---
title: "Comparison of *in silico* prediction of *Mycobacterium tuberculosis* spoligotypes and lineages from whole genome sequences"
output: 
  bookdown::word_document2: 
    fig_caption: yes
    table_caption: yes
    number_sections: no
    reference_docx: ../../pipeline/word_template/use_template.docx
bibliography: ../../pipeline/references/all_refs.bib
csl: ../../pipeline/references/scientific-reports.csl
---

```{r setup, include=FALSE, echo = F, warning=F, message=F}

# SETUP ----

rm(list = ls())

knitr::opts_chunk$set(echo = F)
# options(scipen=1, digits=2)
options(scipen=999, digits = 3)
table_font_sz <- 8

```

```{r library, include=FALSE, echo = F, warning=F, message=F}

# library(sjmisc)
library(plyr)
library(dplyr)
library(tibble)
library(stringr)
library(ggplot2)
library(tidyverse)
library(tidyr)
library(janitor)
library(scatterpie)

```

```{r functions, echo = F, warning=F, message=F}

source("https://raw.githubusercontent.com/GaryNapier/Packages_functions/master/Functions.R")

non_num_cols <- function(x){
  # Returns only the non-numeric columns of a dataframe
  x[!(sapply(x, is.numeric))]
}

expand_hierarchy <- function(df, group_by_col_name, hierarchy_to_expand_col_name){
  # Takes df like this:
  #   ID      Group
  # 1 samp_1  4.2.1.1
  # 2 samp_2  1.2.1.2.1
  
  # And makes this:
  #   ID    lin_level_1 lin_level_2 lin_level_3 lin_level_4 lin_level_5   max_lin
  # 1 samp_1          4         4.2       4.2.1     4.2.1.1        <NA>   4.2.1.1
  # 2 samp_2          1         1.2       1.2.1     1.2.1.2   1.2.1.2.1 1.2.1.2.1
  
  split_lins <- stringr::str_split(df[[hierarchy_to_expand_col_name]], "\\.")
  max_lin_len <- max(sapply(split_lins, length))
  mat <- matrix(nrow = length(df[[group_by_col_name]]), ncol = max_lin_len+1)
  mat[, 1] <- df[[group_by_col_name]]
  for(i in 1:nrow(mat)){
    for(lin_level in 1:max_lin_len){
      
      len_lin <- length(split_lins[[i]])
      
      if(lin_level > len_lin){
        mat[i, lin_level+1] <- NA
      }else{
        mat[i, lin_level+1] <- paste0(split_lins[[i]][1:lin_level], collapse = ".")
      }
    }
  }
  
  max_lin <- vector()
  for(i in seq(nrow(mat))){
    max_lin[i] <- mat[i, which.max(sapply(mat[i, -1], len_str))+1]
  }
  mat <- data.frame(cbind(mat, max_lin), stringsAsFactors = F)
  names(mat) <- c("id", paste0("lin_level_", 1:(ncol(mat)-2) ), "max_lin")
  return(mat)
}


top_spol_freq <- function(x, col){
  x %>% 
    group_by_(.dots = lazyeval::lazy(col)) %>% 
    dplyr::count(.dots = lazyeval::lazy(col), spoligotype) %>% 
    dplyr::arrange(desc(n), .by_group = TRUE) %>%
    dplyr::top_n(10, n) %>% 
    data.frame()
}


tab2df <- function(df){
  as.data.frame.matrix(table(df))
}

row_probs <- function(x){
  # Dataframe:
  # fruit   X1 X2 X3
  # mangoes 90 10 20
  # bananas 10 90 80
  # Get the row-wise proportions for each number:
  # fruit   X1     X2     X3
  # mangoes 0.7500 0.0833 0.167
  # bananas 0.0556 0.5000 0.444
  # i.e. mangoes-X1 = 90/(90+10+20) = 0.75
  
  # Strip off the non-numeric col(s)
  x_non_num <- non_num_cols(x)
  # Strip off numeric cols for calculation 
  x <- num_cols(x)
  # Pre-define an empty matrix
  mat <- matrix(nrow = nrow(x), ncol = ncol(x))
  # Loop over rows 
  for(row in seq(nrow(x))){
    # Loop over cols in row
    for(col in seq(ncol(x[row, ]))){
      # Divide the number by the total in the row
      mat[row, col] <- x[row, col]/sum(x[row, ])
    }
  }
  # Put table back together
  cbind(x_non_num, setNames(data.frame(mat), names(x)))
}

col_probs <- function(x){
  # Dataframe:
  # fruit   X1 X2 X3
  # mangoes 90 10 20
  # bananas 10 90 80
  # Get the col-wise proportions for each number:
  # col_probs(x)
  # fruit   L1  L2  L3
  # mangoes 0.9 0.1 0.2
  # bananas 0.1 0.9 0.8
  # i.e. mangoes-X1 = 90/(90+10) = 0.9
  
  # Strip off the non-numeric col(s)
  x_non_num <- non_num_cols(x)
  # Strip off numeric cols for calculation 
  x <- num_cols(x)
  # Pre-define an empty matrix
  mat <- matrix(nrow = nrow(x), ncol = ncol(x))
  # Loop over rows 
  for(row in seq(nrow(x))){
    # Loop over cols in row
    for(col in seq(ncol(x[row, ]))){
      # Divide the number by the total in the row
      mat[row, col] <- x[row, col]/sum(x[ ,col])
    }
  }
  # Put table back together
  cbind(x_non_num, setNames(data.frame(mat), names(x)))
}

sort_df_by_col_name <- function(df, col, decreasing = T){
  df[order(df[, col],  decreasing = decreasing),]
}

rm_dup_group <- function(df, col){
  # If rows of groups are repeated in a col, replace repeats with blank ("")
  # For final display of tables
  # e.g. 
  # in
  # lineage value
  # L1      10
  # L1      20
  # L1      25
  # L2      100
  # L2      3
  # L2      21
  # out
  # lineage value
  # L1      10
  #         20
  #         25
  # L2      100
  #         3
  #         21
  df[which(duplicated(df[col])), col] <- ""
  df
}

pc <- function(x){
  paste0(round(x, 1), "%")
}

list_to_df_group <- function(lst){
  # lst <- list(X = 1:5, Y = LETTERS[1:5])
  # $X
  # [1]  1  2  3  4  5 
  # $Y
  # [1] "A" "B" "C" "D" "E"
  # list_to_df_group(lst)
  #      group values
  # 1      X      1
  # 2      X      2
  # 3      X      3
  # 4      X      4
  # 5      X      5
  # 6      Y      A
  # 7      Y      B
  # 8      Y      C
  # 9      Y      D
  # 10     Y      E
  
  df_list <- list()
  for(i in seq(lst)){
    values_vect <- lst[[i]]
    nm <- names(lst[i])
    group_vect <- rep(nm, length(values_vect))
    df_list[[i]] <- data.frame(group = group_vect, values = values_vect)
  }
  do.call("rbind", df_list)
}

replace_inf <- function(x){
  x[is.infinite(x)] <- 0
  x
}

add_pc_brkt <- function(df, col, rnd = 1){
  pcs <- round(df[, col]/sum(df[, col])*100, rnd)
  df <- fmt(df)
  df[, col] <- paste0(df[, col], " (", pcs, ")")
  df
}

all_dups <- function(df, col){
  duped <- df[duplicated(df[, col]), col]
  duped_df <- df[df[, col] %in% duped, ]
  duped_df[order(duped_df[, col]),]
}


```

```{r variables, echo = F, warning=F, message=F}


```

```{r run-scripts, echo = F, warning=F, message=F}

# source("~/Documents/spolpred/r_scripts/spol_lin_levels_table.R")

```

```{r paths, echo = F, warning=F, message=F}

setwd("~/Documents/spolpred/r_scripts")

data_path <- "../data/"
results_path <- "../results/"
metadata_path <- "../../metadata/"
db_path <- "../../pipeline/db/"

```

```{r files, echo = F, warning=F, message=F}

spol_data_file <- paste0(data_path, "spoligo_lineage.SNPs.csv")
spol_lin_levels_table_file <- paste0(results_path, "spol_lin_levels_table.csv")
family_lookup_file <- paste0(data_path, "family_lookup.csv")
regions_lookup_file <- paste0(db_path, "country_code_lookup.txt")
metadata_file <- paste0(metadata_path, "tb_data_18_02_2021.csv")
animal_file <- paste0(data_path, "animal_spol_data.csv")

lin1_7_ggtree <- paste0(results_path, "lin1_7_ggtree.png")
lin2_ggtree <- paste0(results_path, "lin2_ggtree.png")
lin3_ggtree <- paste0(results_path, "lin3_ggtree.png")
lin4_ggtree <- paste0(results_path, "lin4_ggtree.png")
lin5_6_8_9_La_ggtree <- paste0(results_path, "lin5_6_8_9_La_ggtree.png")

```

```{r read-in-data, echo = F, warning=F, message=F}

spol_data <- read.csv(spol_data_file, header = T, colClasses = c("spoligotype" = "character"))
spol_lin_levels_table <- read.csv(spol_lin_levels_table_file, colClasses = c("spoligotype" = "character"))
family_lookup <- read.csv(family_lookup_file)
regions_lookup <- read.delim(regions_lookup_file)
metadata <- read.csv(metadata_file)
animal <- read.csv(animal_file)

```

```{r clean-metadata, echo = F, warning=F, message=F}

# Clean metadata regions
metadata$subregion <- ifelse(metadata$subregion == "Australia and New Zealand", "Oceana", metadata$subregion)
metadata$subregion <- ifelse(metadata$subregion == "Northern America", "North America", metadata$subregion)
metadata$subregion <- ifelse(metadata$subregion == "#N/A", "Unknown", metadata$subregion)

```

```{r clean-spol-data, echo = F, warning=F, message=F}

# Remove spacers 
spol_data <- dplyr::select(spol_data, -(spacer1:spacer43))

# Blank lineages - all 1.2.2.1 apparently
spol_data$lineage <- ifelse(spol_data$lineage == "", "lineage1.2.2.1", spol_data$lineage)
# Remove 0000000000000000000000000000000000000000000 - error apparently
spol_data <- subset(spol_data, !(spoligotype == "0000000000000000000000000000000000000000000"))

# Clean SIT and family cols
spol_data$SIT <- ifelse(spol_data$SIT == "", "-", spol_data$SIT)
spol_data$family <- ifelse(spol_data$family == "", "-", spol_data$family)

# Separate out all the metadata into lookup tables and data tables
lin_spol_sit_fam <- odr(unique(select(spol_data, lineage, spoligotype, SIT, family)))
sit_fam_spol <- odr(unique(select(spol_data, SIT, family, spoligotype)))
sit_fam <- odr(unique(select(spol_data, SIT, family)))
lin_fam <- odr(unique(select(spol_data, lineage, family)))

# Separate out the data for just correlating lineage and spol

# Remove "lineage" so that the levels can be split out
spol_data$lineage <- gsub("lineage", "", spol_data$lineage)

# Clean family
spol_data$family <- ifelse(spol_data$family == "-", "Unknown", spol_data$family)
spol_data$family <- ifelse(spol_data$family == "Zero-copy", "Unknown", spol_data$family)

```

```{r animal-and-expand-lins-spol-data, echo = F, warning=F, message=F}

# Clean animal spoligotypes (messed up spol when saving to csv and editing in excel)
animal <- merge(select(animal, -(spoligotype)), 
                select(spol_data, sample, spoligotype), 
                by = "sample", all.x = T, sort = F)
animal <- select(animal, sample, lineage, spoligotype, everything())

# Prepare data for r-binding with animal. 

# head(animal)
# sample        lineage spoligotype lin_level_1 lin_level_2 lin_level_3 lin_level_4 lin_level_5
# ERR3275518     La1      1...0          La         La1         La1         La1         La1
# ERR2517357     La1      1...0          La         La1         La1         La1         La1

# Retain SIT and family data with sample as key
samp_sit_fam <- select(spol_data, sample, SIT, family)

# Retain same cols as animal
spol_data <- select(spol_data, sample, lineage, spoligotype)

# Remove and store animal strains - need to process separately
# Add back in after expanding animal strains manually in excel
# animal <- subset(spol_data, grepl("La", lineage))
# write.csv(animal, file = paste0(data_path, "animal_spol_data.csv"), 
#           quote = F, row.names = F)
spol_data <- subset(spol_data, !(grepl("La", lineage)))

# Expand lineages, rbind animal back in and merge
exp <- expand_hierarchy_fill(spol_data, "sample", "lineage")
# data <- merge(rbind(spol_data, animal), exp,
#               by.x = "sample", by.y = "id", all.x = T, 
#               sort = F)
spol_data <- merge(spol_data, exp,
                   by.x = "sample", by.y = "id", all.x = T, 
                   sort = F)

# Add animal back in after processing manually
spol_data <- rbind(spol_data, animal)

```

```{r add-metadata-to-spol-data, echo = F, warning=F, message=F}

# Merge SIT and family back in
spol_data <- merge(spol_data, samp_sit_fam, by = "sample", 
                   all.x = T, sort = F)

# # Clean AFRI - should be either AFRI_1 or AFRI_2
# 
# spol_data$family <- ifelse(spol_data$family == "AFRI" & spol_data$lin_level_1 == "5", 
#                            "AFRI_2", spol_data$family)
# 
# spol_data$family <- ifelse(spol_data$family == "AFRI" & spol_data$lin_level_1 == "6", 
#                            "AFRI_1", spol_data$family)

# Add in family group
spol_data <- merge(spol_data, select(family_lookup, family, family_group), 
                   by = "family", all.x = T, sort = F)

# Add in country and regions
spol_data <- merge(spol_data, select(metadata, wgs_id, country_code, region, subregion), 
                   by.x = "sample", by.y = "wgs_id", all.x = T, sort = F)

# Add WHO region
spol_data <- merge(spol_data, select(regions_lookup, country_code_lower, WHO_region), 
                   by.x = "country_code", by.y = "country_code_lower", all.x = T, sort = F)

# Clean
spol_data$WHO_region <- ifelse(is.na(spol_data$WHO_region), "Unknown", spol_data$WHO_region)


```

```{r clean-results-table, echo = F, warning=F, message=F}

# Split into two tables - one with all results, and one top 5 spols by proportion of samples in lin 

spol_lin_levels_split <- split(spol_lin_levels_table, spol_lin_levels_table$level)

spol_lin_levels_top <- list()
for(level in names(spol_lin_levels_split)){
  
  level_data <- spol_lin_levels_split[[level]]
  level_data_split <- split(level_data, level_data$lineage)
  
  lin_list <- list()
  for(lin in names(level_data_split)){
    
      # Get the top 5 sample proportions and save as separate list
      top_col_prob <- sort(level_data_split[[lin]]$col_prob, decreasing = T)
      top_col_prob <- top_col_prob[1:5]
      
      # print(level_data_split[[lin]][which(level_data_split[[lin]]$col_prob %in% top_col_prob), ])
      lin_list[[lin]] <- level_data_split[[lin]][which(level_data_split[[lin]]$col_prob %in% top_col_prob), ]
  }
  spol_lin_levels_top[[level]] <- do.call("rbind", lin_list)
}

```

```{r clean-results-table-ctnd, echo = F, warning=F, message=F}

# Tidy top results table for display 
# - need to do before r-binding because all dups will be removed, not just the consecutive ones
spol_lin_levels_table_display <- lapply(spol_lin_levels_top, rm_dup_group, "lineage")
spol_lin_levels_table_display <- lapply(spol_lin_levels_table_display, rm_dup_group, "level")

spol_lin_levels_table_display <- do.call("rbind", spol_lin_levels_table_display)

# Need to prefix s otherwise printout is dodgy 
spol_lin_levels_table_display$spoligotype <- paste0("s", spol_lin_levels_table_display$spoligotype)

names(spol_lin_levels_table_display) <- c("Level",
                                          "Lineage",
                                          "Spoligotype",
                                          "SIT",
                                          "Family",
                                          "Proportion in lin.",
                                          "n in lineage",
                                          "% of lin")

write.csv(spol_lin_levels_table_display, 
          file = "../results/spol_lin_levels_table_supp.csv", 
          quote = F, row.names = F)

# spol_lin_levels_table$Level <- ifelse(is.na(spol_lin_levels_table$Level), "", spol_lin_levels_table$Level)

```

```{r basic-numbers-before-filter, echo = F, warning=F, message=F}

n_total_samps_before_filter <- length(spol_data$sample)
n_unique_lins_before_filter <- length(unique(spol_data$lineage))
n_unique_spol_before_filter <- length(unique(spol_data$spoligotype))

```

```{r main-lin-family-group-before-filter, echo = F, warning=F}

# Table of families x main lin before filter
lin_fam_freq_tab_before_filter <- as.data.frame.matrix(table(spol_data$family_group, spol_data$lin_level_1))

# Get numbers for spol families (i.e. rows)
n_samps_family_before_filter <- data.frame(as.list(sort(rowSums(lin_fam_freq_tab_before_filter), 
                                                        decreasing = T)))

```

<!-- FILTER! FILTER! FILTER! FILTER! FILTER! -->
```{r filter-spol-five-samps, echo = F, warning=F}

# Make a copy first
spol_data_unfilt <- spol_data

# Keep only those with 5 or more samples per spoligotype
spol_data <- spol_data %>% group_by(spoligotype) %>% filter(n() > 4) %>% data.frame()

```
<!-- FILTER! FILTER! FILTER! FILTER! FILTER! -->

```{r basic-numbers-after-filter, echo = F, warning=F, message=F}

n_total_samps_after_filter <- length(spol_data$sample)
n_unique_lins_after_filter <- length(unique(spol_data$lineage))
n_unique_spol_after_filter <- length(unique(spol_data$spoligotype))

```

```{r geo, echo = F, warning=F, message=F}

# Merge in WHO regions
# metadata <- merge(metadata,
#                   select(regions_lookup, country_code_lower, WHO_region),
#                   by.x = "country_code",
#                   by.y = "country_code_lower",
#                   all.x = T,
#                   sort = F)

# Add unknown
# metadata$WHO_region <- ifelse(is.na(metadata$WHO_region), "Unknown", metadata$WHO_region)

# Merge metadata to spol family data
# geo_df <- select(metadata, wgs_id, country_code, country, region, subregion, WHO_region)
# lin_fam_geo_df <- merge(lin_fam_merged, geo_df,
#                         by.x = "sample", by.y = "wgs_id", all.x = T, sort = F)

# Make table of region and spol family
# region_family_tab <- as.data.frame.matrix(table(lin_fam_geo_df$subregion, lin_fam_geo_df$family_group))
# region_family_tab <- as.data.frame.matrix(table(lin_fam_geo_df$family, lin_fam_geo_df$WHO_region))C
# region_family_tab <- cbind(Region = row.names(region_family_tab), region_family_tab)

# CORRECT - Using spol_data
region_family_tab <- as.data.frame.matrix(table(spol_data$family, spol_data$WHO_region))
# CORRECT - Using spol_data

# # Get geo numbers
n_samps_geo <- data.frame(as.list(sort(colSums(region_family_tab), decreasing = T) ))
# 
# # Take out rows with < 10 
# region_family_tab <- region_family_tab[rowSums(region_family_tab) >= 10, ]
# 
# # Wrangle for plot
# # Normalise across col
# region_family_tab <- cbind(Family = row.names(region_family_tab), 
#       data.frame(apply(num_cols(region_family_tab), 2, function(x) {round(x/sum(x), 3)})))
# 
# # Clean - re-arrange unknown
# unknown_row <- subset(region_family_tab, Family == "Unknown")
# region_family_tab <- subset(region_family_tab, !(Family == "Unknown"))
# region_family_tab <- rbind(region_family_tab, unknown_row)
# 
# # Rename
# region_family_tab <- dplyr::rename(region_family_tab, 
#                                    E.Med. = Eastern.Mediterranean, 
#                                    S.E.Asia = South.East.Asia, 
#                                    W.Pacific = Western.Pacific)

# # Make long format for heatmap
# region_family_tab_plot <- region_family_tab %>% gather(Region, value, -Family)
# 
# # Plot
# max_n <- round_any(max(region_family_tab_plot$value), 1000)
# leg_ticks <- c(0, 10, 100, 1000, 2000)
# leg_breaks <- replace_inf(log(leg_ticks))
# # region_family_plot <- ggplot(data = region_family_tab_plot, 
# #             aes(x = Family, y = Region, fill = log(value+1))) +
# 
# region_family_plot <- ggplot(data = region_family_tab_plot, 
#             aes(x = Region, y = Family, fill = value)) +
#   geom_tile()+
#   geom_text(aes(label = value), color = "white", size = 3)+ 
#   xlab("WHO region")+
#   scale_y_discrete(limits=rev)+
#   theme_bw()+
#   theme(axis.text.x = element_text(angle = 45, hjust = 1), 
#         panel.grid.major = element_blank(), 
#         panel.grid.minor = element_blank(), 
#         panel.background = element_blank())+
#   coord_fixed(ratio=0.2)
# 
# region_family_plot_file <- paste0(results_path, "region_family_plot.png")
# ggsave(plot = region_family_plot, 
#        file = region_family_plot_file, 
#        width = 1500/7, height = 1000/5, units = "mm")

```

```{r table-1-cut, echo = F, warning=F, message=F}

# spol_pivot_lv1 <- reshape2::dcast(spol_data, lin_level_1 ~ 'n_spol', 
#                                   value.var = "spoligotype", fun.aggregate = len_uniq)
# 
# n_pivot_lv2 <- reshape2::dcast(spol_data, lin_level_2 ~ 'n_samp', 
#                                value.var = "sample", fun.aggregate = len_uniq)
# spol_pivot_lv2 <- reshape2::dcast(spol_data, lin_level_2 ~ 'n_spol', 
#                                   value.var = "spoligotype", fun.aggregate = len_uniq)
# 
# table_1_lv1 <- data.frame(cbind(to_table(n_pivot_lv1, "col"), to_table(spol_pivot_lv1, "col")))
# table_1_lv1 <- dplyr::select(table_1_lv1, -(lin_level_1.1),  -(Total), -(Total.1))
# table_1_lv1 <- data.frame(cbind(level = rep("1", nrow(table_1_lv1)), table_1_lv1))
# 
# table_1_lv2 <- data.frame(cbind(to_table(n_pivot_lv2, "col"), to_table(spol_pivot_lv2, "col")))
# table_1_lv2 <- dplyr::select(table_1_lv2, -(lin_level_2.1),  -(Total), -(Total.1))
# table_1_lv2 <- data.frame(cbind(level = rep("2", nrow(table_1_lv2)), table_1_lv2))
# 
# table_1 <- rbind_force(table_1_lv1, table_1_lv2)

```

```{r spol-lin-results, echo = F, warning=F, message=F}

# Split out by lin level
spol_lin_levels_table_split <- split(spol_lin_levels_table, spol_lin_levels_table$level)

# Make lists to store stats for each level
pure_n_list <- list() # N spols pure at each level
pure_pc_list <- list() # Overall % of spols pure at each level
med_pc_samps_pure_list <- list() # Take the median of this vector

for(level in names(spol_lin_levels_table_split)){
  
  # Table of all the spoligotypes, pure and unpure
  all_spols_at_level <- spol_lin_levels_table_split[[level]]
  
  # Subset the pure ones
  pure <- subset(all_spols_at_level, prob == 1)
  
  # Add 'lv' to make it easier to subset lists later
  new_lv_name <- paste0("lv", level)
  
  # N spols pure at a level
  pure_n_list[[new_lv_name]] <- length(pure$spoligotype)
  # What % of all the spols at the level are pure?
  pure_pc_list[[new_lv_name]] <- (pure_n_list[[new_lv_name]]/length(all_spols_at_level$spoligotype))*100
  
  # Save the median of this value
  med_pc_samps_pure_list[[new_lv_name]] <- round(median(pure$col_prob), 2)
  
}

```

<!-- TABLES -->
```{r table-1, echo = F, warning=F, message=F}

# ----------------------
# UNFILTERED

# Lineage (lv1)

# How many samples in L1, L2, L3 etc.. 
n_pivot_lv1 <- reshape2::dcast(spol_data_unfilt, lin_level_1 ~ 'n_samp', 
                               value.var = "sample", fun.aggregate = len_uniq)
# How many sublins in L1, L2, L3 etc..
mem_pivot_lv1 <- reshape2::dcast(spol_data_unfilt, lin_level_1 ~ 'n_mem', 
                               value.var = "lineage", fun.aggregate = len_uniq)
# Merge
lin_lv1_pivot <- merge(mem_pivot_lv1, n_pivot_lv1, by = "lin_level_1", all.x = T, sort = F)
# Add % of samples 
lin_lv1_pivot$pc <- round(lin_lv1_pivot$n_samp/(sum(lin_lv1_pivot$n_samp))*100, 1)


# Spol family

# How many samples per main spol family
n_pivot_fam <- reshape2::dcast(spol_data_unfilt, family_group ~ 'n_samp', 
                               value.var = "sample", fun.aggregate = len_uniq)

# Aggregate "other"
n_pivot_fam_other <- subset(n_pivot_fam, n_samp < 297)
other_df <- data.frame(family_group = "Other", n_samp = sum(n_pivot_fam_other$n_samp))
n_pivot_fam <- subset(n_pivot_fam, n_samp >= 297)
n_pivot_fam <- n_pivot_fam %>% arrange(desc(n_samp))
n_pivot_fam <- rbind(n_pivot_fam, other_df)

# How many spols in each spol fam?
mem_pivot_fam <- reshape2::dcast(spol_data_unfilt, family_group ~ 'n_mem', 
                                 value.var = "spoligotype", fun.aggregate = len_uniq)
# Aggregate "other"
# Make sure same rows as above
mem_pivot_fam_other <- subset(mem_pivot_fam, 
                              mem_pivot_fam$family_group %in% n_pivot_fam_other$family_group)
other_df <- data.frame(family_group = "Other", n_mem = sum(mem_pivot_fam_other$n_mem))
mem_pivot_fam <- subset(mem_pivot_fam, 
                        !(mem_pivot_fam$family_group %in% n_pivot_fam_other$family_group))
mem_pivot_fam <- rbind(mem_pivot_fam, other_df)
# Merge clean and add pc col
fam_pivot <- merge(n_pivot_fam, mem_pivot_fam, by = "family_group", sort = F)
fam_pivot <- dplyr::select(fam_pivot,family_group, n_mem, n_samp)
fam_pivot$pc <- round(fam_pivot$n_samp/sum(fam_pivot$n_samp)*100, 1)

# WHO region

# Subset metadata to those in the spol data
# who <- subset(metadata, metadata$wgs_id %in% spol_data_unfilt$sample)

# How many samples per WHO region?
n_pivot_who <- reshape2::dcast(spol_data_unfilt, WHO_region ~ 'n_samp', 
                               value.var = "sample", fun.aggregate = len_uniq)

# How many countries per WHO region?
mem_pivot_who <- reshape2::dcast(spol_data, WHO_region ~ 'n_mem', 
                                 value.var = "country_code", fun.aggregate = len_uniq)

# Merge clean and add pc col
who_pivot <- merge(mem_pivot_who, n_pivot_who, by = "WHO_region")
who_pivot <- who_pivot %>% arrange(desc(n_samp))
who_pivot$pc <- round(who_pivot$n_samp/sum(who_pivot$n_samp)*100, 1)

# ----------------------

# FILTERED

# Lineage (lv1)

# How many samples in L1, L2, L3 etc.. 
n_pivot_lv1_filt <- reshape2::dcast(spol_data, lin_level_1 ~ 'n_samp_filt', 
                               value.var = "sample", fun.aggregate = len_uniq)

# Add % of samples 
n_pivot_lv1_filt$pc_filt <- round(n_pivot_lv1_filt$n_samp_filt/(sum(n_pivot_lv1_filt$n_samp_filt))*100, 1)

# Spols

# How many samples per main spol family
n_pivot_fam_filt <- reshape2::dcast(spol_data, family_group ~ 'n_samp_filt', 
                               value.var = "sample", fun.aggregate = len_uniq)

# Aggregate "other"
n_pivot_fam_other_filt <- subset(n_pivot_fam_filt, n_samp_filt < 244)
other_df_filt <- data.frame(family_group = "Other", n_samp_filt = sum(n_pivot_fam_other_filt$n_samp_filt))
n_pivot_fam_filt <- subset(n_pivot_fam_filt, n_samp_filt >= 244)
n_pivot_fam_filt <- n_pivot_fam_filt %>% arrange(desc(n_samp_filt))
n_pivot_fam_filt <- rbind(n_pivot_fam_filt, other_df_filt)
n_pivot_fam_filt$pc_filt <- round(n_pivot_fam_filt$n_samp_filt/sum(n_pivot_fam_filt$n_samp_filt)*100, 1)

# WHO region

n_pivot_who_filt <- reshape2::dcast(spol_data, WHO_region ~ 'n_samp_filt', 
                               value.var = "sample", fun.aggregate = len_uniq)

n_pivot_who_filt$pc_filt <- round(n_pivot_who_filt$n_samp_filt/sum(n_pivot_who_filt$n_samp_filt)*100, 1)


# ----------------------

# Put together

# Merge filt and unfilt

# Lineage (lv1)

lin_lv1_pivot <- left_join(lin_lv1_pivot, n_pivot_lv1_filt, by = "lin_level_1")

# Spols

fam_pivot <- left_join(fam_pivot, n_pivot_fam_filt, by = "family_group")

# WHO region
who_pivot <- left_join(who_pivot, n_pivot_who_filt, by = "WHO_region")



table_1 <- rbind_force(lin_lv1_pivot, rbind_force(fam_pivot, who_pivot))
table_1 <- cbind(Characteristic = c(rep("Lineage", nrow(lin_lv1_pivot)), 
                                    rep("Spoligotype", nrow(fam_pivot)), 
                                    rep("WHO region", nrow(who_pivot))), 
                 table_1)

# Make copy for display
table_1_display <- table_1

# Clean
table_1_display <- rm_dup_group(table_1_display, "Characteristic")
table_1_display <- fmt(table_1_display)
names(table_1_display) <- c("Characteristic", 
                            "", 
                            "[# members]*", 
                            sprintf("n=%s", n_total_samps_before_filter), 
                            "%", 
                            sprintf("n=%s**", n_total_samps_after_filter), 
                            "%")

```

```{r table-2, echo = F, warning=F, message=F}

# Table 2
# Numbers of samples and unique spoligotypes for sub-lineages* across 27,933 M. tuberculosis

# NB USE FILTERED DATASET - spol_data

n_pivot_lv1 <- reshape2::dcast(spol_data, lin_level_1 ~ 'n_samp', 
                               value.var = "sample", fun.aggregate = len_uniq)

spol_pivot_lv1 <- reshape2::dcast(spol_data, lin_level_1 ~ 'n_spol',
                                  value.var = "spoligotype", fun.aggregate = len_uniq)

fam_pivot_lv1 <- reshape2::dcast(spol_data, lin_level_1 ~ 'n_fam',
                                  value.var = "family", fun.aggregate = len_uniq)

n_pivot_lv1 <- add_pc_brkt(n_pivot_lv1, "n_samp")
spol_pivot_lv1 <- add_pc_brkt(spol_pivot_lv1, "n_spol")
fam_pivot_lv1 <- add_pc_brkt(fam_pivot_lv1, "n_fam")

lv1_df <- data.frame(cbind(lineage = n_pivot_lv1$lin_level_1,
                           sublineage = rep("Overall", nrow(n_pivot_lv1)), 
                           n_samp = n_pivot_lv1$n_samp, 
                           n_spol = spol_pivot_lv1$n_spol, 
                           n_fam = fam_pivot_lv1$n_fam))


# Level 2
n_pivot_lv2 <- reshape2::dcast(spol_data, lin_level_1 + lin_level_2 ~ 'n_samp', 
                                   value.var = "sample", fun.aggregate = len_uniq)

spol_pivot_lv2 <- reshape2::dcast(spol_data, lin_level_1 + lin_level_2 ~ 'n_spol', 
                                   value.var = "spoligotype", fun.aggregate = len_uniq)

fam_pivot_lv2 <- reshape2::dcast(spol_data, lin_level_1 + lin_level_2 ~ 'n_fam', 
                                   value.var = "family", fun.aggregate = len_uniq)

n_pivot_lv2 <- add_pc_brkt(n_pivot_lv2, "n_samp")
spol_pivot_lv2 <- add_pc_brkt(spol_pivot_lv2, "n_spol")
fam_pivot_lv2 <- add_pc_brkt(fam_pivot_lv2, "n_fam")

lv2_df <- data.frame(cbind(lineage = n_pivot_lv2$lin_level_1,
                          sublineage = n_pivot_lv2$lin_level_2, 
                          n_samp = n_pivot_lv2$n_samp, 
                          n_spol = spol_pivot_lv2$n_spol, 
                          n_fam = fam_pivot_lv2$n_fam))

# Split and r-bind the two tables
lv1_df_split <- split(lv1_df, lv1_df$lineage)
lv2_df_split <- split(lv2_df, lv2_df$lineage)

for(i in seq(length(lv1_df_split))){
  lv2 <- lv2_df_split[[i]]
  if(nrow(lv2) > 1){
    lv2_df_split[[i]] <- rbind(lv1_df_split[[i]], lv2)
  }else{
    lv2_df_split[[i]] <- lv1_df_split[[i]]
  }
}
# Put back together
lv1_lv2_n_spol_fam <- do.call("rbind", lv2_df_split)

# Clean
lv1_lv2_n_spol_fam <- rm_dup_group(lv1_lv2_n_spol_fam, "lineage")
names(lv1_lv2_n_spol_fam) <- c("Lineage", 
                               "Sub-lineage", 
                               "N (%)", 
                               "No. spoligotypes (%)\\*", 
                               "No. families (%)")

```

<!-- S1 -->
```{r rare-spols-table, echo = F, warning=F, message=F}

# Get the ones that aren't in the filtered df
rare_spol_df <- subset(spol_data_unfilt, !(spol_data_unfilt$sample %in% spol_data$sample))
rare_spol_df <- select(rare_spol_df, sample, spoligotype, lineage, family, SIT)
# Pivot
rare_spol_df <- reshape2::dcast(rare_spol_df, spoligotype+lineage+family+SIT ~ 'n', 
                value.var = "sample", fun.aggregate = len_uniq)

# Mark dups
dups <- all_dups(rare_spol_df, "spoligotype")
rare_spol_df$dup <- ifelse(rare_spol_df$spoligotype %in% unique(dups$spoligotype), "*", "")

# Clean
rare_spol_df <- rare_spol_df %>% arrange(spoligotype)                 
rare_spol_df$spoligotype <- paste0("s", rare_spol_df$spoligotype)
names(rare_spol_df) <- c("Spoligotype", "Lineage", "Family", "SIT", "N", ">1 lineage")

rare_spols_table_file <- "../results/rare_spol.csv"
write.csv(rare_spol_df, file = rare_spols_table_file, quote = F, row.names = F)

```

```{r rare-spols-numbers, echo = F, warning=F, message=F}

# N unique rare spols
rare_spols_n <- len_uniq(rare_spol_df$Spoligotype)
# Get main lin
rare_spol_df$main_lin <- str_sub(rare_spol_df$Lineage, 1, 1)
# Table of rare spols per lin
rare_spol_lin_tab <- reshape2::dcast(rare_spol_df, main_lin ~ 'n', 
                                     value.var = "Spoligotype", 
                                     fun.aggregate = len_uniq)
# Sort
rare_spol_lin_tab <- rare_spol_lin_tab[order(-rare_spol_lin_tab[,"n"]), ]
# Get % - note divide by count of unique spols because duplicates across lineages
rare_spol_lin_tab$pc <- trimws(fmt_pc(rare_spol_lin_tab$n/rare_spols_n, 1))

# Get %
rare_spol_L4_pc <- subset(rare_spol_lin_tab, main_lin == "4")$pc
rare_spol_L1_pc <- subset(rare_spol_lin_tab, main_lin == "1")$pc
rare_spol_L3_pc <- subset(rare_spol_lin_tab, main_lin == "3")$pc

# Other
rare_other <- subset(rare_spol_lin_tab, !(main_lin %in% c("4", "1", "3")))
rare_other_pc <- fmt_pc(sum(rare_other$n)/rare_spols_n, 1)

```

<!-- S2 TABLE-->
```{r s-2, echo = F, warning=F, message=F}

# Supplementary table 2
# "Table of spoligotypes (within families), N samples, N sublineages; main sub-lineages % (<5% other); WHO region %; F statistic of heterogeneity….?? [AT LOWEST LEVEL]"

# Spol Family	N samples	N sublineages	Main sublineages (%)	Africa	Europe	Americas	Corr.
# 0..1 X	    1000	2 (1.1,1.2)	1.1 (70), 2.1 (35), 3.1.1 (10)	10% of samples within Africa are this			

# Keep only spols with at least 5 samps
# lin_fam_geo_df_filt <- lin_fam_geo_df %>% group_by(spoligotype) %>% filter(n() > 4) %>% data.frame()

lv4 <- subset(spol_lin_levels_table, level == "4")

# Family (from SIT) and number of samples
# spol_fam_n <- reshape2::dcast(lin_fam_geo_df, spoligotype + family ~ 'n', 
#                  value.var = 'sample', fun.aggregate = len_uniq)
# spol_fam_n <- reshape2::dcast(spol_data, spoligotype + family ~ 'n', 
#                  value.var = 'sample', fun.aggregate = len_uniq)
fam_n <- reshape2::dcast(spol_data, family_group + family ~ 'n', 
                 value.var = 'sample', fun.aggregate = len_uniq)
# Subset to ones with at least 5 samps
# spol_fam_n <- subset(spol_fam_n, n >= 5)

# Number of sublins spol is in
# spol_n_sublin <- reshape2::dcast(lv4, spoligotype ~ 'n_sublin', 
#                                  value.var = 'lineage', fun.aggregate = len_uniq)
fam_n_sublin <- reshape2::dcast(lv4, family ~ 'n_sublin', 
                                 value.var = 'lineage', fun.aggregate = len_uniq)

# 'Main' (>5%) sublins
# lv4_split <-  split(lv4, lv4$spoligotype)
lv4_split <-  split(lv4, lv4$family)
main_sublins <- lapply(lv4_split, function(x){
  x <- x[order(-x$freq), ]
  pcs <- x$freq/sum(x$freq)
  which_pcs_gr_5 <- which(pcs >= 0.05)
  pcs_gr_5 <- round(pcs[which_pcs_gr_5]*100, 1)
  # lins_gr_5 <- x[which_pcs_gr_5, "lineage"]
  lins_SIT_gr_5 <- paste0(x[which_pcs_gr_5, "lineage"], " [", x[which_pcs_gr_5, "SIT"], "]")
  lins_pcs <- paste0(lins_SIT_gr_5, " (", pcs_gr_5, ")", collapse = "; ")
  # data.frame(spoligotype = unique(x$spoligotype), 
  #                  main_sublins = lins_pcs)
  data.frame(family = unique(x$family), 
                   main_sublins = lins_pcs)
})

main_sublins <- do.call("rbind", main_sublins)

# WHO regions
# who_tab <- as.data.frame.matrix(table(lin_fam_geo_df$spoligotype, lin_fam_geo_df$WHO_region))
# who_tab <- as.data.frame.matrix(table(spol_data$spoligotype, spol_data$WHO_region))
who_tab <- as.data.frame.matrix(table(spol_data$family, spol_data$WHO_region))
# Subset to ones with at least 5 samps
# who_tab <- who_tab[row.names(who_tab) %in% spol_fam_n$spoligotype, ]
# Get percent per col (region)
who_tab <- apply(who_tab, 2, function(x){
  round((x/sum(x))*100, 2)
  })
# Add spol as col
# who_tab <- data.frame(cbind(spoligotype = row.names(who_tab), who_tab))
who_tab <- data.frame(cbind(family = row.names(who_tab), who_tab))
# Drop unknown
who_tab <- select(who_tab, -Unknown)
# Clean
names(who_tab) <- c("family", "Africa", "Americas", "E.Med.", "Europe", "S.E.Asia", "W.Pacific")

# Correlation metric

# corr_df <- lapply(lv4_split, function(x){
#   max_samps_row <- which.max(x$freq)
#   x[max_samps_row, c("spoligotype", "prob")]
# })
# corr_df <- do.call("rbind", corr_df)


# PUT TOGETHER

cols_1_to_4 <- merge(fam_n, fam_n_sublin, 
                     by = "family", all.x = T, sort = F)

cols_1_to_5 <- merge(cols_1_to_4, main_sublins, 
                     by = "family", all.x = T, sort = F)

s2 <- merge(cols_1_to_5, who_tab, 
                       by = "family", all.x = T, sort = F)

# s2 <- merge(cols_1_to_who, corr_df, 
#                        by = "spoligotype", all.x = T, sort = F)

# Clean
s2 <- select(s2, family_group, everything())
# s2 <- s2 %>% arrange(spoligotype)
# s2 <- s2 %>% arrange(family)
# s2$spoligotype <- paste0("s", s2$spoligotype)
# s2 <- dplyr::rename(s2, Spoligotype = spoligotype, 
#              Family = family, 
#              "N samples" = n, 
#              "N sublineages" = n_sublin,
#              "Main sublineages (%)" = main_sublins,
#              "Correlation metric" = prob)
s2 <- dplyr::rename(s2, "Family group" = family_group, 
             Family = family, 
             "N samples" = n, 
             "N sublineages" = n_sublin,
             "Main sublineages [SIT] (%)" = main_sublins)

s2_table_file <- "../results/s2_table.csv"
write.csv(s2, file = s2_table_file, quote = F, row.names = F)

```

<!-- S3 TABLE -->
```{r main-lin-family-group, echo = F, warning=F, message=F}

# What is the correspondence between main lin and the (main) spol families?

# Clean
# family_lookup <- subset(family_lookup, !(family == "Zero-copy"))

# # Merge lineage into family lookup table and pull unique main lineage and family group
# lin_fam <- select(spol_data, spoligotype, sample, lineage, family)
# lin_fam_merged <- merge(lin_fam, family_lookup, by = "family", all.x = T, sort = F)
# lin_fam_merged$main_lin <- substr(lin_fam_merged$lineage, 1, 1)
# lin_fam_merged$main_lin <- ifelse(grepl("La", lin_fam_merged$lineage), "La", lin_fam_merged$main_lin)

# manu <- subset(spol_data, family_group == "Manu")
# manu_spol <- merge(manu, select(spol_data, sample, spoligotype), by = "sample")
# manu$spoligotype <- paste0("s", manu$spoligotype)
# write.csv(manu, "../results/manu.csv", row.names = F, quote = F)

# Find the anomalous main lin-family groups - ones with just a few samples
# e.g. some L1 samps are AFRI, which is clearly not correct
# lin_fam_freq_tab <- as.data.frame.matrix(table(lin_fam_merged$family_group, lin_fam_merged$main_lin))
lin_fam_freq_tab <- as.data.frame.matrix(table(spol_data$family_group, spol_data$lin_level_1))

# Get numbers for spol families
n_samps_family <- data.frame(as.list(sort(rowSums(lin_fam_freq_tab), decreasing = T)))

# Clean and add totals for display
lin_fam_freq_tab <- cbind(Family = row.names(lin_fam_freq_tab), lin_fam_freq_tab)
lin_fam_freq_tab$Family <- ifelse(lin_fam_freq_tab$Family == "Manu_3", "Manu 3", lin_fam_freq_tab$Family)
lin_fam_freq_tab$Family <- ifelse(lin_fam_freq_tab$Family == "Manu_ancestor", "Manu ancestor",
                                  lin_fam_freq_tab$Family)
lin_fam_freq_tab <- adorn_totals(lin_fam_freq_tab, where = c("row", "col"))

# # Make a table of the 'proper' correspondence between main lin and family group, 
# # taking out the anomalous ones from the freq table
# main_lin_family_group <- unique(select(lin_fam_merged, main_lin, family_group))
# main_lin_family_group <- subset(main_lin_family_group, !is.na(family_group))
# main_lin_family_group <- subset(main_lin_family_group, !(family_group == "Unknown"))
# main_lin_family_group <- odr(main_lin_family_group)
# 
# main_lin_family_group <- subset(main_lin_family_group, !(main_lin == "1" & family_group == "AFRI"))
# main_lin_family_group <- subset(main_lin_family_group, !(main_lin == "4" & family_group == "AFRI"))
# main_lin_family_group <- subset(main_lin_family_group, !(main_lin == "1" & family_group == "Beijing"))
# main_lin_family_group <- subset(main_lin_family_group, !(main_lin == "3" & family_group == "Beijing"))
# main_lin_family_group <- subset(main_lin_family_group, !(main_lin == "5" & family_group == "Beijing"))
# main_lin_family_group <- subset(main_lin_family_group, !(main_lin == "3" & family_group == "BOV"))
# main_lin_family_group <- subset(main_lin_family_group, !(main_lin == "1" & family_group == "CAS"))
# main_lin_family_group <- subset(main_lin_family_group, !(main_lin == "2" & family_group == "CAS"))
# main_lin_family_group <- subset(main_lin_family_group, !(main_lin == "4" & family_group == "CAS"))
# main_lin_family_group <- subset(main_lin_family_group, !(main_lin == "5" & family_group == "CAS"))
# main_lin_family_group <- subset(main_lin_family_group, !(main_lin == "4" & family_group == "EAI"))
# main_lin_family_group <- subset(main_lin_family_group, !(main_lin == "1" & family_group == "PINI2"))
# main_lin_family_group <- subset(main_lin_family_group, !(main_lin == "4" & family_group == "PINI2"))
# main_lin_family_group <- subset(main_lin_family_group, !(main_lin == "3" & family_group == "T"))
# 
# main_lin_family_group <- rm_dup_group(main_lin_family_group, "main_lin")
# 
# names(main_lin_family_group) <- c("Main lineage", "Spoligotype family group")

# Manu

manu_3 <- subset(lin_fam_freq_tab, Family == "Manu 3")
manu_anc <- subset(lin_fam_freq_tab, Family == "Manu ancestor")

manu_total <- sum(manu_3$Total, manu_anc$Total)

manu_3_n <- manu_3$`3`
# fmt_pc(manu_3_n/manu_total, 1)

manu_anc_n <- manu_anc$`2`



```

<!-- S4 TABLE -->
```{r lowest-lvl-spol-split, echo = F, warning=F, message=F}

# Find spoligotypes which offer greater resolution to the lowest lineage 
# In other words find at least two spols associated with a (lowest level) lin (after filters)

# Take lowest level
lv4 <- spol_lin_levels_split$`4`

# Split by lin
lv4_split <- split(lv4, lv4$lineage)

# Filter to those spols accounting for >= 20% of samples and >= 20 samples in that lin 
# and a prob score >=0.50
lv4_split_filt <- lapply(lv4_split, function(x){
  subset(x, freq >= 20 & col_prob >= 20 & prob >= 0.5)
})
# Then remove the remaining lins where there is only one spol left 
# (need at least 2 to give more resolution to the lowest level)
lv4_split_filt <- lv4_split_filt[unlist(lapply(lv4_split_filt, nrow)) >= 2]
lv4_filt <- do.call("rbind", lv4_split_filt)

# Make copy for display
lv4_filt_display <- lv4_filt

# Add "s" before writing to csv
lv4_filt_display$spoligotype <- paste0("s", lv4_filt_display$spoligotype)

names(lv4_filt_display) <- c("Level", "Lineage", "Spoligotype", "SIT", "Family",
                     "Proportion in lin.", "n in lineage", "% of lin")

write.csv(lv4_filt_display, file = "../results/lv4_filt.csv", row.names = F, quote = F)

```


<!-- FIGURES -->

<!-- OLD -->
```{r spol-lin-results-plot, echo = F, warning=F, message=F}

# spol_lin_levels_table$col_prob_log10 <- log10(spol_lin_levels_table$col_prob)
# spol_lin_levels_table$col_prob_log10 <- ifelse(is.infinite(spol_lin_levels_table$col_prob_log10), 
#                                                min(spol_lin_levels_table$col_prob_log10[!is.infinite(spol_lin_levels_table$col_prob_log10)]),
#                                                spol_lin_levels_table$col_prob_log10)
# 
# pure_pc_df <- list_to_df_group(pure_pc_list)
# pure_pc_df$group <- 1:4
# 
# y_A <- seq(0, 2, 0.5)
# y_B <- seq(0, 10, 2) 
# y_C <- seq(20, 50, 10) 
# y_D <- seq(60, 100, 20)
# y_ax <- c(y_A, y_B, y_C, y_D)
# spol_lin_results_plot <- ggplot()+
#   geom_boxplot(data = spol_lin_levels_table, aes(x = as.factor(level), y = col_prob))+
#   geom_line(data = pure_pc_df, aes(x=group, y=values, group=1), color="red", size = 1)+
#   geom_point(data = pure_pc_df, aes(x=group, y=values), size = 3, colour = "blue")+
#   xlab("Lineage level")+
#   ylab("Percentage")+
#   scale_y_log10(breaks = y_ax)+
#   theme_bw()
# spol_lin_results_plot_file <- "../results/spol_lin_results_plot.png"
# 
# ggsave(file = spol_lin_results_plot_file, plot = spol_lin_results_plot, width = 1100/5, height = 700/5, units = "mm")

```
<!-- OLD -->
```{r level-prob-hist, echo = F, warning=F, message=F}

# spol_lin_levels_table$main_lin <- substr(spol_lin_levels_table$lineage, 1, 1)
# 
# spol_lin_levels_table$main_lin <- ifelse(spol_lin_levels_table$main_lin == "L", "La", 
#                                          spol_lin_levels_table$main_lin)
# 
# spol_lin_levels_table <- spol_lin_levels_table %>% 
#   mutate(prob_group = case_when(prob == 1 ~ '1',
#                                 prob < 1 & prob >= 0.9 ~ '0.9-0.99',
#                                 prob < 0.9 & prob >= 0.8 ~ '0.8-0.89', 
#                                 prob < 0.8 & prob >= 0.7 ~ '0.7-0.79', 
#                                 prob < 0.7 & prob >= 0.6 ~ '0.6-0.69', 
#                                 prob < 0.6 & prob >= 0.5 ~ '0.5-0.59', 
#                                 prob < 0.5 & prob >= 0.4 ~ '0.4-0.49', 
#                                 prob < 0.4 & prob >= 0.3 ~ '0.3-0.39', 
#                                 prob < 0.3 & prob >= 0.2 ~ '0.2-0.29', 
#                                 prob < 0.2 & prob >= 0.1 ~ '0.1-0.19', 
#                                 prob < 0.1 & prob >= 0 ~ '0-0.09'))
# 
# prob_group_pivot <- reshape2::dcast(data = spol_lin_levels_table, prob_group ~ level)
# prob_group_pivot <- prob_group_pivot[rev(1:nrow(prob_group_pivot)), ]
# 
# 
# level_prob_hist <- ggplot(spol_lin_levels_table, aes(x = prob, fill = main_lin))+
#   geom_histogram(bins = 11, colour = "black", lwd=0.1)+
#   scale_x_continuous(breaks = seq(0, 1, 0.1))+
#   labs(fill = "Lineage")+
#   xlab("Correlation score")+
#   facet_wrap( ~ level)+
#   theme_bw()

# level_prob_hist <- ggplot(spol_lin_levels_table, aes(x = prob_group, fill = main_lin))+
#   geom_histogram(bins = 11, colour = "black", lwd=0.1, stat = "count")+
#   # scale_x_continuous(breaks = seq(0, 1, 0.1))+
#   # scale_x_discrete(breaks = seq(0, 1, 0.1))+
#   labs(fill = "Lineage")+
#   xlab("Correlation score")+
#   facet_wrap( ~ level)+
#   theme_bw()+
#   theme(axis.text.x = element_text(angle=45, hjust = 1))

# level_prob_hist_file <- "../results/level_prob_hist.png"
# ggsave(plot = level_prob_hist, file = level_prob_hist_file, 
#        width = 1100/6, height = 700/6, units = "mm")

```

<!-- FIGURE 1 -->
```{r fam-lin-bar, echo = F, warning=F, message=F}

# Barplot - x = Family, y = n samps, col = main lin, number on top

fam_lin_n <- reshape2::dcast(spol_data, family_group + lin_level_1 ~ 'n', 
                      value.var = "sample", fun.aggregate = len_uniq)

fam_n <- reshape2::dcast(spol_data, family_group ~ 'n', 
                      value.var = "sample", fun.aggregate = len_uniq)

y_ticks <- c(0, seq(500, max(fam_lin_n$n), 500))

fam_lin_n_bar <- ggplot()+
  geom_bar(data = fam_lin_n, aes(x = family_group, y = n, fill = lin_level_1), 
           stat = "identity", width=0.7, colour = "black", size = 0.2)+
  xlab("Family")+
  ylab("N")+
  geom_text(data = fam_n, aes(x = family_group, y = n, label = n), vjust=-0.3, size=3.5)+
  scale_y_continuous(breaks = y_ticks)+
  theme_bw()+
  theme(axis.text.x = element_text(angle = 45, hjust = 1))+
  guides(fill=guide_legend(title="Lineage"))

fam_lin_n_bar_file <- "../results/fam_lin_n_bar.png"
ggsave(plot = fam_lin_n_bar, file = fam_lin_n_bar_file, 
       width = 1100/6, height = 700/6, units = "mm")

# lv4 <- merge(lv4, select(family_lookup, family, family_group), 
#              by = "family", all.x = T, sort = F)
# 
# fam_lin_cnt <- reshape2::dcast(lv4, family_group ~ 'n_lins', 
#                                   value.var = 'lineage', fun.aggregate = len_uniq)
# 
# y_ticks <- c(0, seq(5, max(fam_lin_cnt$n_lins), 5))
# 
# fam_n_lins_bar <- ggplot(data = fam_lin_cnt, aes(x = family_group, y = n_lins))+
#   geom_bar(stat = "identity", width=0.7, fill="steelblue")+
#   xlab("Family")+
#   ylab("N lineages")+
#   scale_y_continuous(breaks = y_ticks)+
#   theme_bw()+
#   theme(axis.text.x = element_text(angle = 45, hjust = 1))
# 
# fam_n_lins_bar_file <- "../results/fam_n_lins_bar.png"
# ggsave(plot = fam_n_lins_bar, file = fam_n_lins_bar_file, 
#        width = 1100/6, height = 700/6, units = "mm")

```

```{r fam-who-bar, echo = F, warning=F, message=F}

# WHO barplot - x = Family, y = n samps, col = WHO regions

# Spols with at least 5 samples 
# fam_who <- subset(lin_fam_geo_df, lin_fam_geo_df$spoligotype %in% lv4$spoligotype)
# Remove unknown WHO
# fam_who <- subset(fam_who, !(WHO_region == "Unknown"))

fam_who <- reshape2::dcast(spol_data, family_group + WHO_region ~ 'n', 
                           value.var = "sample", fun.aggregate = len_uniq)

# fam_who_bar <- ggplot(data = fam_who, aes(x = family_group, y = n))+
#   geom_bar(stat = "identity", width=0.7, fill = WHO_region)+
#   xlab("Family")+
#   ylab("N WHO regions")+
#   scale_y_continuous(breaks = y_ticks)+
#   theme_bw()+
#   theme(axis.text.x = element_text(angle = 45, hjust = 1))

fam_who_n_bar <- ggplot()+
  geom_bar(data = fam_who, aes(x = family_group, y = n, fill = WHO_region), 
           stat = "identity", width=0.7, colour = "black", size = 0.2)+
  xlab("Family")+
  ylab("N")+
  geom_text(data = fam_n, aes(x = family_group, y = n, label = n), vjust=-0.3, size=3.5)+
  scale_y_continuous(breaks = y_ticks)+
  theme_bw()+
  theme(axis.text.x = element_text(angle = 45, hjust = 1))+
  guides(fill=guide_legend(title="WHO region"))

fam_who_n_bar_file <- "../results/fam_who_bar.png"
ggsave(plot = fam_who_n_bar, file = fam_who_n_bar_file, 
       width = 1100/6, height = 700/6, units = "mm")

```

<!-- FIGURE 2 - LOAD IN FIGURES DISPLAY BLOCK - TREES -->

<!-- S1 FIGURE -->
```{r spol-freq-hist, echo = F, warning=F, message=F}

spol_freqs <- as.data.frame.matrix(table(spol_lin_levels_table$spoligotype,
                           spol_lin_levels_table$level)) %>% gather()

spol_freq_hist <- ggplot(gather(spol_freqs), aes(value))+
  geom_histogram(bins = 11)+
  xlab("Frequency of spoligotypes")+
  facet_wrap(~key)+
  theme_bw()

spol_freq_hist_file <- "../results/spol_freq_hist.png"
ggsave(plot = spol_freq_hist, file = spol_freq_hist_file,
       width = 1100/6, height = 700/6, units = "mm")

```

<!-- S2 FIGURE -->
```{r map, echo = F, warning=F, message=F}

# Family

# At least 5 samples
# fam_who <- subset(lin_fam_geo_df, lin_fam_geo_df$spoligotype %in% lv4$spoligotype)
# Remove unknown WHO
# fam_who <- subset(fam_who, !(WHO_region == "Unknown"))
# Make table of region and spol family
# region_family_tab <- as.data.frame.matrix(table(lin_fam_geo_df$subregion, lin_fam_geo_df$family_group))
# region_family_tab <- as.data.frame.matrix(table(fam_who$WHO_region, fam_who$family_group))
region_family_tab <- as.data.frame.matrix(table(spol_data$WHO_region, spol_data$family_group))
region_family_tab <- data.frame(cbind(WHO_region = row.names(region_family_tab), region_family_tab))
# Remove unknown
region_family_tab <- subset(region_family_tab, !(WHO_region == "Unknown"))

# Lineage
# who_lin <- as.data.frame.matrix(table(fam_who$WHO_region, fam_who$main_lin))
who_lin <- as.data.frame.matrix(table(spol_data$WHO_region, spol_data$lin_level_1))
who_lin <- cbind(WHO_region = row.names(who_lin), who_lin)

world <- map_data('world')
# Countries at centre of WHO regions
countries <- c("Democratic Republic of the Congo", "Nicaragua", "Iran", "Belarus", "Bangladesh", "Philippines")
who_country_df <- data.frame(WHO_region = region_family_tab$WHO_region, countries = countries)
# Get long lat 
world_sub <- unique(subset(world, region %in% countries))
# Get mean long lat for key countries
long_lat_means <- data.frame(world_sub %>% group_by(region) %>% summarise_at(vars(long, lat), list(mean)))
who_country_df <- merge(who_country_df, long_lat_means, 
                        by.x = "countries", by.y = "region", 
                        all.x = T, sort = F)

region_family_tab <- merge(who_country_df, region_family_tab, by = "WHO_region", all.x = T, sort = F)
region_family_tab <- merge(region_family_tab, who_lin, by = "WHO_region", all.x = T, sort = F)

fams <- sort(unique(spol_data$family_group))
lins <- sort(unique(spol_data$lin_level_1))

# fam_data <- select(region_family_tab, WHO_region, long, lat, AFRI:X)
# lin_data <- select(region_family_tab, WHO_region, long, lat, "1":La)

fam_cols <- c("#ff0000", "#fa8072", "#dda0dd", "#ff00ff", "#ff1493", "#ffa500", "#ffff00", "#f0e68c", "#006400", "#00ff00", "#E3FF00", "#00fa9a", "#00008b", "#0000ff", "#1e90ff", "#00ffff", "#2f4f4f")
lin_cols <- rainbow(length(lins), alpha = 1, s = 0.6, v = 1)

fam_map <- ggplot(world, aes(long, lat))+
    geom_map(map=world, aes(map_id=region), fill=NA, color="black", size = 0.1)+
    coord_quickmap()+
  geom_scatterpie(data = region_family_tab, aes(x = long, y = lat, r = 15), 
                    cols = fams, color = "black", size = 0.1, legend_name = "Family")+
  scale_fill_manual(values = fam_cols)

fam_map <- fam_map + ggnewscale::new_scale_fill()

fam_lin_map <- fam_map + 
  geom_scatterpie(data = region_family_tab, aes(x = long, y = lat, r = 10),
                   cols = lins, size = 0.1, legend_name = "Lineage")+
  scale_fill_manual(values = lin_cols)+
  theme_void()

fam_lin_map_file <- paste0(results_path, "fam_lin_map.png")
ggsave(plot = fam_lin_map, 
       file = fam_lin_map_file, 
       width = 1500/7, height = 1000/5, units = "mm")

```

```{r supp, echo = F, warning=F, message=F}

# TABLES

# Supplementary table 1
# List of infrequent spoligotypes (<5 samples)
rare_spols_table_s_number <- "1"

# Supplementary table 2
# Table of spoligotypes (within families), N samples, N sublineages; main sub-lineages % (<5% other); WHO region %; F statistic of heterogeneity….??
fam_table_s_number <- "2"

# Supplementary table 3
# Frequency table of samples by main lineage and spoligotype family
lin_fam_freq_tab_s_number <- "3"

# Supplementary table 4
# Spoligotypes discriminating lineages at the lowest level
lv4_filt_display_s_number <- "4"


# FIGURES

# Supplementary figure 1
# Distribution of the number of lineages and sub-lineages present for each spoligotype and spoligotype family. 
# Panel of 4 barplots 
# X-axis 1, 2, 3, 4, … y-axis freq
spol_freq_hist_s_number <- "1"

# Supplementary figure 2
# Global map of WHO regions
# 1.	Spoligotype family
# 2.	Lineage
map_figure_s_number <- "2"

# Supplementary figure 3
# Phylogenetic trees showing lineage or sub-lineage, family and spoligotypes.
trees_figures_s_number <- "3"


```

<!-- RESULTS -->

<!-- BEFORE FILTER -->

```{r family-numbers-before-filter, echo = F, warning=F, message=F}

beijing_n_before_filter <- n_samps_family_before_filter$Beijing
beijing_pc_before_filter <- fmt_pc(beijing_n_before_filter/n_total_samps_before_filter)

T_n_before_filter <- n_samps_family_before_filter$T
T_pc_before_filter <- fmt_pc(T_n_before_filter/n_total_samps_before_filter)

LAM_n_before_filter <- n_samps_family_before_filter$LAM
LAM_pc_before_filter <- fmt_pc(LAM_n_before_filter/n_total_samps_before_filter)

CAS_n_before_filter <- n_samps_family_before_filter$CAS
CAS_pc_before_filter <- fmt_pc(CAS_n_before_filter/n_total_samps_before_filter, 1)

EAI_n_before_filter <- n_samps_family_before_filter$EAI
EAI_pc_before_filter <- fmt_pc(EAI_n_before_filter/n_total_samps_before_filter, 1)

unknown_family_n_before_filter <- n_samps_family_before_filter$Unknown
unknown_family_pc_before_filter <- fmt_pc(unknown_family_n_before_filter/n_total_samps_before_filter)

```

```{r lin-numbers-before-filter, echo = F, warning=F, message=F}

# Get numbers for spol families (i.e. rows)
n_samps_lin_before_filter <- data.frame(as.list(sort(colSums(lin_fam_freq_tab_before_filter), 
                                                        decreasing = T)))

L4_n_before_filter <- n_samps_lin_before_filter$X4
L4_pc_before_filter <- fmt_pc(L4_n_before_filter/n_total_samps_before_filter)

L2_n_before_filter <- n_samps_lin_before_filter$X2
L2_pc_before_filter <- fmt_pc(L2_n_before_filter/n_total_samps_before_filter, 1)

L3_n_before_filter <- n_samps_lin_before_filter$X3
L3_pc_before_filter <- fmt_pc(L3_n_before_filter/n_total_samps_before_filter, 1)

L1_n_before_filter <- n_samps_lin_before_filter$X1
L1_pc_before_filter <- fmt_pc(L1_n_before_filter/n_total_samps_before_filter, 1)

```

```{r spol-numbers-before-filter, echo = F, warning=F, message=F}

n_spols_T <- len_uniq(subset(spol_data_unfilt, family_group == "T")$spoligotype)
n_spols_LAM <- len_uniq(subset(spol_data_unfilt, family_group == "LAM")$spoligotype)
n_spols_CAS <- len_uniq(subset(spol_data_unfilt, family_group == "CAS")$spoligotype)
n_spols_EAI <- len_uniq(subset(spol_data_unfilt, family_group == "EAI")$spoligotype)


```

```{r geo-numbers-before-filter, echo = F, warning=F, message=F}

who_n_cntry_unfilt <- reshape2::dcast(spol_data_unfilt, WHO_region ~ 'n', 
                                      value.var = "country_code", fun.aggregate = len_uniq)


n_ctry_europe_unfilt <- subset(who_n_cntry_unfilt, WHO_region == "Europe")$n
n_ctry_africa_unfilt <- subset(who_n_cntry_unfilt, WHO_region == "Africa")$n
n_ctry_wp_unfilt <- subset(who_n_cntry_unfilt, WHO_region == "Western Pacific")$n
n_ctry_am_unfilt <- subset(who_n_cntry_unfilt, WHO_region == "Americas")$n


who_n_samps_unfilt <- reshape2::dcast(spol_data_unfilt, WHO_region ~ 'n', 
                                      value.var = "sample", fun.aggregate = len_uniq)

who_n_samps_unfilt$pc <- trimws(fmt_pc(who_n_samps_unfilt$n / n_total_samps_before_filter, 1))


europe_pc_samps_unfilt <- subset(who_n_samps_unfilt, WHO_region == "Europe")$pc
africa_pc_samps_unfilt <- subset(who_n_samps_unfilt, WHO_region == "Africa")$pc
wp_pc_samps_unfilt <- subset(who_n_samps_unfilt, WHO_region == "Western Pacific")$pc
am_pc_samps_unfilt <- subset(who_n_samps_unfilt, WHO_region == "Americas")$pc


```

<!-- AFTER FILTER -->

```{r family-numbers-after-filter, echo = F, warning=F, message=F}

beijing_n <- fmt(n_samps_family$Beijing)
beijing_pc <- fmt_pc(n_samps_family$Beijing/n_total_samps_after_filter)

T_n <- fmt(n_samps_family$T)
T_pc <- fmt_pc(n_samps_family$T/n_total_samps_after_filter)

LAM_n <- fmt(n_samps_family$LAM)
LAM_pc <- fmt_pc(n_samps_family$LAM/n_total_samps_after_filter)

unknown_family_n <- fmt(n_samps_family$Unknown)
unknown_family_pc <- fmt_pc(n_samps_family$Unknown/n_total_samps_after_filter)

```

```{r geo-numbers-after-filter, echo = F, warning=F, message=F}

# Subregions
# northern_europe_n <- fmt(n_samps_geo$Northern.Europe)
# northern_europe_pc <- fmt_pc(n_samps_geo$Northern.Europe/n_total_samps_before_filter)
# 
# southern_africa_n <- fmt(n_samps_geo$Southern.Africa)
# southern_africa_pc <- fmt_pc(n_samps_geo$Southern.Africa/n_total_samps_before_filter)
# 
# se_asia_n <- fmt(n_samps_geo$Southeast.Asia)
# se_asia_pc <- fmt_pc(n_samps_geo$Southeast.Asia/n_total_samps_before_filter)
# 
# unknown_geo_n <- fmt(n_samps_geo$Unknown)
# unknown_geo_pc <- fmt_pc(n_samps_geo$Unknown/n_total_samps_before_filter)

# WHO regions
n_europe <- fmt(n_samps_geo$Europe)
pc_europe <- fmt_pc(n_samps_geo$Europe/n_total_samps_after_filter)

n_africa <- fmt(n_samps_geo$Africa)
pc_africa <- fmt_pc(n_samps_geo$Africa/n_total_samps_after_filter)

n_w_pacific <- fmt(n_samps_geo$Western.Pacific)
pc_w_pacific <- fmt_pc(n_samps_geo$Western.Pacific/n_total_samps_after_filter)

unknown_geo_n <- fmt(n_samps_geo$Unknown)
unknown_geo_pc <- fmt_pc(n_samps_geo$Unknown/n_total_samps_after_filter)

```


```{r empty, echo = F, warning=F, message=F}


```


| | |
| ----------- | ----------- |
| Gary Napier^1^ |	gary.napier@lshtm.ac.uk |
| David Couvin^2^ |	dcouvin@pasteur-guadeloupe.fr |
| Guislaine Refrégier^3^ | guislaine.refregier@universite-paris-saclay.fr |
| Christophe Guyeux^4^ | guyeux@gmail.com |
| Conor Meehan^5^ | conor.meehan@ntu.ac.uk |
| Christophe Sola^3^ | christophe.sola@universite-paris-saclay.fr |
| Susana Campino^1^ | susana.campino@lshtm.ac.uk |
| Jody Phelan^1^,^\*^ | jody.phelan@lshtm.ac.uk |
| Taane G. Clark^1,6,\*^ | taane.clark@lshtm.ac.uk |

1.	Faculty of Infectious and Tropical Diseases, London School of Hygiene & Tropical Medicine, WC1E 7HT London, UK
2.	Institut Pasteur de la Guadeloupe, Université Antilles Guyane. Les Abymes, Guadeloupe.
3.	CEA, CNRS, Univ. Paris-Sud, Université Paris-Saclay, cedex, 91198, Gif-sur-Yvette, France
4.	DISC Computer Science Department, Univ. Bourgogne Franche-Comté (UBFC), 16 Route de Gray, 25000, Besançon, France
5.	Nottingham Trent University, NG1 4FQ Nottingham, UK
6.	Faculty of Epidemiology and Population Health, London School of Hygiene & Tropical Medicine, WC1E 7HT London, UK

\* joint authors

***Scientific Reports***

### Abstract

Strain-types of *Mycobacterium tuberculosis*, the bacterial pathogen underlying tuberculosis disease (TB), have been associated with drug resistance, transmissibility, virulence, and host-pathogen interactions. Spoligotyping was developed as a molecular genotyping technique used to determine strain-types, though recent advances un sequencing technology have led to determination of strain-types through a SNP-based sublineage nomenclature. Notwithstanding, spoligotyping remains and important tool and there is a need to characterise their concordance. To enable this research, a new *in silico* spoligotype tool was developed and integrated into TB-Profiler. Lineage and spoligotype predictions were generated for a dataset of over 32,000 isolates and the overlap between the strain typing systems was characterized. Major spoligotypes detected were Beijing (`r beijing_pc_before_filter`), T (`r T_pc_before_filter`), LAM (`r LAM_pc_before_filter`), CAS (`r CAS_pc_before_filter`), EAI (`r EAI_pc_before_filter`), and these broadly followed known geographic distributions. Most spoligotypes were perfectly correlated with the main MTBC lineages (L1-7, plus animal). Conversely, at lower levels of the sublineage system, this relationship began to break down, with only `r fmt(pure_pc_list$lv2)`% of spoligotypes being perfectly associated with a sublineage at the second level, `r fmt(pure_pc_list$lv3)`% at the third level, and `r fmt(pure_pc_list$lv4)`% at the fourth level. This indicates that the SNP-based sublineage system may represent a higher resolution system to characterize strain diversity. 

**URL:**https://github.com/jodyphelan/TBProfiler; https://github.com/GaryNapier/spolpred/tree/master/results

**Keywords:** *Mycobacterium tuberculosis*, spoligotypes, lineages, phylogeny, spolpred

### INTRODUCTION

Tuberculosis is an infectious disease of high global burden caused by members of the *Mycobacterium tuberculosis* complex (MTBC), which includes *M. tuberculosis sensu stricto* (*Mtb*), *M. africanum* and animal strains such as *M. bovis*. Though the MTBC is described as clonal, there is sufficient variation to distinguish strain-types within members of the complex. *Mtb* and *M. africanum* are phylogenetically classified in nine main lineages (L1-9), with strain types that are distributed phylo-geographically [@Napier2020].  Strain identification is crucial to addressing key epidemiological questions, from individual to global scales. Strain typing is informative in the investigation of transmission events, and in the wider context, provides valuable insight into the spread of MTBC variants, indicating potential differences in genotype-phenotype interaction. For example, Beijing strains show lineage-specific associations with drug resistance [@Oppong2019], and that the geographical ubiquity of lineages 2 (Beijing) and 4 (Euro-American-Indian) can be attributed to virulence and transmissibility [@Coscolla2014a]. Furthermore, strain typing at higher phylogenetic resolution can reveal within-strain differences, such as the typical and atypical Beijing strains varying in geographical distribution, resistance and virulence [@Forrellad2013][@Ribeiro2014]. Advances in sequencing technologies are leading high-resolution strain typing offered by whole genome sequencing (WGS), which improve transmission studies and enable the tracking of between- and within-lineage genotypic-phenotypic differences, as well as assisting with understanding drug resistance mechanisms.

Spoligotyping is a fingerprinting PCR technique [@Kamerbeek1997], which exploits the polymorphism harboured at the direct repeat locus of MTBC. It is based on the PCR amplification of 43 short unique sequences (termed spacers) contained between well-conserved 36-bp direct repeats. Since strains vary in the occurrence of spacers, each sample produces a distinctive spot pattern, which is then translated into a numerical code of 8 digits, leading to >3,800 spoligotypes. The spoligotyping nomenclature [@Brudey2006] reflects the phylogeographical structure of MTBC, and its main families overlap with the ~100 (sub-)lineage system [@Napier2020], with both of higher resolution than large deletion-based regions of difference (RD). The spoligotyping nomenclature[@Brudey2006] reflects the phylogeographical structure of MTBC, and its main families overlap with a SNP-based barcoding system[@Coll2014a], which was recently updated[@Napier2020]. Both spoligotypes and sublineages offer higher resolution than large deletion-based regions of difference (RD). However, the full extent of alignment of spoligotypes and sub-lineages needs to be established, leading to improvements in both spoligotyping and sub-lineage barcoding of strain-types using whole genome sequencing data. Previous work has *in silico* predicted spoligotypes, implemented within the widely applied SpolPred software [@Coll2012]. With at least 20-fold more *Mtb* WGS available since its development, we seek to check consistency of spoligotypes with the sub-lineage system[@Napier2020], and assess their global distribution. This is achieved by developing new software ("Spolpred2") to *in silico* genotype isolates, which predicts the spoligotype from raw sequence reads. We incorporate the updated barcodes for spoligotypes and "Spolpred2" within the TB-Profiler tool [@Phelan2019], widely used to profile MTBC sub-lineages, strain-types, and drug resistance from WGS for clinical and surveillance applications. 

### RESULTS

**Global distribution of spoligotype families**

The dataset consisted of `r n_total_samps_before_filter` *M. tuberculosis* isolates with WGS, drug susceptibility test and geographical source data, with lineages inferred using TB-Profiler software (**Table \@ref(tab:table-1-show)**). The spoligotypes were predicted using new Spolpred2 software developed as part of this work (see **MATERIALS AND METHODS**) (**Table \@ref(tab:table-1-show)**). Most isolates were from the main lineages (L4 `r L4_pc_before_filter`, L2 `r L2_pc_before_filter`, L3 `r L3_pc_before_filter`, L1 `r L1_pc_before_filter`), and the major spoligotype families identified were Beijing (L2; `r beijing_pc_before_filter`), T (`r n_spols_T` spoligotypes; L4; `r T_pc_before_filter`), LAM (`r n_spols_LAM` spoligotypes; L4; `r LAM_pc_before_filter`), Central Asian Strain (L3; CAS; `r n_spols_CAS` spoligotypes; `r CAS_pc_before_filter`), EAI (`r n_spols_EAI` spoligotypes; `r EAI_pc_before_filter`), though many samples had an unknown family (n=`r fmt(unknown_family_n_before_filter)`, `r unknown_family_pc_before_filter`). A total of `r fmt(n_unique_lins_before_filter)` unique lineages and sublineages, and `r fmt(n_unique_spol_before_filter)` unique spoligotypes were present. Whilst the isolates represent a convenience sample, they covered all World Health Organization Regions, including Europe (`r n_ctry_europe_unfilt` countries; `r europe_pc_samps_unfilt`), Africa (`r n_ctry_africa_unfilt` countries; `r africa_pc_samps_unfilt`), Western Pacific (`r n_ctry_wp_unfilt` countries; `r wp_pc_samps_unfilt`) and the Americas (`r n_ctry_am_unfilt` countries; `r am_pc_samps_unfilt`).

To improve the stringency of the analysis, all spoligotypes with <5 isolates support were removed, resulting in `r fmt(n_total_samps_after_filter)` (`r fmt_pc(n_total_samps_after_filter/n_total_samps_before_filter)`) isolates, `r fmt(n_unique_lins_after_filter)` (`r fmt_pc(n_unique_lins_after_filter/n_unique_lins_before_filter)`) unique lineages and `r fmt(n_unique_spol_after_filter)` (`r fmt_pc(n_unique_spol_after_filter/n_unique_spol_before_filter)`) distinct spoligotypes (**Figure \@ref(fig:fam-lin-bar-show)**). This filtering reveals the high number of rare spoligotypes (n=`r fmt(rare_spols_n)`; see **S`r rare_spols_table_s_number` Table** for a list), with representation across most lineages (L4 `r rare_spol_L4_pc`; L1 `r rare_spol_L1_pc`; L3 `r rare_spol_L3_pc`; other `r rare_other_pc`). After filtering (n=`r fmt(n_total_samps_after_filter)`), like previously, the most frequent spoligotype family  belongs to Beijing (`r beijing_n`; `r beijing_pc`), followed by T (`r T_n`; `r T_pc`) and LAM (`r LAM_n`; `r LAM_pc`), but the proportion with unknown family decreased (`r unknown_family_n`; `r unknown_family_pc`) (**Figure \@ref(fig:fam-lin-bar-show)**, **Table S`r fam_table_s_number`**). The most common WHO geographical regions were again Europe (`r n_europe`; `r pc_europe`), Africa (`r n_africa`; `r pc_africa`) and Western Pacific (`r n_w_pacific`; `r pc_w_pacific`) (**Figure \@ref(fig:fam-lin-bar-show)**, **Figure S`r map_figure_s_number`**). While many isolates occur in their expected geographical regions, such as Beijing strains in Western Pacific and Southeast Asia, there is high variation in the source, reflecting the spread of *Mtb* since spoligotype labels were conceived, and the convenience nature of the sampling, which includes an emphasis on transmission studies or clinically relevant investigations.

**Spoligotype families and lineages**

There was a strong concordance between spoligotype family and main lineage among the `r fmt(n_total_samps_after_filter)` samples (**S`r lin_fam_freq_tab_s_number` Table**). At the lineage level (L1 - L7), there were `r pure_n_list$lv1` (`r pc(pure_pc_list$lv1)`) spoligotypes appearing exclusively in their respective lineages. For example, the AFRI family only appears in isolates classed as lineages 5 and 6. EAI, CAS, and Ethiopian families are exclusively within lineages 1, 3, and 7 respectively. Similarly, Cameroon, Ethiopian, H, LAM, S, T, Turkey, and URAL spoligotype families appear only in lineage 4, consistent it with being the most diverse lineage (**Figure \@ref(fig:lin-1-7-tree)**). 

There were however a few discrepancies, such as a very small proportion of isolates with spoligotype family Beijing classified as lineage 1 (n=1) or 3 (n=21) (22/`r beijing_n`; <0.3%) (**S`r lin_fam_freq_tab_s_number` Table**). These discrepancies could not be explained by low coverage in the direct repeat region. Isolates with the Manu spoligotype family straddled lineage 2 (n=`r manu_anc_n`; fmt_pc(manu_anc_n/manu_total, 1)) with the Manu ancestor types, as well as lineage 3 (n=`r manu_3_n`; `r fmt_pc(manu_3_n/manu_total, 1)`) corresponding to a Manu3 strain-type. Whilst many spoligotypes were found to be exclusive to lineages at each level, in many cases they nevertheless appeared in a relatively small proportion of that lineage's total samples (**S`r lin_fam_freq_tab_s_number` Table**). For example, spoligotype EAI2-nonthaburi is only found in lineage 1 but appears in only 17.2% of that lineage's total samples, and is known to be localized to Thailand[@Palittapongarnpim2018], like EAI-Manila found in the Philippines[@Phelan2019_Philippines]. Conversely, as shown above, there are spoligotypes such as Beijing which are highly prevalent in lineage 2 (91.2%), which appears in two other lineages (**S`r fam_table_s_number` Table**). 

Subsequent analysis looked at spoligotypes within secondary, tertiary, and subsequent levels of lineages. The lineage levels show decreasing numbers and proportions of samples with spoligotypes with perfect concordance (second level: n = `r pure_n_list$lv2` (`r pc(pure_pc_list$lv2)`), third level: n = `r pure_n_list$lv3` (`r pc(pure_pc_list$lv3)`), fourth level: `r pure_n_list$lv4` (`r pc(pure_pc_list$lv4)`)) (**Figure S`r spol_freq_hist_s_number`**). The spoligotypes which offered discrimination between lineages at the lowest lineage level and with at least 20 isolates, included EAI2-Manila and EAI2-nonthaburi (lineage 1.2.1.2), Manu ancestor (2.1), T4-CEU1 (4.1.2), Turkey (4.2.2.1), LAM1 and LAM2 (4.3.4.1), T2-Uganda (4.6.1.1), and BOV_3 (La1.8.1) (**S`r lv4_filt_display_s_number` Table**), which could be used to potentially update the lineage SNP barcode. 

### DISCUSSION

This work aimed to characterise the global distribution of spoligotypes and correlate this with the lineage system developed by Napier et al[@Napier2020]. To enable this work, a new rapid *in silico* spoligotyping software was developed with speed and flexibility in mind and was integrated into the TB-Profiler analysis platform. 
The frequency of spoligotypes and their respective families confirm known common spoligotype families with representation from Beijing, T, LAM, CAS and EAI. The geographic distribution of spoligotype families followed known patterns with T and LAM being most prevalent in Europe, Africa and the Americas, *Africanum* in West Africa and Beijing being prevalent across most geographic regions. Interestingly, there were 3,490 spoligotypes that were present in less than five samples, these may represent either very rare combinations of spacers or samples with low or unstable coverage around the direct repeat locus. Of the 1140/3490 rare spoligotypes had been previously seen in the SITVIT2 database, indicating that these are indeed valid spoligotypes, albeit rare. The remaining spoligotypes could represent truly novel spoligotypes or have been generated from samples with spurious coverage. Generally, there was a good association of spoligotypes to lineage with the majority of spoligotype family association exclusively to one of the major lineages. The only discrepancies found were 21 L3 samples and one L1 sample with a Beijing spoligotype. These spoligotypes were manually verified which ruled out poor data quality and confirmed the Beijing spoligotype. As expected, the perfect concordance between spoligotype and lineage diminished as higher resolution sublineages were used for comparison with only 33.9% of spoligotypes showing perfect concordance. This indicates that the spoligotypes are not monophyletic and have arisen through convergent evolution, or that the sublineage comprises a higher resolution unit than the respective spoligotype(s). Conversely, there were some instances where a sublineage contained multiple major spoligotypes and hence the spoligotype represents the higher resolution unit for the related samples. In these cases the sublineage system and corresponding SNP-barcode could be further refined to reflect this diversity.

### CONCLUSIONS

We have presented a new means of predicting spoligotypes from WGS *in silico* that is fast and accurate. This software is freely available as part of the TB-Profiler package. Spoligotypes are useful in tracking the epidemiological spread of MTBC, but do not necessarly agree with the lineage system at lower resolution. We have clarified this relationship, which adds to the power of using a dual approach to strain typing. 

### MATERIAL AND METHODS

**Sequence data and processing**

The input dataset consists of ~32k isolates for which next generation sequences have been deposited on the ENA and have been previously described in publications and has been previously described[@Phelan2019a]. All sequence data was aligned to the H37Rv reference genome (NC_000962.3) using BWA mem software (v0.7.17). Variants were called using gatk HaplotypeCaller (v4.1.4.1 -ERC GVCF) and merged using gatk CombineGVCFs. Variants were filtered to remove indels, SNPs in pe/ppe genes and those which had >10% missing genotypes across samples. Filtered variants were transformed to a muti-fasta format file using custom scripts which was used as the input to phylogenetic reconstruction using iqtree (v2.1.2 -m GTR+G+ASC). Lineage assignments were generated using TB-Profiler (v4.3.0). Alignment files in bam format were used for spoligotype generation using the algorithm described below.

**Spolpred2 algorithm**

The Spolpred2 spoligotype prediction tool is based on k-mer counting. KMC3 [@Kokot2017] is used to count k-mers from either raw fastq, fasta, bam or cram format. A k-mer length equal to the length of the unique spacers (k=25) is chosen. For bam and cram files, alignment against the H37Rv reference genome (AL123456.3) [@Cole1998] is assumed and only reads falling between positions 3117003 and 3127206 are analysed. Custom Python code then loads the counts and performs a direct lookup of the spacers converted to their canonical form to extract the counts. Lookups are also performed for spacers with up to two mismatches. Presence or absence of a spacer is determined by comparing the counts against a minimum threshold. The threshold is selected to be 20% of the maximum spacer count. The presence/absence vector represents the binary spoligotype and is converted into an octal form. Finally, the associated family and SIT are reported by performing a lookup in a CSV file which currently contains data for all samples submitted to SITVIT2 [@SITVIT2]. The code was integrated into TB-Profiler (v4.3.0) [@Phelan2019] and can be invoked to perform spoligotyping only, or as part of the standard profiling pipeline which also reports drug resistance and SNP-based lineage. Using a standard laptop with 8Gb ram, Spolpred2 can profile from bam and fasta format files with 1000-fold coverage in <10 seconds, whilst perform the same task on raw fastq files with up to 500-fold coverage in <30 seconds.

**Association of spoligotypes to lineages**

Spoligotypes were inferred using Spolpred2 across `r n_total_samps_before_filter` MTBC samples with whole genome sequencing data, location, and drug resistance phenotypes. Lineages were inferred using TB-Profiler, which implements a published barcode[@Napier2020]. The number of lineages and sublineages within spoligotype families was estimated. As there were many spoligotypes in low numbers of samples and therefore offering little predictive power, those appearing in fewer than five samples were excluded. Since we were interested in the strength of association between spoligotypes and the various levels of the lineage system[@Napier2020], the lineages were parsed into a hierarchy for each round of analysis. For example, the first level analysed the association between each spoligotype and the main *Mtb* lineages 1-7. Next was the association between each spoligotype and the second level, represented by lineages 1.1, 1.2, 2.1, 2.2...etc, and subsequent levels. The concordance statistic used assigns a score of 1 if a spoligotype is only found in a given lineage, and anything less than 1 indicated that the spoligotype is found in at least one other sample belonging to another lineage.

### DATA AVAILABILITY

All data used in this work is publicly available. Spolpred2 software is available as part of TB-Profiler, but also as stand-alone.

###ACKNOWLEDGEMENTS

GN is funded by an BBSRC-LIDo PhD studentship. JEP is funded by a Newton Institutional Links Grant (British Council, no. 261868591). TGC is funded by the Medical Research Council UK (Grant no. MR/M01360X/1, MR/N010469/1, MR/R025576/1, and MR/R020973/1). SC is funded by Medical Research Council UK grants (ref. MR/M01360X/1, MR/R025576/1, and MR/R020973/1). The authors declare no conflicts of interest. The funders had no role in the design of the study and collection, analysis, and interpretation of data and in writing the manuscript should be declared.


### AUTHORS CONTRIBUTIONS
JEP and TGC conceived and directed the project. GN performed bioinformatic and statistical analyses under the supervision of SC, JEP and TGC. DC, GR, CG, CM and CS provided resources. GN, CM, SC, JEP and TGC interpreted results. GN wrote the first draft of the manuscript with inputs from JEP and TGC. All authors commented and edited on various versions of the draft manuscript and approved the final version. GN, JEP, and TGC compiled the final manuscript.

### ADDITIONAL INFORMATION

**Ethics approval and consent to participate**
No ethics approvals were required as all data is publicly available.

**Consent for publication**
All authors have consented to the publication of this manuscript. 

**Availability of data and materials**
Analysis scripts are available at https://github.com/GaryNapier/spolpred

**Competing interests**
Authors declare no competing interests.


## TABLES

<!-- ```{r times-table, echo = F, warning=F} -->

<!-- times_df <- data.frame(Accession = c("ERR1144974", "SRR6389896", "ERR038260", "ERR2513429"),  -->
<!--            Median_coverage = c(705, 508, 244, 100),  -->
<!--            fastq = c(40.904, 55.541, 16.628, 10.553),  -->
<!--            fasta = c(6.589, 6.736, 6.405, 6.429),  -->
<!--            bam = c(3.152, 3.323, 2.659, 2.587)) -->


<!-- names(times_df) <- c("Accession", "Median coverage", "fastq (s)", "fasta (s)", "bam (s)") -->

<!-- cap <- "Time taken from different input sources using a maximum of 8Gb RAM and 8 threads for four randomly chosen samples" -->

<!-- knitr::kable(times_df, row.names = F, caption = cap, format = "pipe") -->

<!-- ``` -->

```{r table-1-show, echo = F, warning=F}

cap <- sprintf("*M. tuberculosis* dataset (n=%s)", n_total_samps_before_filter)

knitr::kable(table_1_display, row.names = F, caption = cap, format = "pipe")

```
\* sub-lineage, spoligotype or number of countries

```{r lv1-lv2-n-spol-fam-show, echo = F, warning=F}

cap <- sprintf("Numbers of samples and unique spoligotypes for sub-lineages after filtering out spoligotypes occurring in fewer than five samples across %s *M. tuberculosis*",
               n_total_samps_after_filter)

knitr::kable(lv1_lv2_n_spol_fam, row.names = F, caption = cap, format = "pipe")

```
\*Number of spoligotypes duplicated on some occasions due to presence in multiple lineages/sublineages.

<!-- # ```{r main-lin-fam-group-tab, echo = F, warning=F} -->
<!-- # -->
<!-- # cap <- "Main *M.tb* lineages (1-7, plus animal strains) and their corresponding spoligotype families" -->
<!-- # -->
<!-- # knitr::kable(main_lin_family_group, row.names = F, caption = cap, format = "pipe") -->
<!-- # -->
<!-- # ``` -->

<!-- EAI = East-African-Indian; -->
<!-- CAS = Central Asian Strains; -->
<!-- H = Haarlem; -->
<!-- LAM = Latin American-Mediterranean; -->
<!-- S = Spoligotype family S; -->
<!-- T = Spoligotype family T; -->
<!-- AFRI = *M. africanum*; -->
<!-- BOV = *M. bovis* (animal); -->
<!-- PINI2 = *M. pinnipedii* (animal) -->

**Supplementary tables**

**Table S`r rare_spols_table_s_number`**: https://github.com/GaryNapier/spolpred/blob/master/results/rare_spol.csv

**Table S`r fam_table_s_number`**: https://github.com/GaryNapier/spolpred/blob/master/results/s2_table.csv

**Table S`r lin_fam_freq_tab_s_number`**

Frequency table of samples by main lineage and spoligotype family
```{r lin-fam-freq-tab, echo = F, warning=F}

knitr::kable(fmt(lin_fam_freq_tab), row.names = F, format = "pipe")

```

**Table S`r lv4_filt_display_s_number`**

Spoligotypes discriminating lineages at the lowest level

```{r lowest-lvl-spol-split-table, echo = F, warning=F}

knitr::kable(lv4_filt_display, row.names = F, format = "pipe")

```


<!-- # ```{r spol-lin-levels-table, echo = F, warning=F} -->
<!-- #  -->
<!-- # cap <- "Correspondence between lineage and spoligotypes at each of the four levels of lineage." -->
<!-- #  -->
<!-- # knitr::kable(spol_lin_levels_table_display, row.names = F, caption = cap, format = "pipe") -->
<!-- #  -->
<!-- # ``` -->


## FIGURES

<!-- ```{r times, echo = F, warning=F, fig.cap = "Time taken from different input sources using a maximum of 8Gb RAM and 8 threads."} -->

<!-- knitr::include_graphics("../results/times.png") -->

<!-- ``` -->


<!-- ```{r level-prob-hist-display, echo = F, warning=F, message=F, fig.cap = "Histograms of correlation score for each lineage level 1-4"} -->

<!-- knitr::include_graphics(level_prob_hist_file) -->

<!-- ``` -->

<!-- ```{r spol-freq-hist-display, echo = F, warning=F, message=F, fig.cap = "Histograms of frequencies of spoligotypes for each lineage level 1-4"} -->

<!-- knitr::include_graphics(spol_freq_hist_file) -->

<!-- ``` -->


<!-- ```{r spol-lin-results-plot-display, echo = F, warning=F, message=F, fig.cap = "Boxplot: Aggregated percentages of samples with each spoligotype, within each lineage; Line: Total percentage of spoligotypes scoring 1 on our correlation score"} -->

<!-- knitr::include_graphics(spol_lin_results_plot_file) -->

<!-- ``` -->


<!-- ```{r region-family-plot, echo = F, warning=F, fig.cap="Heatmap of samples by spoligotype family and region of sample collection, normalised by Region (row)."} -->

<!-- knitr::include_graphics(region_family_plot_file) -->

<!-- ``` -->


```{r fam-lin-bar-show, echo = F, warning=F, fig.cap = "Spoligotype families and number of samples (a) by lineages; (b) across WHO regions"}

knitr::include_graphics(fam_lin_n_bar_file)

```

(a)

```{r fam-who-bar-show, echo = F, warning=F}

knitr::include_graphics(fam_who_n_bar_file)

```

(b)

```{r lin-1-7-tree, echo = F, warning=F, fig.cap = "Phylogenetic trees showing lineage or sub-lineage and spoligotype family"}

knitr::include_graphics(lin1_7_ggtree)

```

```{r lin-2-tree, echo = F, warning=F}

knitr::include_graphics(lin2_ggtree)

```

```{r lin-3-tree, echo = F, warning=F}

knitr::include_graphics(lin3_ggtree)

```

```{r lin-4-tree, echo = F, warning=F}

knitr::include_graphics(lin4_ggtree)

```

```{r lin-5-tree, echo = F, warning=F}

knitr::include_graphics(lin5_6_8_9_La_ggtree)

```

**Supplementary figures**

**Figure S`r spol_freq_hist_s_number`**

Frequencies of spoligotypes at each lineage level
```{r spol-freq-hist-display, echo = F, warning=F}

knitr::include_graphics(spol_freq_hist_file)

```

**Figure S`r map_figure_s_number`**

Global map of WHO regions. Inner piechart: Lineage; Outer piechart: Spoligotype family
```{r fam-lin-map, echo = F, warning=F}

knitr::include_graphics(fam_lin_map_file)

```

**Figure S`r trees_figures_s_number`** - ATTACHED

## REFERENCES
























