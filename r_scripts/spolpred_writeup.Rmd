---
title: "Accurate *in silico* prediction of *Mycobacterium tuberculosis* spoligotypes from whole genome sequences"
output: 
  bookdown::word_document2: 
    fig_caption: yes
    table_caption: yes
    number_sections: no
    reference_docx: ../../pipeline/word_template/use_template.docx
bibliography: ../../pipeline/references/all_refs.bib
csl: ../../pipeline/references/biomed-central.csl
---

```{r setup, include=FALSE, echo = F, warning=F, message=F}

# SETUP ----

rm(list = ls())

knitr::opts_chunk$set(echo = F)
# options(scipen=1, digits=2)
options(scipen=999, digits = 3)
table_font_sz <- 8

```

```{r library, include=FALSE, echo = F, warning=F, message=F}

# library(sjmisc)
library(plyr)
library(dplyr)
library(tibble)
library(stringr)
library(ggplot2)
library(tidyverse)
library(tidyr)
library(janitor)

```

```{r functions, echo = F, warning=F, message=F}

source("https://raw.githubusercontent.com/GaryNapier/Packages_functions/master/Functions.R")

non_num_cols <- function(x){
  # Returns only the non-numeric columns of a dataframe
  x[!(sapply(x, is.numeric))]
}

expand_hierarchy <- function(df, group_by_col_name, hierarchy_to_expand_col_name){
  # Takes df like this:
  #   ID      Group
  # 1 samp_1  4.2.1.1
  # 2 samp_2  1.2.1.2.1
  
  # And makes this:
  #   ID    lin_level_1 lin_level_2 lin_level_3 lin_level_4 lin_level_5   max_lin
  # 1 samp_1          4         4.2       4.2.1     4.2.1.1        <NA>   4.2.1.1
  # 2 samp_2          1         1.2       1.2.1     1.2.1.2   1.2.1.2.1 1.2.1.2.1
  
  split_lins <- stringr::str_split(df[[hierarchy_to_expand_col_name]], "\\.")
  max_lin_len <- max(sapply(split_lins, length))
  mat <- matrix(nrow = length(df[[group_by_col_name]]), ncol = max_lin_len+1)
  mat[, 1] <- df[[group_by_col_name]]
  for(i in 1:nrow(mat)){
    for(lin_level in 1:max_lin_len){
      
      len_lin <- length(split_lins[[i]])
      
      if(lin_level > len_lin){
        mat[i, lin_level+1] <- NA
      }else{
        mat[i, lin_level+1] <- paste0(split_lins[[i]][1:lin_level], collapse = ".")
      }
    }
  }
  
  max_lin <- vector()
  for(i in seq(nrow(mat))){
    max_lin[i] <- mat[i, which.max(sapply(mat[i, -1], len_str))+1]
  }
  mat <- data.frame(cbind(mat, max_lin), stringsAsFactors = F)
  names(mat) <- c("id", paste0("lin_level_", 1:(ncol(mat)-2) ), "max_lin")
  return(mat)
}


top_spol_freq <- function(x, col){
  x %>% 
    group_by_(.dots = lazyeval::lazy(col)) %>% 
    dplyr::count(.dots = lazyeval::lazy(col), spoligotype) %>% 
    dplyr::arrange(desc(n), .by_group = TRUE) %>%
    dplyr::top_n(10, n) %>% 
    data.frame()
}


tab2df <- function(df){
  as.data.frame.matrix(table(df))
}

row_probs <- function(x){
  # Dataframe:
  # fruit   X1 X2 X3
  # mangoes 90 10 20
  # bananas 10 90 80
  # Get the row-wise proportions for each number:
  # fruit   X1     X2     X3
  # mangoes 0.7500 0.0833 0.167
  # bananas 0.0556 0.5000 0.444
  # i.e. mangoes-X1 = 90/(90+10+20) = 0.75
  
  # Strip off the non-numeric col(s)
  x_non_num <- non_num_cols(x)
  # Strip off numeric cols for calculation 
  x <- num_cols(x)
  # Pre-define an empty matrix
  mat <- matrix(nrow = nrow(x), ncol = ncol(x))
  # Loop over rows 
  for(row in seq(nrow(x))){
    # Loop over cols in row
    for(col in seq(ncol(x[row, ]))){
      # Divide the number by the total in the row
      mat[row, col] <- x[row, col]/sum(x[row, ])
    }
  }
  # Put table back together
  cbind(x_non_num, setNames(data.frame(mat), names(x)))
}

col_probs <- function(x){
  # Dataframe:
  # fruit   X1 X2 X3
  # mangoes 90 10 20
  # bananas 10 90 80
  # Get the col-wise proportions for each number:
  # col_probs(x)
  # fruit   L1  L2  L3
  # mangoes 0.9 0.1 0.2
  # bananas 0.1 0.9 0.8
  # i.e. mangoes-X1 = 90/(90+10) = 0.9
  
  # Strip off the non-numeric col(s)
  x_non_num <- non_num_cols(x)
  # Strip off numeric cols for calculation 
  x <- num_cols(x)
  # Pre-define an empty matrix
  mat <- matrix(nrow = nrow(x), ncol = ncol(x))
  # Loop over rows 
  for(row in seq(nrow(x))){
    # Loop over cols in row
    for(col in seq(ncol(x[row, ]))){
      # Divide the number by the total in the row
      mat[row, col] <- x[row, col]/sum(x[ ,col])
    }
  }
  # Put table back together
  cbind(x_non_num, setNames(data.frame(mat), names(x)))
}

sort_df_by_col_name <- function(df, col, decreasing = T){
  df[order(df[, col],  decreasing = decreasing),]
}

rm_dup_group <- function(df, col){
  # If rows of groups are repeated in a col, replace repeats with blank ("")
  # For final display of tables
  # e.g. 
  # in
  # lineage value
  # L1      10
  # L1      20
  # L1      25
  # L2      100
  # L2      3
  # L2      21
  # out
  # lineage value
  # L1      10
  #         20
  #         25
  # L2      100
  #         3
  #         21
  df[which(duplicated(df[col])), col] <- ""
  df
}

pc <- function(x){
  paste0(round(x, 1), "%")
}

list_to_df_group <- function(lst){
  # lst <- list(X = 1:5, Y = LETTERS[1:5])
  # $X
  # [1]  1  2  3  4  5 
  # $Y
  # [1] "A" "B" "C" "D" "E"
  # list_to_df_group(lst)
  #      group values
  # 1      X      1
  # 2      X      2
  # 3      X      3
  # 4      X      4
  # 5      X      5
  # 6      Y      A
  # 7      Y      B
  # 8      Y      C
  # 9      Y      D
  # 10     Y      E
  
  df_list <- list()
  for(i in seq(lst)){
    values_vect <- lst[[i]]
    nm <- names(lst[i])
    group_vect <- rep(nm, length(values_vect))
    df_list[[i]] <- data.frame(group = group_vect, values = values_vect)
  }
  do.call("rbind", df_list)
}

replace_inf <- function(x){
  x[is.infinite(x)] <- 0
  x
}

```

```{r variables, echo = F, warning=F, message=F}


```

```{r run-scripts, echo = F, warning=F, message=F}

# source("~/Documents/spolpred/r_scripts/spol_lin_levels_table.R")

```

```{r paths, echo = F, warning=F, message=F}

setwd("~/Documents/spolpred/r_scripts")

data_path <- "../data/"
results_path <- "../results/"
metadata_path <- "../../metadata/"

```

```{r files, echo = F, warning=F, message=F}

spol_data_file <- paste0(data_path, "spoligo_lineage.SNPs.csv")
spol_lin_levels_table_file <- paste0(results_path, "spol_lin_levels_table.csv")
family_lookup_file <- paste0(data_path, "family_lookup.csv")
metadata_file <- paste0(metadata_path, "tb_data_18_02_2021.csv")
animal_file <- paste0(data_path, "animal_spol_data.csv")

lin1_7_ggtree <- paste0(results_path, "lin1_7_ggtree.png")
lin2_ggtree <- paste0(results_path, "lin2_ggtree.png")
lin3_ggtree <- paste0(results_path, "lin3_ggtree.png")
lin4_ggtree <- paste0(results_path, "lin4_ggtree.png")
lin5_6_8_9_La_ggtree <- paste0(results_path, "lin5_6_8_9_La_ggtree.png")

```

```{r read-in-data, echo = F, warning=F, message=F}

spol_data <- read.csv(spol_data_file, header = T, colClasses = c("spoligotype" = "character"))
spol_lin_levels_table <- read.csv(spol_lin_levels_table_file, colClasses = c("spoligotype" = "character"))
family_lookup <- read.csv(family_lookup_file)
metadata <- read.csv(metadata_file)
animal <- read.csv(animal_file)

```

```{r clean-spol-data, echo = F, warning=F, message=F}

# Blank lineages - all 1.2.2.1 apparently
spol_data$lineage <- ifelse(spol_data$lineage == "", "lineage1.2.2.1", spol_data$lineage)
# Remove 0000000000000000000000000000000000000000000 - error apparently
spol_data <- subset(spol_data, !(spoligotype == "0000000000000000000000000000000000000000000"))

# Clean SIT and family cols
spol_data$SIT <- ifelse(spol_data$SIT == "", "-", spol_data$SIT)
spol_data$family <- ifelse(spol_data$family == "", "-", spol_data$family)

# Separate out all the metadata into lookup tables and data tables
lin_spol_sit_fam <- odr(unique(select(spol_data, lineage, spoligotype, SIT, family)))
sit_fam_spol <- odr(unique(select(spol_data, SIT, family, spoligotype)))
sit_fam <- odr(unique(select(spol_data, SIT, family)))
lin_fam <- odr(unique(select(spol_data, lineage, family)))

# Separate out the data for just correlating lineage and spol

# Remove "lineage" so that the levels can be split out
spol_data$lineage <- gsub("lineage", "", spol_data$lineage)

# Clean family
spol_data$family <- ifelse(spol_data$family == "-", "Unknown", spol_data$family)
spol_data$family <- ifelse(spol_data$family == "Zero-copy", "Unknown", spol_data$family)

# Clean animal spoligotypes (messed up when saving to csv and editing in excel)
animal <- merge(select(animal, -(spoligotype)), 
                select(spol_data, sample, spoligotype), 
                by = "sample", all.x = T, sort = F)
animal <- select(animal, sample, lineage, spoligotype, everything())


```

```{r main-lin-family-group, echo = F, warning=F, message=F}

# What is the correspondence between main lin and the (main) spol families?

# Clean
family_lookup <- subset(family_lookup, !(family == "Zero-copy"))

# Merge lineage into family lookup table and pull unique main lineage and family group 
lin_fam <- select(spol_data, sample, lineage, family)
lin_fam_merged <- merge(lin_fam, family_lookup, by = "family", all.x = T, sort = F)
lin_fam_merged$main_lin <- substr(lin_fam_merged$lineage, 1, 1)
lin_fam_merged$main_lin <- ifelse(grepl("La", lin_fam_merged$lineage), "La", lin_fam_merged$main_lin)

manu <- subset(lin_fam_merged, family_group == "Manu")
manu_spol <- merge(manu, select(spol_data, sample, spoligotype), by = "sample")
write.csv(manu_spol, "../results/manu_spol.csv", row.names = F, quote = F)

# Find the anomalous main lin-family groups - ones with just a few samples
# e.g. some L1 samps are AFRI, which is clearly not correct
lin_fam_freq_tab <- as.data.frame.matrix(table(lin_fam_merged$family_group, lin_fam_merged$main_lin))

# Get numbers for spol families
n_samps_family <- data.frame(as.list(sort(rowSums(lin_fam_freq_tab), decreasing = T)))

# Clean and add totals for display
lin_fam_freq_tab <- cbind(Family = row.names(lin_fam_freq_tab), lin_fam_freq_tab)
lin_fam_freq_tab <- adorn_totals(lin_fam_freq_tab, where = c("row", "col"))

# Make a table of the 'proper' correspondence between main lin and family group, 
# taking out the anomalous ones from the freq table
main_lin_family_group <- unique(select(lin_fam_merged, main_lin, family_group))
main_lin_family_group <- subset(main_lin_family_group, !is.na(family_group))
main_lin_family_group <- subset(main_lin_family_group, !(family_group == "Unknown"))
main_lin_family_group <- odr(main_lin_family_group)

main_lin_family_group <- subset(main_lin_family_group, !(main_lin == "1" & family_group == "AFRI"))
main_lin_family_group <- subset(main_lin_family_group, !(main_lin == "4" & family_group == "AFRI"))
main_lin_family_group <- subset(main_lin_family_group, !(main_lin == "1" & family_group == "Beijing"))
main_lin_family_group <- subset(main_lin_family_group, !(main_lin == "3" & family_group == "Beijing"))
main_lin_family_group <- subset(main_lin_family_group, !(main_lin == "5" & family_group == "Beijing"))
main_lin_family_group <- subset(main_lin_family_group, !(main_lin == "3" & family_group == "BOV"))
main_lin_family_group <- subset(main_lin_family_group, !(main_lin == "1" & family_group == "CAS"))
main_lin_family_group <- subset(main_lin_family_group, !(main_lin == "2" & family_group == "CAS"))
main_lin_family_group <- subset(main_lin_family_group, !(main_lin == "4" & family_group == "CAS"))
main_lin_family_group <- subset(main_lin_family_group, !(main_lin == "5" & family_group == "CAS"))
main_lin_family_group <- subset(main_lin_family_group, !(main_lin == "4" & family_group == "EAI"))
main_lin_family_group <- subset(main_lin_family_group, !(main_lin == "1" & family_group == "PINI2"))
main_lin_family_group <- subset(main_lin_family_group, !(main_lin == "4" & family_group == "PINI2"))
main_lin_family_group <- subset(main_lin_family_group, !(main_lin == "3" & family_group == "T"))

main_lin_family_group <- rm_dup_group(main_lin_family_group, "main_lin")

names(main_lin_family_group) <- c("Main lineage", "Spoligotype family group")

```

```{r geo, echo = F, warning=F, message=F}

# Clean metadata regions
metadata$subregion <- ifelse(metadata$subregion == "Australia and New Zealand", "Oceana", metadata$subregion)
metadata$subregion <- ifelse(metadata$subregion == "Northern America", "North America", metadata$subregion)
metadata$subregion <- ifelse(metadata$subregion == "#N/A", "Unknown", metadata$subregion)

# Merge metadata to spol family data
geo_df <- select(metadata, wgs_id, country_code, country, region, subregion)
lin_fam_geo_df <- merge(lin_fam_merged, geo_df, by.x = "sample", by.y = "wgs_id", all.x = T, sort = F)

# Make table of region and spol family
region_family_tab <- as.data.frame.matrix(table(lin_fam_geo_df$subregion, lin_fam_geo_df$family_group))
# region_family_tab <- cbind(Region = row.names(region_family_tab), region_family_tab)

# Get geo numbers
n_samps_geo <- data.frame(as.list(sort(rowSums(region_family_tab), decreasing = T) ))

# Wrangle for plot
# Normalise across row (Have to transpose for some reason. Stupid!)
region_family_tab <- cbind(Region = row.names(region_family_tab),
      data.frame(t(apply(num_cols(region_family_tab), 1, function(x) {round(x/sum(x), 2)}))))

# Clean - re-arrange unknown
unknown_row <- subset(region_family_tab, Region == "Unknown")
region_family_tab <- subset(region_family_tab, !(Region == "Unknown"))
region_family_tab <- rbind(region_family_tab, unknown_row)

# Make long format for heatmap
region_family_tab_plot <- region_family_tab %>% gather(Family, value, -Region)

# Plot
max_n <- round_any(max(region_family_tab_plot$value), 1000)
leg_ticks <- c(0, 10, 100, 1000, 2000)
leg_breaks <- replace_inf(log(leg_ticks))
# region_family_plot <- ggplot(data = region_family_tab_plot, 
#             aes(x = Family, y = Region, fill = log(value+1))) +
region_family_plot <- ggplot(data = region_family_tab_plot, 
            aes(x = Family, y = Region, fill = value)) +
  geom_tile()+
  theme(axis.text.x = element_text(angle = 45, hjust = 1))+
  # scale_fill_continuous(breaks = leg_breaks, 
  #                       labels = leg_ticks, 
  #                       name = "n")+
  geom_text(aes(label = value), color = "white", size = 2.25)+ 
  scale_y_discrete(limits=rev)+
  coord_fixed()

region_family_plot_file <- paste0(results_path, "region_family_plot.png")
ggsave(plot = region_family_plot, 
       file = region_family_plot_file, 
       width = 1500/7, height = 1000/7, units = "mm")

```

```{r clean-spol-data-ctnd, echo = F, warning=F, message=F}

# Just retain sample, lin and spol cols 
spol_data <- select(spol_data, sample, lineage, spoligotype)

# Remove and store animal strains - need to process separately
# Add back in after expanding animal strains manually in excel
# animal <- subset(spol_data, grepl("La", lineage))
# write.csv(animal, file = paste0(data_path, "animal_spol_data.csv"), 
#           quote = F, row.names = F)
spol_data <- subset(spol_data, !(grepl("La", lineage)))

# Expand lineages, rbind animal back in and merge
exp <- expand_hierarchy_fill(spol_data, "sample", "lineage")
# data <- merge(rbind(spol_data, animal), exp,
#               by.x = "sample", by.y = "id", all.x = T, 
#               sort = F)
spol_data <- merge(spol_data, exp,
                   by.x = "sample", by.y = "id", all.x = T, 
                   sort = F)

# Add animal back in after processing manually
spol_data <- rbind(spol_data, animal)

```

```{r clean-results-table, echo = F, warning=F, message=F}

# Split into two tables - one with all results, and one top 5 spols by proportion of samples in lin 

spol_lin_levels_split <- split(spol_lin_levels_table, spol_lin_levels_table$level)

spol_lin_levels_top <- list()
for(level in names(spol_lin_levels_split)){
  
  level_data <- spol_lin_levels_split[[level]]
  level_data_split <- split(level_data, level_data$lineage)
  
  lin_list <- list()
  for(lin in names(level_data_split)){
    
      # Get the top 5 sample proportions and save as separate list
      top_col_prob <- sort(level_data_split[[lin]]$col_prob, decreasing = T)
      top_col_prob <- top_col_prob[1:5]
      
      # print(level_data_split[[lin]][which(level_data_split[[lin]]$col_prob %in% top_col_prob), ])
      lin_list[[lin]] <- level_data_split[[lin]][which(level_data_split[[lin]]$col_prob %in% top_col_prob), ]
  }
  spol_lin_levels_top[[level]] <- do.call("rbind", lin_list)
}

# Tidy top results table for display 
# - need to do before r-binding because all dups will be removed, not just the consecutive ones
spol_lin_levels_table_display <- lapply(spol_lin_levels_top, rm_dup_group, "lineage")
spol_lin_levels_table_display <- lapply(spol_lin_levels_table_display, rm_dup_group, "level")

spol_lin_levels_table_display <- do.call("rbind", spol_lin_levels_table_display)

# Need to wrap spol in quotes for otherwise printout is dodgy 
spol_lin_levels_table_display$spoligotype <- paste0("\"", spol_lin_levels_table_display$spoligotype, "\"")

names(spol_lin_levels_table_display) <- c("Level",
                                          "Lineage",
                                          "Spoligotype",
                                          "SIT",
                                          "Family",
                                          "Proportion in lin.",
                                          "n in lineage",
                                          "% of lin")

# spol_lin_levels_table$Level <- ifelse(is.na(spol_lin_levels_table$Level), "", spol_lin_levels_table$Level)

```

```{r basic-numbers-before-filter, echo = F, warning=F, message=F}

n_total_samps_before_filter <- length(spol_data$sample)
n_unique_lins_before_filter <- length(unique(spol_data$lineage))
n_unique_spol_before_filter <- length(unique(spol_data$spoligotype))

```

```{r filter-spol-five-samps, echo = F, warning=F}

# Keep only those with 5 or more samples per spoligo
spol_data <- spol_data %>% group_by(spoligotype) %>% filter(n() > 4) %>% data.frame()

```

```{r basic-numbers-after-filter, echo = F, warning=F, message=F}

n_total_samps_after_filter <- length(spol_data$sample)
n_unique_lins_after_filter <- length(unique(spol_data$lineage))
n_unique_spol_after_filter <- length(unique(spol_data$spoligotype))

```

```{r table-1, echo = F, warning=F, message=F}

n_pivot_lv1 <- reshape2::dcast(spol_data, lin_level_1 ~ 'n_samp', value.var = "sample", fun.aggregate = len_uniq)
spol_pivot_lv1 <- reshape2::dcast(spol_data, lin_level_1 ~ 'n_spol', value.var = "spoligotype", fun.aggregate = len_uniq)

n_pivot_lv2 <- reshape2::dcast(spol_data, lin_level_2 ~ 'n_samp', value.var = "sample", fun.aggregate = len_uniq)
spol_pivot_lv2 <- reshape2::dcast(spol_data, lin_level_2 ~ 'n_spol', value.var = "spoligotype", fun.aggregate = len_uniq)

table_1_lv1 <- data.frame(cbind(to_table(n_pivot_lv1, "col"), to_table(spol_pivot_lv1, "col")))
table_1_lv1 <- dplyr::select(table_1_lv1, -(lin_level_1.1),  -(Total), -(Total.1))
table_1_lv1 <- data.frame(cbind(level = rep("1", nrow(table_1_lv1)), table_1_lv1))

table_1_lv2 <- data.frame(cbind(to_table(n_pivot_lv2, "col"), to_table(spol_pivot_lv2, "col")))
table_1_lv2 <- dplyr::select(table_1_lv2, -(lin_level_2.1),  -(Total), -(Total.1))
table_1_lv2 <- data.frame(cbind(level = rep("2", nrow(table_1_lv2)), table_1_lv2))

table_1 <- rbind_force(table_1_lv1, table_1_lv2)

table_1 <- rm_dup_group(table_1, "level")

names(table_1) <- c("Level", "Lineage", "n samples", "n unique spoligotypes")

```

```{r spol-lin-results, echo = F, warning=F, message=F}

# Split out by lin level
spol_lin_levels_table_split <- split(spol_lin_levels_table, spol_lin_levels_table$level)

# Make lists to store stats for each level
pure_n_list <- list() # N spols pure at each level
pure_pc_list <- list() # Overall % of spols pure at each level
med_pc_samps_pure_list <- list() # Take the median of this vector

for(level in names(spol_lin_levels_table_split)){
  
  # Table of all the spoligotypes, pure and unpure
  all_spols_at_level <- spol_lin_levels_table_split[[level]]
  
  # Subset the pure ones
  pure <- subset(all_spols_at_level, prob == 1)
  
  # Add 'lv' to make it easier to subset lists later
  new_lv_name <- paste0("lv", level)
  
  # N spols pure at a level
  pure_n_list[[new_lv_name]] <- length(pure$spoligotype)
  # What % of all the spols at the level are pure?
  pure_pc_list[[new_lv_name]] <- (pure_n_list[[new_lv_name]]/length(all_spols_at_level$spoligotype))*100
  
  # Save the median of this value
  med_pc_samps_pure_list[[new_lv_name]] <- round(median(pure$col_prob), 2)
  
}

```

```{r spol-lin-results-plot, echo = F, warning=F, message=F}

spol_lin_levels_table$col_prob_log10 <- log10(spol_lin_levels_table$col_prob)
spol_lin_levels_table$col_prob_log10 <- ifelse(is.infinite(spol_lin_levels_table$col_prob_log10), 
                                               min(spol_lin_levels_table$col_prob_log10[!is.infinite(spol_lin_levels_table$col_prob_log10)]),
                                               spol_lin_levels_table$col_prob_log10)

pure_pc_df <- list_to_df_group(pure_pc_list)
pure_pc_df$group <- 1:4

y_A <- seq(0, 2, 0.5)
y_B <- seq(0, 10, 2) 
y_C <- seq(20, 50, 10) 
y_D <- seq(60, 100, 20)
y_ax <- c(y_A, y_B, y_C, y_D)
spol_lin_results_plot <- ggplot()+
  geom_boxplot(data = spol_lin_levels_table, aes(x = as.factor(level), y = col_prob))+
  geom_line(data = pure_pc_df, aes(x=group, y=values, group=1), color="red", size = 1)+
  geom_point(data = pure_pc_df, aes(x=group, y=values), size = 3, colour = "blue")+
  xlab("Lineage level")+
  ylab("Percentage")+
  scale_y_log10(breaks = y_ax)+
  theme_bw()
spol_lin_results_plot_file <- "../results/spol_lin_results_plot.png"

ggsave(file = spol_lin_results_plot_file, plot = spol_lin_results_plot, width = 1100/5, height = 700/5, units = "mm")

```

```{r working, echo = F, warning=F, message=F}

```


| | |
| ----------- | ----------- |
|Gary Napier^1^ |	gary.napier@lshtm.ac.uk|
|Susana Campino^1^ | susana.campino@lshtm.ac.uk|
|Jody Phelan^1^,^\*^ | jody.phelan@lshtm.ac.uk|
|Taane G. Clark^1,5,\*^ | taane.clark@lshtm.ac.uk|

1. Faculty of Infectious and Tropical Diseases, London School of Hygiene & Tropical Medicine, WC1E 7HT London, UK
2. Faculty of Epidemiology and Population Health, London School of Hygiene & Tropical Medicine, WC1E 7HT London, UK

\* joint authors

**Genome Medicine:**

### Abstract

**Background:** Strain-types of *Mycobacterium tuberculosis*, the bacterial pathogen underlying tuberculosis disease (TB), have been associated with drug resistance, transmissibility, virulence, and host-pathogen interactions. Spoligotyping is an established genotyping technique, and historically used to describe strain-types globally. Advances in sequencing technologies have led to whole genome characterisation and determination of barcoding mutations for strain-types through a sub-lineage nomenclature. Given the large number of *M. tuberculosis*, there is a need to update the *in silico* profiling of spoligotypes, and link it to established sub-lineages. 

**Results:** 

  - XXX Updating of spolpred and codes, software XXX
    
  - [XXX Distributions of spoligotypes globally. XXX] Although the geographical sources of our samples somewhat agreed with the phylogeographical spoligotype families, there were many exceptions, though this may be a reflection of sampling bias.  
    
  - [ XXX Correlation with new sublineage system. XXX ] We found that many spoligotypes were purely associated with the main MTBC lineages as well as the second level of the hierarchical MTBC lineage clades. Conversely, many spoligotyopes that were less purely associated with lineages nevertheless appeared in a large proportion of those lineages. At lower levels of the lineage system there were fewer spoligotypes purely associated with those lineages. A full table of results can be found at github.com/GaryNapier/spolpred/blob/master/results/spol_lin_levels_table.csv

**Conclusions:** We present a faster more streamlined software for predicting spoligotypes *in silico* from WGS. Soligotypes are usefully predictive of lineage at the first two hierarchical lineage levels.  

**URL:** link to new spolpred2

**Keywords:** *Mycobacterium tuberculosis*, spoligotypes, lineages, phylogeny, spolpred

### Background

<!-- Napier [@Napier2020] -->
<!-- Brudey [@Brudey2006] -  spoligotyping database  -->
<!-- Kamerbeek [@Kamerbeek1997] -->
<!-- Coll (spolpred) [@Coll2012] -->

Tuberculosis is an infectious disease of high global burden caused by members of the *Mycobacterium tuberculosis* complex (MTBC), which includes *M. tuberculosis sensu stricto* (*Mtb*), *M. africanum* and animal strains such as *M. bovis*. Though the MTBC is described as clonal, there is enough variation to distinguish strain types within members of the complex. *Mtb* and *M. africanum* are phylogenetically classified in nine main lineages (L1-9). In particular, strain types are distributed phylogeographically. 

Spoligotyping is a fingerprinting PCR techniques [@Kamerbeek1997], which exploits the polymorphism harboured at the direct repeat (DR) locus of MTBC. It is based on the PCR amplification of 43 short unique sequences (termed spacers) contained between well-conserved 36-bp DRs and the subsequent hybridisation of the products onto a membrane with oligonucleotides complementary to each spacer. Since strains vary in the occurrence of spacers, each sample produces a distinctive spot pattern, which is then translated into a numerical code of 8 digits. More than 60 lineages/sub-lineages have been defined based on octal codes, each one normally showing a specific world distribution ('family') [@Brudey2006]. 

Spoligotyping nomenclature [@Brudey2006] reflects the phylogeographical structure of MTBC and its main families overlap the lineage system (**Table \@ref(tab:main-lin-fam-group-tab)**). These overlaps are well preserved in our data; **Table \@ref(tab:lin-fam-freq-tab)** shows there are only a few samples in each main lineage mis-assigned a spoligotype family (for example 4 samples in L1 are assigned to AFRI).

Both the spoligotype system and the lineage system have more fine-grained nomenclature than shown in **Table \@ref(tab:lin-fam-freq-tab)**. Spoligotype families are further subdivided into sub-families such as AFRI1, AFRI2, AFRI3, preserving geographical links [@Brudey2006], while the lineage system, although not geographically associated, discerns small clades of the full MTBC phylogenetic tree in a numerically hierarchical manner (e.g. 1, 1.1, 1.1.1) [@Napier2020]. Although the relationship between these systems is well preserved in our data at the highest level, it is unclear how these systems diverge at lower levels. 

Strain identification is crucial to addressing key epidemiological questions, providing information on the individial as well as global scales. Strain typing is informative in the investigation of transmission events because although two samples of the same strain may or may not have been transmitted, two samples cannot have been transmitted if they are from two different (sub-)lineages. In the wider context, strain typing provides valuable insight into the spread of MTBC variants, indicating potential differences in genotype-phenotype interaction. There is evidence for example that Beijing strains show lineage-specific associations with drug resistance [@Oppong2019], and that the geographical ubiquity of lineages 2 (Beijing) and 4 (Euro-American-Indian) can be attributed to virulence and transmissibility [@Coscolla2014a]. Furthermore, strain typing at higher phylogenetic resolution can reveal within-strain differences, such as the typical and atypical Beijing strains varying in geographical distribution, resistance and virulence [@Forrellad2013][@Ribeiro2014]. Advances in sequencing technologies will lead high-resolution strain typing offered by whole genome sequencing, which ought to improve transmission studies and enable the tracking of between- and within-lineage genotypic-phenotypic differences. 

The lineage system characterised in Napier (2020) [@Napier2020] names MTBC clades in a hierarchy of lineages and sublineages. The first level names the familiar major lineages as 1-9, plus animal strains. Sublineages consist of progressively finer resolution of the phylogenetic tree - for example lineage 1 is sub-divided into two main clades, 1.1 and 1.2, and so on **Figure \@ref(fig:lin-1-7-tree)**. These lineages and sublineages overlap with pre-established lineage systems such as regions of difference (RD), preserving major phylogenetic structural changes at the higher levels. Departing from these other lineage systems, it identifies finer resolution based on statistical differences in the branch lengths of the MTBC phylogenetic tree. The identifying markers of these clades, rather than being major structural changes of the MTBC genome, are individual (synonymous) SNPs with a fixation index (F~st~) score of 1, meaning that the SNP is unique to the clade. 

One of the central questions we consider here is at which level of the  Napier *et al.* (2020) lineage system spoligotypes are usefully associated. The phylogenetic trees in **Figure \@ref(fig:lin-1-7-tree)** clearly show a high degree of noise among the individual spoligotypes. While some patterns can be discerned between the major lineages (the overall spoligotype pattern of lineage 1 is clearly different to lineage 2 for example), it is less clear how spoligotypes vary with the lower levels of the lineage system (1.1, 1.1.1, 1.1.1.1 etc). We developed a score for each spoligotype measuring how purely each is associated to a lineage, at each level, weighted by sample size. This score is somewhat similar to the F~st~ fixiation index used in [@Napier2020], and a score of 1 indicates the spoligotype occurs exclusively in a lineage (see **Methods**). 

Spoligotyping is still a technology of choice in some settings however, and it is possible to *in silico* predict spoligotypes from SpolPred [@Coll2012]. With a great number of *Mtb* WGS available, we seek to check consistency with the sub-lineage system [@Napier2020], and assess their global distribution. This is achieved through developing software ("Spolpred2") to *in silico* genotype isolates, to predict the spoligotype from raw sequence reads. 

##### Implementation

Description of the overall architecture of the software implementation

We have developed a XXXXXX executable to predict the spoligotype octal code from FASTQ files, including those from XXXXXXXX platforms. 

Appearance of all 43 queries is eventually translated into the octal code which is then matched to a spoligotype in the latest version of the international spoligotyping database (SpolDB5).

The software was run on 40k Mtb

### Methods

**Association of spoligotypes to lineages**

As there were many spoligotypes in low numbers of samples and therefore offering little predictive power, those appearing in fewer than five samples were excluded. Since we were interested in the strength of association between spoligotypes and the various levels of the Napier *et al.* (2020) lineage system, the lineages were parsed into a hierarchy for each round of analysis. For example, the first level analysed the association between each spoligotype and the main *Mtb* lineages 1-7. Next was the association between each spoligotype and the second level, represented by lineages 1.1, 1.2, 2.1, 2.2, etc. This hierarchy consisted of four levels, the last being e.g. lineage 1.1.1.1. As the system is hierarchical, any spoligotypes still appearing in samples at a higher level were included in the association calculations. Hence the results in **Table \@ref(tab:spol-lin-levels-table)** show for example lineage 3 appearing along with lineage 3.1 at the second lineage level. 

To assess how closely associated each spoligotype is to each lineage, at each level, a score was developed analagous to the fixation index F~st~ [@Weir1984]. This statistic assigns a score of 1 if an allele is fixed in a given population, and is not present outside that group. Similarly, the spoligotype score here assigns a score of 1 if a spoligotype is only found in a given lineage, and anything less than 1 indicates that the spoligotype is found in at least one other sample belonging to another lineage. 

Our calculation proceeded as follows: At each lineage level, a frequency table was made of samples for each spoligotype by lineage. For each lineage, the sample frequencies were first converted to a proportion of the total lineage sample size in order to weight the final association score by sample size. Then, for each spoligotype, this sample size proportion was calculated as a proportion of occurrences across each lineage (column "Proportion in lineage" in **Table \@ref(tab:spol-lin-levels-table)**).
      
These calculations yield a measure of how purely associated each spoligotype is to each lineage, at each level. A score of 1 for a spoligotype-lineage combination means a spoligotype only appears in that particular lineage. For example, spoligotype 1001111111111111111111111111000010110001111 scores 1 for lineage 1.1, meaning this spoligotype is only found in this lineage and no others (at the second level of the lineage system). 

### Results

**Global distribution of spoligotype families**

```{r family-numbers, echo = F, warning=F, message=F}

beijing_n <- fmt(n_samps_family$Beijing)
beijing_pc <- fmt_pc(n_samps_family$Beijing/n_total_samps_before_filter)

T_n <- fmt(n_samps_family$T)
T_pc <- fmt_pc(n_samps_family$T/n_total_samps_before_filter)

LAM_n <- fmt(n_samps_family$LAM)
LAM_pc <- fmt_pc(n_samps_family$LAM/n_total_samps_before_filter)

unknown_family_n <- fmt(n_samps_family$Unknown)
unknown_family_pc <- fmt_pc(n_samps_family$Unknown/n_total_samps_before_filter)

```

```{r geo-numbers, echo = F, warning=F, message=F}

northern_europe_n <- fmt(n_samps_geo$Northern.Europe)
northern_europe_pc <- fmt_pc(n_samps_geo$Northern.Europe/n_total_samps_before_filter)

southern_africa_n <- fmt(n_samps_geo$Southern.Africa)
southern_africa_pc <- fmt_pc(n_samps_geo$Southern.Africa/n_total_samps_before_filter)

se_asia_n <- fmt(n_samps_geo$Southeast.Asia)
se_asia_pc <- fmt_pc(n_samps_geo$Southeast.Asia/n_total_samps_before_filter)

unknown_geo_n <- fmt(n_samps_geo$Unknown)
unknown_geo_pc <- fmt_pc(n_samps_geo$Unknown/n_total_samps_before_filter)

```

The most frequent spoligotype family in our data belongs to Beijing (`r beijing_n`; `r beijing_pc`), followed by T (`r T_n`; `r T_pc`) and LAM (`r LAM_n`; `r LAM_pc`), though many samples had an unknown family (`r unknown_family_n`; `r unknown_family_pc`). The most common geographical regions in which our samples are found were Northern Europe (`r northern_europe_n`; `r northern_europe_pc`), Southern Africa (`r southern_africa_n`; `r southern_africa_pc`) and Southeast Asia (`r se_asia_n`; `r se_asia_pc`), as with family, many samples were of unknown origin (`r unknown_geo_n`; `r unknown_geo_pc`). **Figure \@ref(fig:region-family-plot)** shows the frequency of samples gathered in a geographical region versus the spoligotype family. While many samples occur in their expected geographical region, there is much variation as to where in the world a spoligotype family is found. The discordance of geographical distribution with respect to spoligotype family in our data perhaps reflects samples being taken as part of transmission studies or other clinically relevant investigation. 

**Association of spoligotypes to lineages**

Before filtering the spoligotypes to those appearing in five or more samples, our data consisted of `r fmt(n_total_samps_before_filter)` samples, `r fmt(n_unique_lins_before_filter)` unique lineages and sublineages, and `r fmt(n_unique_spol_before_filter)` unique spoligotypes. This filtering step resulted in `r fmt(n_total_samps_after_filter)` samples, `r fmt(n_unique_lins_after_filter)` unique lineages and `r fmt(n_unique_spol_after_filter)` distinct spoligotypes. 

Many spoligotypes were found to be exclusive to lineages at each level, however in many cases they nevertheless appeared in a relatively small proportion of that lineage's total samples, for example spoligotype 1101111111111111111001111111000010111111111 is only found in lineage 1, but appears in only 17.2% of that lineage's total samples. Conversely, less pure spoligotypes were found which in fact appeared in a large proportion of samples (spoligotype 0000000000000000000000000000000000111111111 scored 0.99 for association to lineage 2, but appears in 91.2% of its samples). Therefore, we include the number of samples with a given spoligotype as well as the percentage of the lineage's total samples in **Table \@ref(tab:spol-lin-levels-table)**. 

For simplicity, our results in **Table \@ref(tab:spol-lin-levels-table)** only show the top five most-closely associated spoligotypes for each lineage. These are ordered first by purity - i.e. the "Proportion in lineage score", then by percentage of samples in the lineage with this spoligotype (column "% of lineage"). The full table of results for the unfiltered spoligotypes can be found at github.com/GaryNapier/spolpred/blob/master/results/spol_lin_levels_table.csv

At the first lineage level (lineages 1-7), there were `r pure_n_list$lv1` (`r pc(pure_pc_list$lv1)`) spoligotypes appearing exclusively in their respective lineages, however the the median percentage of samples with a pure spoligotype across all lineages 1-7 was very low at `r med_pc_samps_pure_list$lv1`. 

The levels show decreasing numbers and proportions of samples with pure spoligotypes (second level: n = `r pure_n_list$lv2` (`r pc(pure_pc_list$lv2)`), third level: n = `r pure_n_list$lv3` (`r pc(pure_pc_list$lv3)`), fourth level: `r pure_n_list$lv4` (`r pc(pure_pc_list$lv4)`)), but the median percentage of samples with pure spoligotypes, while remaining low very, actually increased (second level: `r med_pc_samps_pure_list$lv2`, third level: `r med_pc_samps_pure_list$lv3`, fourth level: `r med_pc_samps_pure_list$lv4`) (**Figure \@ref(fig:spol-lin-results-plot-display)**). 

### Discussion

Although many spoligotypes were shown to be purely associated to a lineage, even to the lowest lineage level, a significant number of these were in a small proportion of the lineage samples. On the other hand, a number of spoligotypes were less predictive of lineage, but appeared in a large proportion of the lineage samples. These latter spoligotypes are of course more likely to be encountered, and so although they have a lower purity score, should be considered useful. 

The percentage of spoligotypes purely associated to a lineage decreased significantly from `r pc(pure_pc_list$lv1)` at the first lineage level to `r pc(pure_pc_list$lv4)`) at the fourth, indicating that spoligotypes in general are only usefully predictive of perhaps the first two levels. 

### Conclusions

### Availability and requirements**

### List of abbreviations

|||
|:----|:----------------|
| AFRI | *M. africanum* |
| BOV | *M. bovis* (animal) |
| CAS | Central Asian Strains |
| DR | Direct repeat |
| EAI | East-African-Indian |
| H | Haarlem |
| L | Lineage |
| LAM | Latin America-Mediterranean |
| *Mtb* | *Mycobacterium tuberculosis* | 
| MTBC | *Mycobacterium tuberculosis* complex |
| PCR | Polymerase chain reaction |
| PINI2 | *M. pinnipedii* (animal) |
| RD | Region of difference |
| S | XXX |
| SNP | Single nucleotide polymorphism |
| T | Ghana XXX ? - CHECK XXX |
| WGS | Whole genome sequencing |


**Declarations**

**Ethics approval and consent to participate**
Not applicable

**Consent for publication**
Not applicable 

**Availability of data and materials**

**Competing interests**
The authors declare that they have no competing interests

**Funding**
GN is funded by an BBSRC-LiDO PhD studentship. JEP is funded by a Newton Institutional Links Grant (British Council, no. 261868591). TGC is funded by the Medical Research Council UK (Grant no. MR/M01360X/1, MR/N010469/1, MR/R025576/1, and MR/R020973/1). SC is funded by Medical Research Council UK grants (ref. MR/M01360X/1, MR/R025576/1, and MR/R020973/1). The authors declare no conflicts of interest. The funders had no role in the design of the study and collection, analysis, and interpretation of data and in writing the manuscript should be declared.

**Authors' contributions**
XXX, JEP and TGC conceived and directed the project. XXXXXXX contributed data. GN performed bioinformatic and statistical analyses under the supervision of SC, JEP and TGC. GN, SC, JEP and TGC interpreted results. GN wrote the first draft of the manuscript with inputs from JEP and TGC. All authors commented and edited on various versions of the draft manuscript and approved the final version. GN, SC, JEP, and TGC compiled the final manuscript. 

**Acknowledgements**

## FIGURES

```{r spol-lin-results-plot-display, echo = F, warning=F, message=F, fig.cap = "Boxplot: Aggregated percentages of samples with each spoligotype, within each lineage; Line: Total percentage of 'pure' spoligotypes."}
  
knitr::include_graphics(spol_lin_results_plot_file)

```

```{r lin-1-7-tree, echo = F, warning=F, fig.cap = "Phylogenetic trees showing lineage or sublineage, family and spoligotypes."}

knitr::include_graphics(lin1_7_ggtree)

```

```{r lin-2-tree, echo = F, warning=F}

knitr::include_graphics(lin2_ggtree)

```

```{r lin-3-tree, echo = F, warning=F}

knitr::include_graphics(lin3_ggtree)

```

```{r lin-4-tree, echo = F, warning=F}

knitr::include_graphics(lin4_ggtree)

```

```{r lin-5-tree, echo = F, warning=F}

knitr::include_graphics(lin5_6_8_9_La_ggtree)

```

```{r region-family-plot, echo = F, warning=F, fig.cap="Heatmap of samples by spoligotype family and region of sample collection, normalised by Region (row)."}

knitr::include_graphics(region_family_plot_file)

```


## TABLES

```{r table-1-show, echo = F, warning=F}

cap <- "Numbers of samples and unique spoligotypes for the first two lineage levels after filtering out spoligotypes occurring in fewer than five samples"

knitr::kable(table_1, row.names = F, caption = cap, format = "pipe")

```

```{r main-lin-fam-group-tab, echo = F, warning=F}

cap <- "Main *M.tb* lineages (1-7, plus animal strains) and their corresponding spoligotype families"

knitr::kable(main_lin_family_group, row.names = F, caption = cap, format = "pipe")

```

EAI = East-African-Indian;
CAS = Central Asian Strains;
H = Haarlem;
LAM = Latin America-Mediterranean;
S = XXX;
T = Ghana XXX ? - CHECK XXX;
AFRI = *M. africanum*;
BOV = *M. bovis* (animal);
PINI2 = *M. pinnipedii* (animal)


```{r lin-fam-freq-tab, echo = F, warning=F}

cap <- "Frequency table of samples by main lineage and spoligotype family"

knitr::kable(fmt(lin_fam_freq_tab), row.names = F, caption = cap, format = "pipe")


```


```{r spol-lin-levels-table, echo = F, warning=F}

cap <- "Correspondence between lineage and spoligotypes at each of the four levels of lineage."

knitr::kable(spol_lin_levels_table_display, row.names = F, caption = cap, format = "pipe")

```



## REFERENCES
























