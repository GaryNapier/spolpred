---
title: "Accurate *in silico* prediction of *Mycobacterium tuberculosis* spoligotypes from whole genome sequences"
output: 
  bookdown::word_document2: 
    fig_caption: yes
    table_caption: yes
    number_sections: no
    reference_docx: ../../pipeline/word_template/use_template.docx
bibliography: ../../pipeline/references/all_refs.bib
csl: ../../pipeline/references/biomed-central.csl
---

```{r setup, include=FALSE, echo = F, warning=F, message=F}

# SETUP ----

rm(list = ls())

knitr::opts_chunk$set(echo = F)
# options(scipen=1, digits=2)
options(scipen=999, digits = 3)
table_font_sz <- 8

```

```{r library, include=FALSE, echo = F, warning=F, message=F}

# library(sjmisc)
library(plyr)
library(dplyr)
library(tibble)
library(stringr)
library(ggplot2)
library(tidyverse)
library(tidyr)
library(janitor)
library(scatterpie)

```

```{r functions, echo = F, warning=F, message=F}

source("https://raw.githubusercontent.com/GaryNapier/Packages_functions/master/Functions.R")

non_num_cols <- function(x){
  # Returns only the non-numeric columns of a dataframe
  x[!(sapply(x, is.numeric))]
}

expand_hierarchy <- function(df, group_by_col_name, hierarchy_to_expand_col_name){
  # Takes df like this:
  #   ID      Group
  # 1 samp_1  4.2.1.1
  # 2 samp_2  1.2.1.2.1
  
  # And makes this:
  #   ID    lin_level_1 lin_level_2 lin_level_3 lin_level_4 lin_level_5   max_lin
  # 1 samp_1          4         4.2       4.2.1     4.2.1.1        <NA>   4.2.1.1
  # 2 samp_2          1         1.2       1.2.1     1.2.1.2   1.2.1.2.1 1.2.1.2.1
  
  split_lins <- stringr::str_split(df[[hierarchy_to_expand_col_name]], "\\.")
  max_lin_len <- max(sapply(split_lins, length))
  mat <- matrix(nrow = length(df[[group_by_col_name]]), ncol = max_lin_len+1)
  mat[, 1] <- df[[group_by_col_name]]
  for(i in 1:nrow(mat)){
    for(lin_level in 1:max_lin_len){
      
      len_lin <- length(split_lins[[i]])
      
      if(lin_level > len_lin){
        mat[i, lin_level+1] <- NA
      }else{
        mat[i, lin_level+1] <- paste0(split_lins[[i]][1:lin_level], collapse = ".")
      }
    }
  }
  
  max_lin <- vector()
  for(i in seq(nrow(mat))){
    max_lin[i] <- mat[i, which.max(sapply(mat[i, -1], len_str))+1]
  }
  mat <- data.frame(cbind(mat, max_lin), stringsAsFactors = F)
  names(mat) <- c("id", paste0("lin_level_", 1:(ncol(mat)-2) ), "max_lin")
  return(mat)
}


top_spol_freq <- function(x, col){
  x %>% 
    group_by_(.dots = lazyeval::lazy(col)) %>% 
    dplyr::count(.dots = lazyeval::lazy(col), spoligotype) %>% 
    dplyr::arrange(desc(n), .by_group = TRUE) %>%
    dplyr::top_n(10, n) %>% 
    data.frame()
}


tab2df <- function(df){
  as.data.frame.matrix(table(df))
}

row_probs <- function(x){
  # Dataframe:
  # fruit   X1 X2 X3
  # mangoes 90 10 20
  # bananas 10 90 80
  # Get the row-wise proportions for each number:
  # fruit   X1     X2     X3
  # mangoes 0.7500 0.0833 0.167
  # bananas 0.0556 0.5000 0.444
  # i.e. mangoes-X1 = 90/(90+10+20) = 0.75
  
  # Strip off the non-numeric col(s)
  x_non_num <- non_num_cols(x)
  # Strip off numeric cols for calculation 
  x <- num_cols(x)
  # Pre-define an empty matrix
  mat <- matrix(nrow = nrow(x), ncol = ncol(x))
  # Loop over rows 
  for(row in seq(nrow(x))){
    # Loop over cols in row
    for(col in seq(ncol(x[row, ]))){
      # Divide the number by the total in the row
      mat[row, col] <- x[row, col]/sum(x[row, ])
    }
  }
  # Put table back together
  cbind(x_non_num, setNames(data.frame(mat), names(x)))
}

col_probs <- function(x){
  # Dataframe:
  # fruit   X1 X2 X3
  # mangoes 90 10 20
  # bananas 10 90 80
  # Get the col-wise proportions for each number:
  # col_probs(x)
  # fruit   L1  L2  L3
  # mangoes 0.9 0.1 0.2
  # bananas 0.1 0.9 0.8
  # i.e. mangoes-X1 = 90/(90+10) = 0.9
  
  # Strip off the non-numeric col(s)
  x_non_num <- non_num_cols(x)
  # Strip off numeric cols for calculation 
  x <- num_cols(x)
  # Pre-define an empty matrix
  mat <- matrix(nrow = nrow(x), ncol = ncol(x))
  # Loop over rows 
  for(row in seq(nrow(x))){
    # Loop over cols in row
    for(col in seq(ncol(x[row, ]))){
      # Divide the number by the total in the row
      mat[row, col] <- x[row, col]/sum(x[ ,col])
    }
  }
  # Put table back together
  cbind(x_non_num, setNames(data.frame(mat), names(x)))
}

sort_df_by_col_name <- function(df, col, decreasing = T){
  df[order(df[, col],  decreasing = decreasing),]
}

rm_dup_group <- function(df, col){
  # If rows of groups are repeated in a col, replace repeats with blank ("")
  # For final display of tables
  # e.g. 
  # in
  # lineage value
  # L1      10
  # L1      20
  # L1      25
  # L2      100
  # L2      3
  # L2      21
  # out
  # lineage value
  # L1      10
  #         20
  #         25
  # L2      100
  #         3
  #         21
  df[which(duplicated(df[col])), col] <- ""
  df
}

pc <- function(x){
  paste0(round(x, 1), "%")
}

list_to_df_group <- function(lst){
  # lst <- list(X = 1:5, Y = LETTERS[1:5])
  # $X
  # [1]  1  2  3  4  5 
  # $Y
  # [1] "A" "B" "C" "D" "E"
  # list_to_df_group(lst)
  #      group values
  # 1      X      1
  # 2      X      2
  # 3      X      3
  # 4      X      4
  # 5      X      5
  # 6      Y      A
  # 7      Y      B
  # 8      Y      C
  # 9      Y      D
  # 10     Y      E
  
  df_list <- list()
  for(i in seq(lst)){
    values_vect <- lst[[i]]
    nm <- names(lst[i])
    group_vect <- rep(nm, length(values_vect))
    df_list[[i]] <- data.frame(group = group_vect, values = values_vect)
  }
  do.call("rbind", df_list)
}

replace_inf <- function(x){
  x[is.infinite(x)] <- 0
  x
}

add_pc_brkt <- function(df, col, rnd = 1){
  pcs <- round(df[, col]/sum(df[, col])*100, rnd)
  df <- fmt(df)
  df[, col] <- paste0(df[, col], " (", pcs, ")")
  df
}

all_dups <- function(df, col){
  duped <- df[duplicated(df[, col]), col]
  duped_df <- df[df[, col] %in% duped, ]
  duped_df[order(duped_df[, col]),]
}


```

```{r variables, echo = F, warning=F, message=F}


```

```{r run-scripts, echo = F, warning=F, message=F}

# source("~/Documents/spolpred/r_scripts/spol_lin_levels_table.R")

```

```{r paths, echo = F, warning=F, message=F}

setwd("~/Documents/spolpred/r_scripts")

data_path <- "../data/"
results_path <- "../results/"
metadata_path <- "../../metadata/"
db_path <- "../../pipeline/db/"

```

```{r files, echo = F, warning=F, message=F}

spol_data_file <- paste0(data_path, "spoligo_lineage.SNPs.csv")
spol_lin_levels_table_file <- paste0(results_path, "spol_lin_levels_table.csv")
family_lookup_file <- paste0(data_path, "family_lookup.csv")
regions_lookup_file <- paste0(db_path, "country_code_lookup.txt")
metadata_file <- paste0(metadata_path, "tb_data_18_02_2021.csv")
animal_file <- paste0(data_path, "animal_spol_data.csv")

lin1_7_ggtree <- paste0(results_path, "lin1_7_ggtree.png")
lin2_ggtree <- paste0(results_path, "lin2_ggtree.png")
lin3_ggtree <- paste0(results_path, "lin3_ggtree.png")
lin4_ggtree <- paste0(results_path, "lin4_ggtree.png")
lin5_6_8_9_La_ggtree <- paste0(results_path, "lin5_6_8_9_La_ggtree.png")

```

```{r read-in-data, echo = F, warning=F, message=F}

spol_data <- read.csv(spol_data_file, header = T, colClasses = c("spoligotype" = "character"))
spol_lin_levels_table <- read.csv(spol_lin_levels_table_file, colClasses = c("spoligotype" = "character"))
family_lookup <- read.csv(family_lookup_file)
regions_lookup <- read.delim(regions_lookup_file)
metadata <- read.csv(metadata_file)
animal <- read.csv(animal_file)

```

```{r clean-metadata, echo = F, warning=F, message=F}

# Clean metadata regions
metadata$subregion <- ifelse(metadata$subregion == "Australia and New Zealand", "Oceana", metadata$subregion)
metadata$subregion <- ifelse(metadata$subregion == "Northern America", "North America", metadata$subregion)
metadata$subregion <- ifelse(metadata$subregion == "#N/A", "Unknown", metadata$subregion)

```

```{r clean-spol-data, echo = F, warning=F, message=F}

# Remove spacers 
spol_data <- dplyr::select(spol_data, -(spacer1:spacer43))

# Blank lineages - all 1.2.2.1 apparently
spol_data$lineage <- ifelse(spol_data$lineage == "", "lineage1.2.2.1", spol_data$lineage)
# Remove 0000000000000000000000000000000000000000000 - error apparently
spol_data <- subset(spol_data, !(spoligotype == "0000000000000000000000000000000000000000000"))

# Clean SIT and family cols
spol_data$SIT <- ifelse(spol_data$SIT == "", "-", spol_data$SIT)
spol_data$family <- ifelse(spol_data$family == "", "-", spol_data$family)

# Separate out all the metadata into lookup tables and data tables
lin_spol_sit_fam <- odr(unique(select(spol_data, lineage, spoligotype, SIT, family)))
sit_fam_spol <- odr(unique(select(spol_data, SIT, family, spoligotype)))
sit_fam <- odr(unique(select(spol_data, SIT, family)))
lin_fam <- odr(unique(select(spol_data, lineage, family)))

# Separate out the data for just correlating lineage and spol

# Remove "lineage" so that the levels can be split out
spol_data$lineage <- gsub("lineage", "", spol_data$lineage)

# Clean family
spol_data$family <- ifelse(spol_data$family == "-", "Unknown", spol_data$family)
spol_data$family <- ifelse(spol_data$family == "Zero-copy", "Unknown", spol_data$family)

```

```{r animal-and-expand-lins-spol-data, echo = F, warning=F, message=F}

# Clean animal spoligotypes (messed up spol when saving to csv and editing in excel)
animal <- merge(select(animal, -(spoligotype)), 
                select(spol_data, sample, spoligotype), 
                by = "sample", all.x = T, sort = F)
animal <- select(animal, sample, lineage, spoligotype, everything())

# Prepare data for r-binding with animal. 

# head(animal)
# sample        lineage spoligotype lin_level_1 lin_level_2 lin_level_3 lin_level_4 lin_level_5
# ERR3275518     La1      1...0          La         La1         La1         La1         La1
# ERR2517357     La1      1...0          La         La1         La1         La1         La1

# Retain SIT and family data with sample as key
samp_sit_fam <- select(spol_data, sample, SIT, family)

# Retain same cols as animal
spol_data <- select(spol_data, sample, lineage, spoligotype)

# Remove and store animal strains - need to process separately
# Add back in after expanding animal strains manually in excel
# animal <- subset(spol_data, grepl("La", lineage))
# write.csv(animal, file = paste0(data_path, "animal_spol_data.csv"), 
#           quote = F, row.names = F)
spol_data <- subset(spol_data, !(grepl("La", lineage)))

# Expand lineages, rbind animal back in and merge
exp <- expand_hierarchy_fill(spol_data, "sample", "lineage")
# data <- merge(rbind(spol_data, animal), exp,
#               by.x = "sample", by.y = "id", all.x = T, 
#               sort = F)
spol_data <- merge(spol_data, exp,
                   by.x = "sample", by.y = "id", all.x = T, 
                   sort = F)

# Add animal back in after processing manually
spol_data <- rbind(spol_data, animal)

```

```{r add-metadata-to-spol-data, echo = F, warning=F, message=F}

# Merge SIT and family back in
spol_data <- merge(spol_data, samp_sit_fam, by = "sample", 
                   all.x = T, sort = F)

# Add in family group
spol_data <- merge(spol_data, select(family_lookup, family, family_group), 
                   by = "family", all.x = T, sort = F)

# Add in country and regions
spol_data <- merge(spol_data, select(metadata, wgs_id, country_code, region, subregion), 
                   by.x = "sample", by.y = "wgs_id", all.x = T, sort = F)

# Add WHO region
spol_data <- merge(spol_data, select(regions_lookup, country_code_lower, WHO_region), 
                   by.x = "country_code", by.y = "country_code_lower", all.x = T, sort = F)

# Clean
spol_data$WHO_region <- ifelse(is.na(spol_data$WHO_region), "Unknown", spol_data$WHO_region)


```

```{r clean-results-table, echo = F, warning=F, message=F}

# Split into two tables - one with all results, and one top 5 spols by proportion of samples in lin 

spol_lin_levels_split <- split(spol_lin_levels_table, spol_lin_levels_table$level)

spol_lin_levels_top <- list()
for(level in names(spol_lin_levels_split)){
  
  level_data <- spol_lin_levels_split[[level]]
  level_data_split <- split(level_data, level_data$lineage)
  
  lin_list <- list()
  for(lin in names(level_data_split)){
    
      # Get the top 5 sample proportions and save as separate list
      top_col_prob <- sort(level_data_split[[lin]]$col_prob, decreasing = T)
      top_col_prob <- top_col_prob[1:5]
      
      # print(level_data_split[[lin]][which(level_data_split[[lin]]$col_prob %in% top_col_prob), ])
      lin_list[[lin]] <- level_data_split[[lin]][which(level_data_split[[lin]]$col_prob %in% top_col_prob), ]
  }
  spol_lin_levels_top[[level]] <- do.call("rbind", lin_list)
}

```

```{r clean-results-table-ctnd, echo = F, warning=F, message=F}

# Tidy top results table for display 
# - need to do before r-binding because all dups will be removed, not just the consecutive ones
spol_lin_levels_table_display <- lapply(spol_lin_levels_top, rm_dup_group, "lineage")
spol_lin_levels_table_display <- lapply(spol_lin_levels_table_display, rm_dup_group, "level")

spol_lin_levels_table_display <- do.call("rbind", spol_lin_levels_table_display)

# Need to prefix s otherwise printout is dodgy 
spol_lin_levels_table_display$spoligotype <- paste0("s", spol_lin_levels_table_display$spoligotype)

names(spol_lin_levels_table_display) <- c("Level",
                                          "Lineage",
                                          "Spoligotype",
                                          "SIT",
                                          "Family",
                                          "Proportion in lin.",
                                          "n in lineage",
                                          "% of lin")

write.csv(spol_lin_levels_table_display, 
          file = "../results/spol_lin_levels_table_supp.csv", 
          quote = F, row.names = F)

# spol_lin_levels_table$Level <- ifelse(is.na(spol_lin_levels_table$Level), "", spol_lin_levels_table$Level)

```

```{r basic-numbers-before-filter, echo = F, warning=F, message=F}

n_total_samps_before_filter <- length(spol_data$sample)
n_unique_lins_before_filter <- length(unique(spol_data$lineage))
n_unique_spol_before_filter <- length(unique(spol_data$spoligotype))

```

<!-- FILTER! FILTER! FILTER! FILTER! FILTER! -->
```{r filter-spol-five-samps, echo = F, warning=F}

# Make a copy first
spol_data_unfilt <- spol_data

# Keep only those with 5 or more samples per spoligotype
spol_data <- spol_data %>% group_by(spoligotype) %>% filter(n() > 4) %>% data.frame()

```
<!-- FILTER! FILTER! FILTER! FILTER! FILTER! -->

```{r basic-numbers-after-filter, echo = F, warning=F, message=F}

n_total_samps_after_filter <- length(spol_data$sample)
n_unique_lins_after_filter <- length(unique(spol_data$lineage))
n_unique_spol_after_filter <- length(unique(spol_data$spoligotype))

```

```{r geo, echo = F, warning=F, message=F}

# Merge in WHO regions
# metadata <- merge(metadata,
#                   select(regions_lookup, country_code_lower, WHO_region),
#                   by.x = "country_code",
#                   by.y = "country_code_lower",
#                   all.x = T,
#                   sort = F)

# Add unknown
# metadata$WHO_region <- ifelse(is.na(metadata$WHO_region), "Unknown", metadata$WHO_region)

# Merge metadata to spol family data
# geo_df <- select(metadata, wgs_id, country_code, country, region, subregion, WHO_region)
# lin_fam_geo_df <- merge(lin_fam_merged, geo_df,
#                         by.x = "sample", by.y = "wgs_id", all.x = T, sort = F)

# Make table of region and spol family
# region_family_tab <- as.data.frame.matrix(table(lin_fam_geo_df$subregion, lin_fam_geo_df$family_group))
# region_family_tab <- as.data.frame.matrix(table(lin_fam_geo_df$family, lin_fam_geo_df$WHO_region))C
# region_family_tab <- cbind(Region = row.names(region_family_tab), region_family_tab)

# CORRECT - Using spol_data
region_family_tab <- as.data.frame.matrix(table(spol_data$family, spol_data$WHO_region))
# CORRECT - Using spol_data

# # Get geo numbers
n_samps_geo <- data.frame(as.list(sort(colSums(region_family_tab), decreasing = T) ))
# 
# # Take out rows with < 10 
# region_family_tab <- region_family_tab[rowSums(region_family_tab) >= 10, ]
# 
# # Wrangle for plot
# # Normalise across col
# region_family_tab <- cbind(Family = row.names(region_family_tab), 
#       data.frame(apply(num_cols(region_family_tab), 2, function(x) {round(x/sum(x), 3)})))
# 
# # Clean - re-arrange unknown
# unknown_row <- subset(region_family_tab, Family == "Unknown")
# region_family_tab <- subset(region_family_tab, !(Family == "Unknown"))
# region_family_tab <- rbind(region_family_tab, unknown_row)
# 
# # Rename
# region_family_tab <- dplyr::rename(region_family_tab, 
#                                    E.Med. = Eastern.Mediterranean, 
#                                    S.E.Asia = South.East.Asia, 
#                                    W.Pacific = Western.Pacific)

# # Make long format for heatmap
# region_family_tab_plot <- region_family_tab %>% gather(Region, value, -Family)
# 
# # Plot
# max_n <- round_any(max(region_family_tab_plot$value), 1000)
# leg_ticks <- c(0, 10, 100, 1000, 2000)
# leg_breaks <- replace_inf(log(leg_ticks))
# # region_family_plot <- ggplot(data = region_family_tab_plot, 
# #             aes(x = Family, y = Region, fill = log(value+1))) +
# 
# region_family_plot <- ggplot(data = region_family_tab_plot, 
#             aes(x = Region, y = Family, fill = value)) +
#   geom_tile()+
#   geom_text(aes(label = value), color = "white", size = 3)+ 
#   xlab("WHO region")+
#   scale_y_discrete(limits=rev)+
#   theme_bw()+
#   theme(axis.text.x = element_text(angle = 45, hjust = 1), 
#         panel.grid.major = element_blank(), 
#         panel.grid.minor = element_blank(), 
#         panel.background = element_blank())+
#   coord_fixed(ratio=0.2)
# 
# region_family_plot_file <- paste0(results_path, "region_family_plot.png")
# ggsave(plot = region_family_plot, 
#        file = region_family_plot_file, 
#        width = 1500/7, height = 1000/5, units = "mm")

```

```{r table-1-cut, echo = F, warning=F, message=F}

# spol_pivot_lv1 <- reshape2::dcast(spol_data, lin_level_1 ~ 'n_spol', 
#                                   value.var = "spoligotype", fun.aggregate = len_uniq)
# 
# n_pivot_lv2 <- reshape2::dcast(spol_data, lin_level_2 ~ 'n_samp', 
#                                value.var = "sample", fun.aggregate = len_uniq)
# spol_pivot_lv2 <- reshape2::dcast(spol_data, lin_level_2 ~ 'n_spol', 
#                                   value.var = "spoligotype", fun.aggregate = len_uniq)
# 
# table_1_lv1 <- data.frame(cbind(to_table(n_pivot_lv1, "col"), to_table(spol_pivot_lv1, "col")))
# table_1_lv1 <- dplyr::select(table_1_lv1, -(lin_level_1.1),  -(Total), -(Total.1))
# table_1_lv1 <- data.frame(cbind(level = rep("1", nrow(table_1_lv1)), table_1_lv1))
# 
# table_1_lv2 <- data.frame(cbind(to_table(n_pivot_lv2, "col"), to_table(spol_pivot_lv2, "col")))
# table_1_lv2 <- dplyr::select(table_1_lv2, -(lin_level_2.1),  -(Total), -(Total.1))
# table_1_lv2 <- data.frame(cbind(level = rep("2", nrow(table_1_lv2)), table_1_lv2))
# 
# table_1 <- rbind_force(table_1_lv1, table_1_lv2)

```

<!-- OLD? -->
```{r spol-lin-results, echo = F, warning=F, message=F}

# Split out by lin level
spol_lin_levels_table_split <- split(spol_lin_levels_table, spol_lin_levels_table$level)

# Make lists to store stats for each level
pure_n_list <- list() # N spols pure at each level
pure_pc_list <- list() # Overall % of spols pure at each level
med_pc_samps_pure_list <- list() # Take the median of this vector

for(level in names(spol_lin_levels_table_split)){
  
  # Table of all the spoligotypes, pure and unpure
  all_spols_at_level <- spol_lin_levels_table_split[[level]]
  
  # Subset the pure ones
  pure <- subset(all_spols_at_level, prob == 1)
  
  # Add 'lv' to make it easier to subset lists later
  new_lv_name <- paste0("lv", level)
  
  # N spols pure at a level
  pure_n_list[[new_lv_name]] <- length(pure$spoligotype)
  # What % of all the spols at the level are pure?
  pure_pc_list[[new_lv_name]] <- (pure_n_list[[new_lv_name]]/length(all_spols_at_level$spoligotype))*100
  
  # Save the median of this value
  med_pc_samps_pure_list[[new_lv_name]] <- round(median(pure$col_prob), 2)
  
}

```

<!-- TABLES -->
```{r table-1, echo = F, warning=F, message=F}

# Lineage (lv1)

# How many samples in L1, L2, L3 etc.. 
n_pivot_lv1 <- reshape2::dcast(spol_data_unfilt, lin_level_1 ~ 'n_samp', 
                               value.var = "sample", fun.aggregate = len_uniq)
# How many sublins in L1, L2, L3 etc..
mem_pivot_lv1 <- reshape2::dcast(spol_data_unfilt, lin_level_1 ~ 'n_mem', 
                               value.var = "lineage", fun.aggregate = len_uniq)
# Merge
lin_lv1_pivot <- merge(mem_pivot_lv1, n_pivot_lv1, by = "lin_level_1", all.x = T, sort = F)
# Add % of samples 
lin_lv1_pivot$pc <- round(lin_lv1_pivot$n_samp/(sum(lin_lv1_pivot$n_samp))*100, 1)


# Spol family

# How many samples per main spol family
n_pivot_fam <- reshape2::dcast(spol_data_unfilt, family_group ~ 'n_samp', 
                               value.var = "sample", fun.aggregate = len_uniq)

# Aggregate "other"
n_pivot_fam_other <- subset(n_pivot_fam, n_samp < 297)
other_df <- data.frame(family_group = "Other", n_samp = sum(n_pivot_fam_other$n_samp))
n_pivot_fam <- subset(n_pivot_fam, n_samp >= 297)
n_pivot_fam <- n_pivot_fam %>% arrange(desc(n_samp))
n_pivot_fam <- rbind(n_pivot_fam, other_df)

# How many spols in each spol fam?
mem_pivot_fam <- reshape2::dcast(spol_data_unfilt, family_group ~ 'n_mem', 
                                 value.var = "spoligotype", fun.aggregate = len_uniq)
# Aggregate "other"
# Make sure same rows as above
mem_pivot_fam_other <- subset(mem_pivot_fam, 
                              mem_pivot_fam$family_group %in% n_pivot_fam_other$family_group)
other_df <- data.frame(family_group = "Other", n_mem = sum(mem_pivot_fam_other$n_mem))
mem_pivot_fam <- subset(mem_pivot_fam, 
                        !(mem_pivot_fam$family_group %in% n_pivot_fam_other$family_group))
mem_pivot_fam <- rbind(mem_pivot_fam, other_df)
# Merge clean and add pc col
fam_pivot <- merge(n_pivot_fam, mem_pivot_fam, by = "family_group", sort = F)
fam_pivot <- dplyr::select(fam_pivot,family_group, n_mem, n_samp)
fam_pivot$pc <- round(fam_pivot$n_samp/sum(fam_pivot$n_samp)*100, 1)

# WHO region

# Subset metadata to those in the spol data
# who <- subset(metadata, metadata$wgs_id %in% spol_data_unfilt$sample)

# How many samples per WHO region?
n_pivot_who <- reshape2::dcast(spol_data_unfilt, WHO_region ~ 'n_samp', 
                               value.var = "sample", fun.aggregate = len_uniq)

# How many countries per WHO region?
mem_pivot_who <- reshape2::dcast(spol_data, WHO_region ~ 'n_mem', 
                                 value.var = "country_code", fun.aggregate = len_uniq)

# Merge clean and add pc col
who_pivot <- merge(mem_pivot_who, n_pivot_who, by = "WHO_region")
who_pivot <- who_pivot %>% arrange(desc(n_samp))
who_pivot$pc <- round(who_pivot$n_samp/sum(who_pivot$n_samp)*100, 1)

# Put together

# lin_lv1_pivot
# fam_pivot
# who_pivot

table_1 <- rbind_force(lin_lv1_pivot, rbind_force(fam_pivot, who_pivot))
table_1 <- cbind(Characteristic = c(rep("Lineage", nrow(lin_lv1_pivot)), 
                                    rep("Spoligotype", nrow(fam_pivot)), 
                                    rep("WHO region", nrow(who_pivot))), 
                 table_1)

# Make copy for display
table_1_display <- table_1

# Clean
table_1_display <- rm_dup_group(table_1_display, "Characteristic")
table_1_display <- fmt(table_1_display)
names(table_1_display) <- c("Characteristic", 
                            "", 
                            "[# members]*", 
                            "N", 
                            "%")

```

```{r table-2, echo = F, warning=F, message=F}

# Table 2
# Numbers of samples and unique spoligotypes for sub-lineages* across 27,933 M. tuberculosis

# NB USE FILTERED DATASET - spol_data

n_pivot_lv1 <- reshape2::dcast(spol_data, lin_level_1 ~ 'n_samp', 
                               value.var = "sample", fun.aggregate = len_uniq)

spol_pivot_lv1 <- reshape2::dcast(spol_data, lin_level_1 ~ 'n_spol',
                                  value.var = "spoligotype", fun.aggregate = len_uniq)

fam_pivot_lv1 <- reshape2::dcast(spol_data, lin_level_1 ~ 'n_fam',
                                  value.var = "family", fun.aggregate = len_uniq)

n_pivot_lv1 <- add_pc_brkt(n_pivot_lv1, "n_samp")
spol_pivot_lv1 <- add_pc_brkt(spol_pivot_lv1, "n_spol")
fam_pivot_lv1 <- add_pc_brkt(fam_pivot_lv1, "n_fam")

lv1_df <- data.frame(cbind(lineage = n_pivot_lv1$lin_level_1,
                           sublineage = rep("Overall", nrow(n_pivot_lv1)), 
                           n_samp = n_pivot_lv1$n_samp, 
                           n_spol = spol_pivot_lv1$n_spol, 
                           n_fam = fam_pivot_lv1$n_fam))


# Level 2
n_pivot_lv2 <- reshape2::dcast(spol_data, lin_level_1 + lin_level_2 ~ 'n_samp', 
                                   value.var = "sample", fun.aggregate = len_uniq)

spol_pivot_lv2 <- reshape2::dcast(spol_data, lin_level_1 + lin_level_2 ~ 'n_spol', 
                                   value.var = "spoligotype", fun.aggregate = len_uniq)

fam_pivot_lv2 <- reshape2::dcast(spol_data, lin_level_1 + lin_level_2 ~ 'n_fam', 
                                   value.var = "family", fun.aggregate = len_uniq)

n_pivot_lv2 <- add_pc_brkt(n_pivot_lv2, "n_samp")
spol_pivot_lv2 <- add_pc_brkt(spol_pivot_lv2, "n_spol")
fam_pivot_lv2 <- add_pc_brkt(fam_pivot_lv2, "n_fam")

lv2_df <- data.frame(cbind(lineage = n_pivot_lv2$lin_level_1,
                          sublineage = n_pivot_lv2$lin_level_2, 
                          n_samp = n_pivot_lv2$n_samp, 
                          n_spol = spol_pivot_lv2$n_spol, 
                          n_fam = fam_pivot_lv2$n_fam))

# Split and r-bind the two tables
lv1_df_split <- split(lv1_df, lv1_df$lineage)
lv2_df_split <- split(lv2_df, lv2_df$lineage)

for(i in seq(length(lv1_df_split))){
  lv2 <- lv2_df_split[[i]]
  if(nrow(lv2) > 1){
    lv2_df_split[[i]] <- rbind(lv1_df_split[[i]], lv2)
  }else{
    lv2_df_split[[i]] <- lv1_df_split[[i]]
  }
}
# Put back together
lv1_lv2_n_spol_fam <- do.call("rbind", lv2_df_split)

# Clean
lv1_lv2_n_spol_fam <- rm_dup_group(lv1_lv2_n_spol_fam, "lineage")
names(lv1_lv2_n_spol_fam) <- c("Lineage", 
                               "Sub-lineage", 
                               "N (%)", 
                               "No. spoligotypes (%)\\*", 
                               "No. families (%)")

```

<!-- S1 -->
```{r rare-spols-table, echo = F, warning=F, message=F}

# Get the ones that aren't in the filtered df
rare_spol_df <- subset(spol_data_unfilt, !(spol_data_unfilt$sample %in% spol_data$sample))
rare_spol_df <- select(rare_spol_df, sample, spoligotype, lineage, family, SIT)
# Pivot
rare_spol_df <- reshape2::dcast(rare_spol_df, spoligotype+lineage+family+SIT ~ 'n', 
                value.var = "sample", fun.aggregate = len_uniq)

# Mark dups
dups <- all_dups(rare_spol_df, "spoligotype")
rare_spol_df$dup <- ifelse(rare_spol_df$spoligotype %in% unique(dups$spoligotype), "*", "")

# Clean
rare_spol_df <- rare_spol_df %>% arrange(spoligotype)                 
rare_spol_df$spoligotype <- paste0("s", rare_spol_df$spoligotype)
names(rare_spol_df) <- c("Spoligotype", "Lineage", "Family", "SIT", "N", ">1 lineage")

rare_spols_table_file <- "../results/rare_spol.csv"
write.csv(rare_spol_df, file = rare_spols_table_file, quote = F, row.names = F)

```

<!-- S2 TABLE-->
```{r s-2, echo = F, warning=F, message=F}

# Supplementary table 2
# "Table of spoligotypes (within families), N samples, N sublineages; main sub-lineages % (<5% other); WHO region %; F statistic of heterogeneity….?? [AT LOWEST LEVEL]"

# Spol Family	N samples	N sublineages	Main sublineages (%)	Africa	Europe	Americas	Corr.
# 0..1 X	    1000	2 (1.1,1.2)	1.1 (70), 2.1 (35), 3.1.1 (10)	10% of samples within Africa are this			

# Keep only spols with at least 5 samps
# lin_fam_geo_df_filt <- lin_fam_geo_df %>% group_by(spoligotype) %>% filter(n() > 4) %>% data.frame()

lv4 <- subset(spol_lin_levels_table, level == "4")

# Family (from SIT) and number of samples
# spol_fam_n <- reshape2::dcast(lin_fam_geo_df, spoligotype + family ~ 'n', 
#                  value.var = 'sample', fun.aggregate = len_uniq)
# spol_fam_n <- reshape2::dcast(spol_data, spoligotype + family ~ 'n', 
#                  value.var = 'sample', fun.aggregate = len_uniq)
fam_n <- reshape2::dcast(spol_data, family_group + family ~ 'n', 
                 value.var = 'sample', fun.aggregate = len_uniq)
# Subset to ones with at least 5 samps
# spol_fam_n <- subset(spol_fam_n, n >= 5)

# Number of sublins spol is in
# spol_n_sublin <- reshape2::dcast(lv4, spoligotype ~ 'n_sublin', 
#                                  value.var = 'lineage', fun.aggregate = len_uniq)
fam_n_sublin <- reshape2::dcast(lv4, family ~ 'n_sublin', 
                                 value.var = 'lineage', fun.aggregate = len_uniq)

# 'Main' (>5%) sublins
# lv4_split <-  split(lv4, lv4$spoligotype)
lv4_split <-  split(lv4, lv4$family)
main_sublins <- lapply(lv4_split, function(x){
  x <- x[order(-x$freq), ]
  pcs <- x$freq/sum(x$freq)
  which_pcs_gr_5 <- which(pcs >= 0.05)
  pcs_gr_5 <- round(pcs[which_pcs_gr_5]*100, 1)
  lins_gr_5 <- x[which_pcs_gr_5, "lineage"]
  lins_pcs <- paste0(lins_gr_5, " (", pcs_gr_5, ")", collapse = "; ")
  # data.frame(spoligotype = unique(x$spoligotype), 
  #                  main_sublins = lins_pcs)
  data.frame(family = unique(x$family), 
                   main_sublins = lins_pcs)
})
main_sublins <- do.call("rbind", main_sublins)

# WHO regions
# who_tab <- as.data.frame.matrix(table(lin_fam_geo_df$spoligotype, lin_fam_geo_df$WHO_region))
# who_tab <- as.data.frame.matrix(table(spol_data$spoligotype, spol_data$WHO_region))
who_tab <- as.data.frame.matrix(table(spol_data$family, spol_data$WHO_region))
# Subset to ones with at least 5 samps
# who_tab <- who_tab[row.names(who_tab) %in% spol_fam_n$spoligotype, ]
# Get percent per col (region)
who_tab <- apply(who_tab, 2, function(x){
  round((x/sum(x))*100, 2)
  })
# Add spol as col
# who_tab <- data.frame(cbind(spoligotype = row.names(who_tab), who_tab))
who_tab <- data.frame(cbind(family = row.names(who_tab), who_tab))
# Drop unknown
who_tab <- select(who_tab, -Unknown)
# Clean
names(who_tab) <- c("family", "Africa", "Americas", "E.Med.", "Europe", "S.E.Asia", "W.Pacific")

# Correlation metric

# corr_df <- lapply(lv4_split, function(x){
#   max_samps_row <- which.max(x$freq)
#   x[max_samps_row, c("spoligotype", "prob")]
# })
# corr_df <- do.call("rbind", corr_df)


# PUT TOGETHER

cols_1_to_4 <- merge(fam_n, fam_n_sublin, 
                     by = "family", all.x = T, sort = F)

cols_1_to_5 <- merge(cols_1_to_4, main_sublins, 
                     by = "family", all.x = T, sort = F)

s2 <- merge(cols_1_to_5, who_tab, 
                       by = "family", all.x = T, sort = F)

# s2 <- merge(cols_1_to_who, corr_df, 
#                        by = "spoligotype", all.x = T, sort = F)

# Clean
s2 <- select(s2, family_group, everything())
# s2 <- s2 %>% arrange(spoligotype)
# s2 <- s2 %>% arrange(family)
# s2$spoligotype <- paste0("s", s2$spoligotype)
# s2 <- dplyr::rename(s2, Spoligotype = spoligotype, 
#              Family = family, 
#              "N samples" = n, 
#              "N sublineages" = n_sublin,
#              "Main sublineages (%)" = main_sublins,
#              "Correlation metric" = prob)
s2 <- dplyr::rename(s2, "Family group" = family_group, 
             Family = family, 
             "N samples" = n, 
             "N sublineages" = n_sublin,
             "Main sublineages (%)" = main_sublins)

s2_table_file <- "../results/s2_table.csv"
write.csv(s2, file = s2_table_file, quote = F, row.names = F)

```

<!-- S3 TABLE -->
```{r main-lin-family-group, echo = F, warning=F, message=F}

# What is the correspondence between main lin and the (main) spol families?

# Clean
# family_lookup <- subset(family_lookup, !(family == "Zero-copy"))

# # Merge lineage into family lookup table and pull unique main lineage and family group
# lin_fam <- select(spol_data, spoligotype, sample, lineage, family)
# lin_fam_merged <- merge(lin_fam, family_lookup, by = "family", all.x = T, sort = F)
# lin_fam_merged$main_lin <- substr(lin_fam_merged$lineage, 1, 1)
# lin_fam_merged$main_lin <- ifelse(grepl("La", lin_fam_merged$lineage), "La", lin_fam_merged$main_lin)
# 
# manu <- subset(lin_fam_merged, family_group == "Manu")
# manu_spol <- merge(manu, select(spol_data, sample, spoligotype), by = "sample")
# write.csv(manu_spol, "../results/manu_spol.csv", row.names = F, quote = F)

# Find the anomalous main lin-family groups - ones with just a few samples
# e.g. some L1 samps are AFRI, which is clearly not correct
# lin_fam_freq_tab <- as.data.frame.matrix(table(lin_fam_merged$family_group, lin_fam_merged$main_lin))
lin_fam_freq_tab <- as.data.frame.matrix(table(spol_data$family_group, spol_data$lin_level_1))

# Get numbers for spol families
n_samps_family <- data.frame(as.list(sort(rowSums(lin_fam_freq_tab), decreasing = T)))

# Clean and add totals for display
lin_fam_freq_tab <- cbind(Family = row.names(lin_fam_freq_tab), lin_fam_freq_tab)
lin_fam_freq_tab <- adorn_totals(lin_fam_freq_tab, where = c("row", "col"))

# # Make a table of the 'proper' correspondence between main lin and family group, 
# # taking out the anomalous ones from the freq table
# main_lin_family_group <- unique(select(lin_fam_merged, main_lin, family_group))
# main_lin_family_group <- subset(main_lin_family_group, !is.na(family_group))
# main_lin_family_group <- subset(main_lin_family_group, !(family_group == "Unknown"))
# main_lin_family_group <- odr(main_lin_family_group)
# 
# main_lin_family_group <- subset(main_lin_family_group, !(main_lin == "1" & family_group == "AFRI"))
# main_lin_family_group <- subset(main_lin_family_group, !(main_lin == "4" & family_group == "AFRI"))
# main_lin_family_group <- subset(main_lin_family_group, !(main_lin == "1" & family_group == "Beijing"))
# main_lin_family_group <- subset(main_lin_family_group, !(main_lin == "3" & family_group == "Beijing"))
# main_lin_family_group <- subset(main_lin_family_group, !(main_lin == "5" & family_group == "Beijing"))
# main_lin_family_group <- subset(main_lin_family_group, !(main_lin == "3" & family_group == "BOV"))
# main_lin_family_group <- subset(main_lin_family_group, !(main_lin == "1" & family_group == "CAS"))
# main_lin_family_group <- subset(main_lin_family_group, !(main_lin == "2" & family_group == "CAS"))
# main_lin_family_group <- subset(main_lin_family_group, !(main_lin == "4" & family_group == "CAS"))
# main_lin_family_group <- subset(main_lin_family_group, !(main_lin == "5" & family_group == "CAS"))
# main_lin_family_group <- subset(main_lin_family_group, !(main_lin == "4" & family_group == "EAI"))
# main_lin_family_group <- subset(main_lin_family_group, !(main_lin == "1" & family_group == "PINI2"))
# main_lin_family_group <- subset(main_lin_family_group, !(main_lin == "4" & family_group == "PINI2"))
# main_lin_family_group <- subset(main_lin_family_group, !(main_lin == "3" & family_group == "T"))
# 
# main_lin_family_group <- rm_dup_group(main_lin_family_group, "main_lin")
# 
# names(main_lin_family_group) <- c("Main lineage", "Spoligotype family group")

```

<!-- S4 TABLE -->
```{r lowest-lvl-spol-split, echo = F, warning=F, message=F}

# Find spoligotypes which offer greater resolution to the lowest lineage 
# In other words find at least two spols associated with a (lowest level) lin (after filters)

# Take lowest level
lv4 <- spol_lin_levels_split$`4`

# Split by lin
lv4_split <- split(lv4, lv4$lineage)

# Filter to those spols accounting for >= 20% of samples and >= 20 samples in that lin 
# and a prob score >=0.50
lv4_split_filt <- lapply(lv4_split, function(x){
  subset(x, freq >= 20 & col_prob >= 20 & prob >= 0.5)
})
# Then remove the remaining lins where there is only one spol left 
# (need at least 2 to give more resolution to the lowest level)
lv4_split_filt <- lv4_split_filt[unlist(lapply(lv4_split_filt, nrow)) >= 2]
lv4_filt <- do.call("rbind", lv4_split_filt)

# Make copy for display
lv4_filt_display <- lv4_filt

# Add "s" before writing to csv
lv4_filt_display$spoligotype <- paste0("s", lv4_filt_display$spoligotype)

names(lv4_filt_display) <- c("Level", "Lineage", "Spoligotype", "SIT", "Family",
                     "Proportion in lin.", "n in lineage", "% of lin")

write.csv(lv4_filt_display, file = "../results/lv4_filt.csv", row.names = F, quote = F)

```


<!-- FIGURES -->

<!-- OLD -->
```{r spol-lin-results-plot, echo = F, warning=F, message=F}

# spol_lin_levels_table$col_prob_log10 <- log10(spol_lin_levels_table$col_prob)
# spol_lin_levels_table$col_prob_log10 <- ifelse(is.infinite(spol_lin_levels_table$col_prob_log10), 
#                                                min(spol_lin_levels_table$col_prob_log10[!is.infinite(spol_lin_levels_table$col_prob_log10)]),
#                                                spol_lin_levels_table$col_prob_log10)
# 
# pure_pc_df <- list_to_df_group(pure_pc_list)
# pure_pc_df$group <- 1:4
# 
# y_A <- seq(0, 2, 0.5)
# y_B <- seq(0, 10, 2) 
# y_C <- seq(20, 50, 10) 
# y_D <- seq(60, 100, 20)
# y_ax <- c(y_A, y_B, y_C, y_D)
# spol_lin_results_plot <- ggplot()+
#   geom_boxplot(data = spol_lin_levels_table, aes(x = as.factor(level), y = col_prob))+
#   geom_line(data = pure_pc_df, aes(x=group, y=values, group=1), color="red", size = 1)+
#   geom_point(data = pure_pc_df, aes(x=group, y=values), size = 3, colour = "blue")+
#   xlab("Lineage level")+
#   ylab("Percentage")+
#   scale_y_log10(breaks = y_ax)+
#   theme_bw()
# spol_lin_results_plot_file <- "../results/spol_lin_results_plot.png"
# 
# ggsave(file = spol_lin_results_plot_file, plot = spol_lin_results_plot, width = 1100/5, height = 700/5, units = "mm")

```
<!-- OLD -->
```{r level-prob-hist, echo = F, warning=F, message=F}

# spol_lin_levels_table$main_lin <- substr(spol_lin_levels_table$lineage, 1, 1)
# 
# spol_lin_levels_table$main_lin <- ifelse(spol_lin_levels_table$main_lin == "L", "La", 
#                                          spol_lin_levels_table$main_lin)
# 
# spol_lin_levels_table <- spol_lin_levels_table %>% 
#   mutate(prob_group = case_when(prob == 1 ~ '1',
#                                 prob < 1 & prob >= 0.9 ~ '0.9-0.99',
#                                 prob < 0.9 & prob >= 0.8 ~ '0.8-0.89', 
#                                 prob < 0.8 & prob >= 0.7 ~ '0.7-0.79', 
#                                 prob < 0.7 & prob >= 0.6 ~ '0.6-0.69', 
#                                 prob < 0.6 & prob >= 0.5 ~ '0.5-0.59', 
#                                 prob < 0.5 & prob >= 0.4 ~ '0.4-0.49', 
#                                 prob < 0.4 & prob >= 0.3 ~ '0.3-0.39', 
#                                 prob < 0.3 & prob >= 0.2 ~ '0.2-0.29', 
#                                 prob < 0.2 & prob >= 0.1 ~ '0.1-0.19', 
#                                 prob < 0.1 & prob >= 0 ~ '0-0.09'))
# 
# prob_group_pivot <- reshape2::dcast(data = spol_lin_levels_table, prob_group ~ level)
# prob_group_pivot <- prob_group_pivot[rev(1:nrow(prob_group_pivot)), ]
# 
# 
# level_prob_hist <- ggplot(spol_lin_levels_table, aes(x = prob, fill = main_lin))+
#   geom_histogram(bins = 11, colour = "black", lwd=0.1)+
#   scale_x_continuous(breaks = seq(0, 1, 0.1))+
#   labs(fill = "Lineage")+
#   xlab("Correlation score")+
#   facet_wrap( ~ level)+
#   theme_bw()

# level_prob_hist <- ggplot(spol_lin_levels_table, aes(x = prob_group, fill = main_lin))+
#   geom_histogram(bins = 11, colour = "black", lwd=0.1, stat = "count")+
#   # scale_x_continuous(breaks = seq(0, 1, 0.1))+
#   # scale_x_discrete(breaks = seq(0, 1, 0.1))+
#   labs(fill = "Lineage")+
#   xlab("Correlation score")+
#   facet_wrap( ~ level)+
#   theme_bw()+
#   theme(axis.text.x = element_text(angle=45, hjust = 1))

# level_prob_hist_file <- "../results/level_prob_hist.png"
# ggsave(plot = level_prob_hist, file = level_prob_hist_file, 
#        width = 1100/6, height = 700/6, units = "mm")

```

<!-- FIGURE 1 -->
```{r fam-lin-bar, echo = F, warning=F, message=F}

# Barplot - x = Family, y = n samps, col = main lin, number on top

fam_lin_n <- reshape2::dcast(spol_data, family_group + lin_level_1 ~ 'n', 
                      value.var = "sample", fun.aggregate = len_uniq)

fam_n <- reshape2::dcast(spol_data, family_group ~ 'n', 
                      value.var = "sample", fun.aggregate = len_uniq)

y_ticks <- c(0, seq(500, max(fam_lin_n$n), 500))

fam_lin_n_bar <- ggplot()+
  geom_bar(data = fam_lin_n, aes(x = family_group, y = n, fill = lin_level_1), 
           stat = "identity", width=0.7, colour = "black", size = 0.2)+
  xlab("Family")+
  ylab("N")+
  geom_text(data = fam_n, aes(x = family_group, y = n, label = n), vjust=-0.3, size=3.5)+
  scale_y_continuous(breaks = y_ticks)+
  theme_bw()+
  theme(axis.text.x = element_text(angle = 45, hjust = 1))+
  guides(fill=guide_legend(title="Lineage"))

fam_lin_n_bar_file <- "../results/fam_lin_n_bar.png"
ggsave(plot = fam_lin_n_bar, file = fam_lin_n_bar_file, 
       width = 1100/6, height = 700/6, units = "mm")

# lv4 <- merge(lv4, select(family_lookup, family, family_group), 
#              by = "family", all.x = T, sort = F)
# 
# fam_lin_cnt <- reshape2::dcast(lv4, family_group ~ 'n_lins', 
#                                   value.var = 'lineage', fun.aggregate = len_uniq)
# 
# y_ticks <- c(0, seq(5, max(fam_lin_cnt$n_lins), 5))
# 
# fam_n_lins_bar <- ggplot(data = fam_lin_cnt, aes(x = family_group, y = n_lins))+
#   geom_bar(stat = "identity", width=0.7, fill="steelblue")+
#   xlab("Family")+
#   ylab("N lineages")+
#   scale_y_continuous(breaks = y_ticks)+
#   theme_bw()+
#   theme(axis.text.x = element_text(angle = 45, hjust = 1))
# 
# fam_n_lins_bar_file <- "../results/fam_n_lins_bar.png"
# ggsave(plot = fam_n_lins_bar, file = fam_n_lins_bar_file, 
#        width = 1100/6, height = 700/6, units = "mm")

```

```{r fam-who-bar, echo = F, warning=F, message=F}

# WHO barplot - x = Family, y = n samps, col = WHO regions

# Spols with at least 5 samples 
# fam_who <- subset(lin_fam_geo_df, lin_fam_geo_df$spoligotype %in% lv4$spoligotype)
# Remove unknown WHO
# fam_who <- subset(fam_who, !(WHO_region == "Unknown"))

fam_who <- reshape2::dcast(spol_data, family_group + WHO_region ~ 'n', 
                           value.var = "sample", fun.aggregate = len_uniq)

# fam_who_bar <- ggplot(data = fam_who, aes(x = family_group, y = n))+
#   geom_bar(stat = "identity", width=0.7, fill = WHO_region)+
#   xlab("Family")+
#   ylab("N WHO regions")+
#   scale_y_continuous(breaks = y_ticks)+
#   theme_bw()+
#   theme(axis.text.x = element_text(angle = 45, hjust = 1))

fam_who_n_bar <- ggplot()+
  geom_bar(data = fam_who, aes(x = family_group, y = n, fill = WHO_region), 
           stat = "identity", width=0.7, colour = "black", size = 0.2)+
  xlab("Family")+
  ylab("N")+
  geom_text(data = fam_n, aes(x = family_group, y = n, label = n), vjust=-0.3, size=3.5)+
  scale_y_continuous(breaks = y_ticks)+
  theme_bw()+
  theme(axis.text.x = element_text(angle = 45, hjust = 1))+
  guides(fill=guide_legend(title="WHO region"))

fam_who_n_bar_file <- "../results/fam_who_bar.png"
ggsave(plot = fam_who_n_bar, file = fam_who_n_bar_file, 
       width = 1100/6, height = 700/6, units = "mm")

```

<!-- FIGURE 2 - LOAD IN FIGURES DISPLAY BLOCK - TREES -->

<!-- S1 FIGURE -->
```{r spol-freq-hist, echo = F, warning=F, message=F}

spol_freqs <- as.data.frame.matrix(table(spol_lin_levels_table$spoligotype,
                           spol_lin_levels_table$level)) %>% gather()

spol_freq_hist <- ggplot(gather(spol_freqs), aes(value))+
  geom_histogram(bins = 11)+
  xlab("Frequency of spoligotypes")+
  facet_wrap(~key)+
  theme_bw()

spol_freq_hist_file <- "../results/spol_freq_hist.png"
ggsave(plot = spol_freq_hist, file = spol_freq_hist_file,
       width = 1100/6, height = 700/6, units = "mm")

```

<!-- S2 FIGURE -->
```{r map, echo = F, warning=F, message=F}

# Family

# At least 5 samples
# fam_who <- subset(lin_fam_geo_df, lin_fam_geo_df$spoligotype %in% lv4$spoligotype)
# Remove unknown WHO
# fam_who <- subset(fam_who, !(WHO_region == "Unknown"))
# Make table of region and spol family
# region_family_tab <- as.data.frame.matrix(table(lin_fam_geo_df$subregion, lin_fam_geo_df$family_group))
# region_family_tab <- as.data.frame.matrix(table(fam_who$WHO_region, fam_who$family_group))
region_family_tab <- as.data.frame.matrix(table(spol_data$WHO_region, spol_data$family_group))
region_family_tab <- data.frame(cbind(WHO_region = row.names(region_family_tab), region_family_tab))
# Remove unknown
region_family_tab <- subset(region_family_tab, !(WHO_region == "Unknown"))

# Lineage
# who_lin <- as.data.frame.matrix(table(fam_who$WHO_region, fam_who$main_lin))
who_lin <- as.data.frame.matrix(table(spol_data$WHO_region, spol_data$lin_level_1))
who_lin <- cbind(WHO_region = row.names(who_lin), who_lin)

world <- map_data('world')
# Countries at centre of WHO regions
countries <- c("Democratic Republic of the Congo", "Nicaragua", "Iran", "Belarus", "Bangladesh", "Philippines")
who_country_df <- data.frame(WHO_region = region_family_tab$WHO_region, countries = countries)
# Get long lat 
world_sub <- unique(subset(world, region %in% countries))
# Get mean long lat for key countries
long_lat_means <- data.frame(world_sub %>% group_by(region) %>% summarise_at(vars(long, lat), list(mean)))
who_country_df <- merge(who_country_df, long_lat_means, 
                        by.x = "countries", by.y = "region", 
                        all.x = T, sort = F)

region_family_tab <- merge(who_country_df, region_family_tab, by = "WHO_region", all.x = T, sort = F)
region_family_tab <- merge(region_family_tab, who_lin, by = "WHO_region", all.x = T, sort = F)

fams <- sort(unique(spol_data$family_group))
lins <- sort(unique(spol_data$lin_level_1))

# fam_data <- select(region_family_tab, WHO_region, long, lat, AFRI:X)
# lin_data <- select(region_family_tab, WHO_region, long, lat, "1":La)

fam_cols <- c("#ff0000", "#fa8072", "#dda0dd", "#ff00ff", "#ff1493", "#ffa500", "#ffff00", "#f0e68c", "#006400", "#00ff00", "#00fa9a", "#00008b", "#0000ff", "#1e90ff", "#00ffff", "#2f4f4f")
lin_cols <- rainbow(length(lins), alpha = 1, s = 0.6, v = 1)

fam_map <- ggplot(world, aes(long, lat))+
    geom_map(map=world, aes(map_id=region), fill=NA, color="black", size = 0.1)+
    coord_quickmap()+
  geom_scatterpie(data = region_family_tab, aes(x = long, y = lat, r = 15), 
                    cols = fams, color = "black", size = 0.1, legend_name = "Family")+
  scale_fill_manual(values = fam_cols)

fam_map <- fam_map + ggnewscale::new_scale_fill()

fam_lin_map <- fam_map + 
  geom_scatterpie(data = region_family_tab, aes(x = long, y = lat, r = 10),
                   cols = lins, size = 0.1, legend_name = "Lineage")+
  scale_fill_manual(values = lin_cols)+
  theme_void()

fam_lin_map_file <- paste0(results_path, "fam_lin_map.png")
ggsave(plot = fam_lin_map, 
       file = fam_lin_map_file, 
       width = 1500/7, height = 1000/5, units = "mm")

```

```{r supp, echo = F, warning=F, message=F}

# TABLES

# Supplementary table 1
# List of infrequent spoligotypes (<5 samples)
rare_spols_table_s_number <- "1"

# Supplementary table 2
# Table of spoligotypes (within families), N samples, N sublineages; main sub-lineages % (<5% other); WHO region %; F statistic of heterogeneity….??
fam_table_s_number <- "2"

# Supplementary table 3
# Frequency table of samples by main lineage and spoligotype family
lin_fam_freq_tab_s_number <- "3"

# Supplementary table 4
# Spoligotypes discriminating lineages at the lowest level
lv4_filt_display_s_number <- "4"


# FIGURES

# Supplementary figure 1
# Distribution of the number of lineages and sub-lineages present for each spoligotype and spoligotype family. 
# Panel of 4 barplots 
# X-axis 1, 2, 3, 4, … y-axis freq
spol_freq_hist_s_number <- "1"

# Supplementary figure 2
# Global map of WHO regions
# 1.	Spoligotype family
# 2.	Lineage
map_figure_s_number <- "2"

# Supplementary figure 3
# Phylogenetic trees showing lineage or sub-lineage, family and spoligotypes.
trees_figures_s_number <- "3"




```


| | |
| ----------- | ----------- |
|Gary Napier^1^ |	gary.napier@lshtm.ac.uk|
|Susana Campino^1^ | susana.campino@lshtm.ac.uk|
|Jody Phelan^1^,^\*^ | jody.phelan@lshtm.ac.uk|
|Taane G. Clark^1,5,\*^ | taane.clark@lshtm.ac.uk|

1. Faculty of Infectious and Tropical Diseases, London School of Hygiene & Tropical Medicine, WC1E 7HT London, UK
2. Faculty of Epidemiology and Population Health, London School of Hygiene & Tropical Medicine, WC1E 7HT London, UK

\* joint authors

### Abstract

**Background:** Strain-types of *Mycobacterium tuberculosis*, the bacterial pathogen underlying tuberculosis disease (TB), have been associated with drug resistance, transmissibility, virulence, and host-pathogen interactions. Spoligotyping is an established genotyping technique, and historically used to describe strain-types globally. Advances in sequencing technologies have led to whole genome characterisation and determination of barcoding mutations for strain-types through a sub-lineage nomenclature. Given the large number of *M. tuberculosis*, there is a need to update the *in silico* profiling of spoligotypes, and link it to established sub-lineages. 

**Results:** 

Our software improves speed and accuracy of *in silico* spoligotyping predictions. Speed varies with coverage and input format (fastq, fasta, bam).
  
Although the geographical sources of our samples somewhat agreed with the phylogeographical spoligotype families, there were many exceptions, though this may be a reflection of sampling bias.  
    
We found that many spoligotypes were perfectly correlated with the main MTBC lineages as well as the second level of the hierarchical MTBC lineage clades. Conversely, many spoligotyopes that were less purely associated with lineages nevertheless appeared in a large proportion of those lineages. At lower levels of the lineage system there were fewer spoligotypes perfectly correlated with lineages and many spoligotypes found in many different lineages lineages. 

**Conclusions:** We present a faster more streamlined software for predicting spoligotypes *in silico* from WGS. Spoligotypes are usefully predictive of lineage at the first two hierarchical lineage levels, but nevertheless retain important phylogeographical information, leading to the recomendation that both systems should be used in tandem.

**URL:** https://tbdr.lshtm.ac.uk/; https://github.com/jodyphelan/TBProfiler

**Keywords:** *Mycobacterium tuberculosis*, spoligotypes, lineages, phylogeny, spolpred

### Background

Tuberculosis is an infectious disease of high global burden caused by members of the *Mycobacterium tuberculosis* complex (MTBC), which includes *M. tuberculosis sensu stricto* (*Mtb*), *M. africanum* and animal strains such as *M. bovis*. Though the MTBC is described as clonal, there is sufficient variation to distinguish strain-types within members of the complex. *Mtb* and *M. africanum* are phylogenetically classified in nine main lineages (L1-9), with strain types that are distributed phylo-geographically [@Napier2020].  Strain identification is crucial to addressing key epidemiological questions, from individual to global scales. Strain typing is informative in the investigation of transmission events, and in the wider context, provides valuable insight into the spread of MTBC variants, indicating potential differences in genotype-phenotype interaction. For example, Beijing strains show lineage-specific associations with drug resistance [@Oppong2019], and that the geographical ubiquity of lineages 2 (Beijing) and 4 (Euro-American-Indian) can be attributed to virulence and transmissibility [@Coscolla2014a]. Furthermore, strain typing at higher phylogenetic resolution can reveal within-strain differences, such as the typical and atypical Beijing strains varying in geographical distribution, resistance and virulence [@Forrellad2013][@Ribeiro2014]. Advances in sequencing technologies are leading high-resolution strain typing offered by whole genome sequencing (WGS), which improve transmission studies and enable the tracking of between- and within-lineage genotypic-phenotypic differences, as well as assisting with understanding drug resistance mechanisms.

Spoligotyping is a fingerprinting PCR technique [@Kamerbeek1997], which exploits the polymorphism harboured at the direct repeat (DR) locus of MTBC. It is based on the PCR amplification of 43 short unique sequences (termed spacers) contained between well-conserved 36-bp DRs and the subsequent hybridisation of the products onto a membrane with oligonucleotides complementary to each spacer. Since strains vary in the occurrence of spacers, each sample produces a distinctive spot pattern, which is then translated into a numerical code of 8 digits, leading to more than 3.8k spoligotypes. The spoligotyping nomenclature [@Brudey2006] reflects the phylogeographical structure of MTBC, and its main families overlap with the ~100 (sub-)lineage system [@Napier2020], with both of higher resolution than large deletion-based regions of difference (RD). However, the full extent of alignment of spoligotypes and sub-lineages needs to be established, leading to improvements in both spoligotyping and sub-lineage barcoding of strain-types using whole genome sequencing data. Previous work has *in silico* predicted spoligotypes, implemented within the widely applied SpolPred software [@Coll2012]. With a great number of *Mtb* WGS available, we seek to check consistency of spoligotypes with the sub-lineage system [@Napier2020], and assess their global distribution. This is achieved by developing new software ("Spolpred2") to *in silico* genotype isolates, which predicts the spoligotype from raw sequence reads. We incorporate the updated barcodes for spoligotypes and "Spolpred2" within the TB-Profiler tool [@Phelan2019], widely used to profile MTBC sub-lineages, strain-types, and drug resistance from WGS for clinical and surveillance applications.  

### Methods

**Spolpred2 algorithm**

The Spolpred2 spoligotype prediction tool is based on k-mer counting. KMC3 [@Kokot2017] is used to count kmers from either raw fastq, fasta, bam or cram format. A k-mer length equal to the length of the unique spacers (k=25) is chosen. For bam and cram files, aligment against the H37Rv reference genome (AL123456.3) [@Cole1998] is assumed and only reads falling between positions 3117003 and 3127206 are analysed. Custom Python code then loads the counts and performs a direct lookup of the spacers converted to their canonical form to extract the counts. Lookups are also performed for spacers with up to two mismatches. Presence or absence of a spacer is determined by comparing the counts against a minimum threshold. The threshold is selected to be 20% of the maximum spacer count. The presence/absence vector represents the binary spoligotype and is converted into an octal form. Finally, the associated family and SIT are reported by performing a lookup in a CSV file which currently contains data for all samples submitted to SITVIT2 [@SITVIT2]. The code was integrated into TB-Profiler (v4.3.0) [@Phelan2019] and can be invoked to perform spoligotyping only, or as part of the standard profiling pipeline which also reports drug resistance and SNP-based lineage. Using a standard laptop with 8 Gb ram, Spolpred2 can proflle from bam and fasta format files with 1000-fold coverage in <10 seconds, whilst perform the same task on raw fastq files with up to 500-fold coverage in <30 seconds.

**Association of spoligotypes to lineages**

Spoligotypes were inferred using Spolpred2 across `r n_total_samps_before_filter` MTBC samples with whole genome sequencing data, location, and drug resistance phenotypes. Lineages were inferred using TB-Profiler, which implements a published barcode [@Napier2020]. The number of lineages and sub-lineages within spoligotype families was estimated. XXXXXXX

**Global distribution of spoligotype families**

```{r family-numbers, echo = F, warning=F, message=F}

beijing_n <- fmt(n_samps_family$Beijing)
beijing_pc <- fmt_pc(n_samps_family$Beijing/n_total_samps_before_filter)

T_n <- fmt(n_samps_family$T)
T_pc <- fmt_pc(n_samps_family$T/n_total_samps_before_filter)

LAM_n <- fmt(n_samps_family$LAM)
LAM_pc <- fmt_pc(n_samps_family$LAM/n_total_samps_before_filter)

unknown_family_n <- fmt(n_samps_family$Unknown)
unknown_family_pc <- fmt_pc(n_samps_family$Unknown/n_total_samps_before_filter)

```

```{r geo-numbers, echo = F, warning=F, message=F}

# Subregions
# northern_europe_n <- fmt(n_samps_geo$Northern.Europe)
# northern_europe_pc <- fmt_pc(n_samps_geo$Northern.Europe/n_total_samps_before_filter)
# 
# southern_africa_n <- fmt(n_samps_geo$Southern.Africa)
# southern_africa_pc <- fmt_pc(n_samps_geo$Southern.Africa/n_total_samps_before_filter)
# 
# se_asia_n <- fmt(n_samps_geo$Southeast.Asia)
# se_asia_pc <- fmt_pc(n_samps_geo$Southeast.Asia/n_total_samps_before_filter)
# 
# unknown_geo_n <- fmt(n_samps_geo$Unknown)
# unknown_geo_pc <- fmt_pc(n_samps_geo$Unknown/n_total_samps_before_filter)

# WHO regions
n_europe <- fmt(n_samps_geo$Europe)
pc_europe <- fmt_pc(n_samps_geo$Europe/n_total_samps_before_filter)

n_africa <- fmt(n_samps_geo$Africa)
pc_africa <- fmt_pc(n_samps_geo$Africa/n_total_samps_before_filter)

n_w_pacific <- fmt(n_samps_geo$Western.Pacific)
pc_w_pacific <- fmt_pc(n_samps_geo$Western.Pacific/n_total_samps_before_filter)

unknown_geo_n <- fmt(n_samps_geo$Unknown)
unknown_geo_pc <- fmt_pc(n_samps_geo$Unknown/n_total_samps_before_filter)

```

Across XXXX *M. tuberculosis*,  spoligotypes, lineages and WHO region
Spoligotypes <5 removed…. What are they, part of large sub-lineages???

The most frequent spoligotype family in our data belongs to Beijing (`r beijing_n`; `r beijing_pc`), followed by T (`r T_n`; `r T_pc`) and LAM (`r LAM_n`; `r LAM_pc`), though many samples had an unknown family (`r unknown_family_n`; `r unknown_family_pc`) (**Figure \@ref(fig:fam-lin-bar-show)(a)**, **Table S`r lin_fam_freq_tab_s_number`**). The most common WHO geographical regions in which our samples are found were Europe (`r n_europe`; `r pc_europe`), Africa (`r n_africa`; `r pc_africa`) and Western Pacific (`r n_w_pacific`; `r pc_w_pacific`) (**Figure \@ref(fig:fam-lin-bar-show)(b)**, **Figure S`r map_figure_s_number`**). As with family, many samples were of unknown origin (`r unknown_geo_n`; `r unknown_geo_pc`). **Table S`r fam_table_s_number`** and **Figure S`r map_figure_s_number`** show the frequency of samples gathered in a WHO geographical region versus the spoligotype family. While many samples occur in their expected geographical region, there is much variation as to where in the world a spoligotype family is found. The discordance of geographical distribution with respect to spoligotype family in our data perhaps reflects samples being taken as part of transmission studies or other clinically relevant investigation.  

**Association of spoligotypes to lineages**

Before filtering the spoligotypes to those appearing in five or more samples, our data consisted of `r fmt(n_total_samps_before_filter)` samples, `r fmt(n_unique_lins_before_filter)` unique lineages and sublineages, and `r fmt(n_unique_spol_before_filter)` unique spoligotypes. This filtering step resulted in `r fmt(n_total_samps_after_filter)` samples, `r fmt(n_unique_lins_after_filter)` unique lineages and `r fmt(n_unique_spol_after_filter)` distinct spoligotypes. 

Many spoligotypes were found to be exclusive to lineages at each level (correlation score = 1), however in many cases they nevertheless appeared in a relatively small proportion of that lineage's total samples, for example spoligotype 1101111111111111111001111111000010111111111 is only found in lineage 1, but appears in only 17.2% of that lineage's total samples. Conversely, spoligotypes scoring less than 1 were found which in fact appeared in a large proportion of samples (spoligotype 0000000000000000000000000000000000111111111 scored 0.99 for association to lineage 2, but appears in 91.2% of its samples). Therefore, we include the number of samples with a given spoligotype as well as the percentage of the lineage's total samples in **Table SXXX**. 

For simplicity, our results in **Table SXXX** only show the top five most-closely associated spoligotypes for each lineage. These are ordered first by purity - i.e. the "Proportion in lineage score", then by percentage of samples in the lineage with this spoligotype (column "% of lineage"). The full table of results for the unfiltered spoligotypes can be found at github.com/GaryNapier/spolpred/blob/master/results/spol_lin_levels_table.csv

At the first lineage level (lineages 1-7), there were `r pure_n_list$lv1` (`r pc(pure_pc_list$lv1)`) spoligotypes appearing exclusively in their respective lineages, however the median percentage of samples with a pure spoligotype across all lineages 1-7 was very low at `r med_pc_samps_pure_list$lv1`. 

The lineage levels show decreasing numbers and proportions of samples with spoligotypes scoring 1 (second level: n = `r pure_n_list$lv2` (`r pc(pure_pc_list$lv2)`), third level: n = `r pure_n_list$lv3` (`r pc(pure_pc_list$lv3)`), fourth level: `r pure_n_list$lv4` (`r pc(pure_pc_list$lv4)`)) (**Figure \@ref(fig:level-prob-hist-display)**). Equivalently, the frequency of each spoligotype increased across lineages with each lineage level - at the first level, many spoligotyoes are unique to a lineage and hence only occur once; at the fourth level, more spoligotypes occur more than once indicating they are found in more than one lineage (**Figure \@ref(fig:spol-freq-hist-display)**). However the median percentage of samples with pure spoligotypes, while remaining low very, actually increased (second level: `r med_pc_samps_pure_list$lv2`, third level: `r med_pc_samps_pure_list$lv3`, fourth level: `r med_pc_samps_pure_list$lv4`) (**Figure \@ref(fig:spol-lin-results-plot-display)**). 

```{r lowest-lvl-spol-split-nums, echo = F, warning=F, message=F}

n_spols_lv4_split <- length(unique(lv4_filt$spoligotype))
n_lins_lv4_split <- length(unique(lv4_filt$lineage))

```

In a final analysis, we sought to find spoligotypes which offered discrimination between lineages at the lowest lineage level. Filtering the full results table (github.com/GaryNapier/spolpred/blob/master/results/spol_lin_levels_table.csv) to those spoligotypes with a correlation score >= 0.5, a minimum of 20 samples, and a minimum of 20% of samples having that spoligotype in the lineage (respective final numeric columns in **Table \@ref(tab:lowest-lvl-spol-split-table)**). This revealed `r n_spols_lv4_split` spoligotypes in `r n_lins_lv4_split` lineages meeting the criteria. These spoligotypes could be used in for example transmission cases to obtain further resolution among these lineages. 

### Discussion

Although many spoligotypes were shown to be purely correlated to a lineage, even to the lowest lineage level, a significant number of these were in a small proportion of the lineage samples. On the other hand, a number of spoligotypes were less predictive of lineage, but appeared in a large proportion of the lineage samples. These latter spoligotypes are of course more likely to be encountered, and so although they have a lower correlation score, should be considered useful. 

The percentage of spoligotypes purely associated to a lineage decreased significantly from `r pc(pure_pc_list$lv1)` at the first lineage level to `r pc(pure_pc_list$lv4)`) at the fourth, indicating that spoligotypes in general are only usefully predictive of perhaps the first two lineage levels. 

Spoligotypes, in retaining a phylogeographical nomenclature, remain valuable in tracking the global spread of MTBC clades. Although exhibiting more resolution and less noise, the lineage system lacks this phylogeographical element. Using the two systems in tandem ought therefore to provide the most value in global MTBC epidemiological investigations.

### Conclusions

We have presented a new means of predicting spoligotypes from WGS *in silico* that is fast and accurate. This software is freely available as part of the TB-Profiler package. Spoligotypes are useful in tracking the epidemiological spread of MTBC, but do not necessarly agree with the lineage system at lower resolution. We have clarified this relationship, which adds to the power of using a dual approach to strain typing. 

### Availability and requirements

Spolpred2 software is available as part of TB-Profiler. 

### List of abbreviations

|||
|:----|:----------------|
| AFRI | *M. africanum* |
| BOV | *M. bovis* (animal) |
| CAS | Central Asian Strains |
| DR | Direct repeat |
| EAI | East-African-Indian |
| ENA | European Nucleotide Archive |
| H | Spoligotype family H |
| L | Lineage |
| LAM | Latin America-Mediterranean |
| *Mtb* | *Mycobacterium tuberculosis* | 
| MTBC | *Mycobacterium tuberculosis* complex |
| PCR | Polymerase chain reaction |
| PINI2 | *M. pinnipedii* (animal) |
| RD | Region of difference |
| S | Spoligotype family S |
| SNP | Single nucleotide polymorphism |
| T | Spoligotype family T |
| WGS | Whole genome sequencing |

**Declarations**

**Ethics approval and consent to participate**
Not applicable

**Consent for publication**
Not applicable 

**Competing interests**
The authors declare that they have no competing interests

**Funding**
GN is funded by an BBSRC-LiDO PhD studentship. JEP is funded by a Newton Institutional Links Grant (British Council, no. 261868591). TGC is funded by the Medical Research Council UK (Grant no. MR/M01360X/1, MR/N010469/1, MR/R025576/1, and MR/R020973/1). SC is funded by Medical Research Council UK grants (ref. MR/M01360X/1, MR/R025576/1, and MR/R020973/1). The authors declare no conflicts of interest. The funders had no role in the design of the study and collection, analysis, and interpretation of data and in writing the manuscript should be declared.

**Authors' contributions**
JEP and TGC conceived and directed the project. GN performed bioinformatic and statistical analyses under the supervision of SC, JEP and TGC. GN, SC, JEP and TGC interpreted results. GN wrote the first draft of the manuscript with inputs from JEP and TGC. All authors commented and edited on various versions of the draft manuscript and approved the final version. GN, SC, JEP, and TGC compiled the final manuscript. 

**Acknowledgements**

## TABLES

<!-- ```{r times-table, echo = F, warning=F} -->

<!-- times_df <- data.frame(Accession = c("ERR1144974", "SRR6389896", "ERR038260", "ERR2513429"),  -->
<!--            Median_coverage = c(705, 508, 244, 100),  -->
<!--            fastq = c(40.904, 55.541, 16.628, 10.553),  -->
<!--            fasta = c(6.589, 6.736, 6.405, 6.429),  -->
<!--            bam = c(3.152, 3.323, 2.659, 2.587)) -->


<!-- names(times_df) <- c("Accession", "Median coverage", "fastq (s)", "fasta (s)", "bam (s)") -->

<!-- cap <- "Time taken from different input sources using a maximum of 8Gb RAM and 8 threads for four randomly chosen samples" -->

<!-- knitr::kable(times_df, row.names = F, caption = cap, format = "pipe") -->

<!-- ``` -->

```{r table-1-show, echo = F, warning=F}

cap <- sprintf("*M. tuberculosis* dataset (n=%s)", n_total_samps_before_filter)

knitr::kable(table_1_display, row.names = F, caption = cap, format = "pipe")

```
\* sub-lineage, spoligotype or number of countries

```{r lv1-lv2-n-spol-fam-show, echo = F, warning=F}

cap <- sprintf("Numbers of samples and unique spoligotypes for sub-lineages after filtering out spoligotypes occurring in fewer than five samples across %s *M. tuberculosis*",
               n_total_samps_after_filter)

knitr::kable(lv1_lv2_n_spol_fam, row.names = F, caption = cap, format = "pipe")

```
\*Number of spoligotypes duplicated on some occasions due to presence in multiple lineages/sublineages.

<!-- # ```{r main-lin-fam-group-tab, echo = F, warning=F} -->
<!-- # -->
<!-- # cap <- "Main *M.tb* lineages (1-7, plus animal strains) and their corresponding spoligotype families" -->
<!-- # -->
<!-- # knitr::kable(main_lin_family_group, row.names = F, caption = cap, format = "pipe") -->
<!-- # -->
<!-- # ``` -->

<!-- EAI = East-African-Indian; -->
<!-- CAS = Central Asian Strains; -->
<!-- H = Haarlem; -->
<!-- LAM = Latin American-Mediterranean; -->
<!-- S = Spoligotype family S; -->
<!-- T = Spoligotype family T; -->
<!-- AFRI = *M. africanum*; -->
<!-- BOV = *M. bovis* (animal); -->
<!-- PINI2 = *M. pinnipedii* (animal) -->

**Supplementary tables**

**Table S`r rare_spols_table_s_number`**: ATTACHED - `r rare_spols_table_file`

**Table S`r fam_table_s_number`**: ATTACHED - `r s2_table_file`

**Table S`r lin_fam_freq_tab_s_number**

```{r lin-fam-freq-tab, echo = F, warning=F}

cap <- "Frequency table of samples by main lineage and spoligotype family"

knitr::kable(fmt(lin_fam_freq_tab), row.names = F, caption = cap, format = "pipe")

```

**Table S`r lv4_filt_display_s_number`**

```{r lowest-lvl-spol-split-table, echo = F, warning=F}

cap <- "Spoligotypes discriminating lineages at the lowest level"

knitr::kable(lv4_filt_display, row.names = F, caption = cap, format = "pipe")

```


<!-- # ```{r spol-lin-levels-table, echo = F, warning=F} -->
<!-- #  -->
<!-- # cap <- "Correspondence between lineage and spoligotypes at each of the four levels of lineage." -->
<!-- #  -->
<!-- # knitr::kable(spol_lin_levels_table_display, row.names = F, caption = cap, format = "pipe") -->
<!-- #  -->
<!-- # ``` -->


## FIGURES

<!-- ```{r times, echo = F, warning=F, fig.cap = "Time taken from different input sources using a maximum of 8Gb RAM and 8 threads."} -->

<!-- knitr::include_graphics("../results/times.png") -->

<!-- ``` -->


<!-- ```{r level-prob-hist-display, echo = F, warning=F, message=F, fig.cap = "Histograms of correlation score for each lineage level 1-4"} -->

<!-- knitr::include_graphics(level_prob_hist_file) -->

<!-- ``` -->

<!-- ```{r spol-freq-hist-display, echo = F, warning=F, message=F, fig.cap = "Histograms of frequencies of spoligotypes for each lineage level 1-4"} -->

<!-- knitr::include_graphics(spol_freq_hist_file) -->

<!-- ``` -->


<!-- ```{r spol-lin-results-plot-display, echo = F, warning=F, message=F, fig.cap = "Boxplot: Aggregated percentages of samples with each spoligotype, within each lineage; Line: Total percentage of spoligotypes scoring 1 on our correlation score"} -->

<!-- knitr::include_graphics(spol_lin_results_plot_file) -->

<!-- ``` -->


<!-- ```{r region-family-plot, echo = F, warning=F, fig.cap="Heatmap of samples by spoligotype family and region of sample collection, normalised by Region (row)."} -->

<!-- knitr::include_graphics(region_family_plot_file) -->

<!-- ``` -->


```{r fam-lin-bar-show, echo = F, warning=F, fig.cap = "Spoligotype families and number of samples (a) by lineages; (b) across WHO regions"}

knitr::include_graphics(fam_lin_n_bar_file)

```
(a)

```{r fam-who-bar-show, echo = F, warning=F}

knitr::include_graphics(fam_who_n_bar_file)

```
(b)

```{r lin-1-7-tree, echo = F, warning=F, fig.cap = "Phylogenetic trees showing lineage or sub-lineage, family and spoligotypes"}

knitr::include_graphics(lin1_7_ggtree)

```

```{r lin-2-tree, echo = F, warning=F}

knitr::include_graphics(lin2_ggtree)

```

```{r lin-3-tree, echo = F, warning=F}

knitr::include_graphics(lin3_ggtree)

```

```{r lin-4-tree, echo = F, warning=F}

knitr::include_graphics(lin4_ggtree)

```

```{r lin-5-tree, echo = F, warning=F}

knitr::include_graphics(lin5_6_8_9_La_ggtree)

```

**Supplementary figures**

**Figure S`r spol_freq_hist_s_number`**

Frequencies of spoligotypes at each lineage level
```{r spol-freq-hist, echo = F, warning=F}

knitr::include_graphics(spol_freq_hist_file)

```

**Figure S`r map_figure_s_number`**

Global map of WHO regions. Inner piechart: Lineage; Outer piechart: Spoligotype family
```{r fam-lin-map, echo = F, warning=F}

knitr::include_graphics(fam_lin_map_file)

```

**Figure S`r trees_figures_s_number`** - ATTACHED - s_trees.pdf

## REFERENCES
























