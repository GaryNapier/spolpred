---
title: "Accurate *in silico* prediction of *Mycobacterium tuberculosis* spoligotypes from whole genome sequences"
output: 
  bookdown::word_document2: 
    fig_caption: yes
    table_caption: yes
    number_sections: no
    reference_docx: ../../pipeline/word_template/use_template.docx
bibliography: all_refs.bib
csl: biomed-central.csl
---

```{r setup, include=FALSE, echo = F, warning=F, message=F}

# SETUP ----

rm(list = ls())

knitr::opts_chunk$set(echo = F)
# options(scipen=1, digits=2)
options(scipen=999, digits = 3)
table_font_sz <- 8

```

```{r library, include=FALSE, echo = F, warning=F, message=F}

# library(sjmisc)
library(dplyr)
library(tibble)
library(stringr)

```

```{r functions, echo = F, warning=F, message=F}

source("https://raw.githubusercontent.com/GaryNapier/Packages_functions/master/Functions.R")

non_num_cols <- function(x){
  # Returns only the non-numeric columns of a dataframe
  x[!(sapply(x, is.numeric))]
}

expand_hierarchy <- function(df, group_by_col_name, hierarchy_to_expand_col_name){
  # Takes df like this:
  #   ID      Group
  # 1 samp_1  4.2.1.1
  # 2 samp_2  1.2.1.2.1
  
  # And makes this:
  #   ID    lin_level_1 lin_level_2 lin_level_3 lin_level_4 lin_level_5   max_lin
  # 1 samp_1          4         4.2       4.2.1     4.2.1.1        <NA>   4.2.1.1
  # 2 samp_2          1         1.2       1.2.1     1.2.1.2   1.2.1.2.1 1.2.1.2.1
  
  split_lins <- stringr::str_split(df[[hierarchy_to_expand_col_name]], "\\.")
  max_lin_len <- max(sapply(split_lins, length))
  mat <- matrix(nrow = length(df[[group_by_col_name]]), ncol = max_lin_len+1)
  mat[, 1] <- df[[group_by_col_name]]
  for(i in 1:nrow(mat)){
    for(lin_level in 1:max_lin_len){
      
      len_lin <- length(split_lins[[i]])
      
      if(lin_level > len_lin){
        mat[i, lin_level+1] <- NA
      }else{
        mat[i, lin_level+1] <- paste0(split_lins[[i]][1:lin_level], collapse = ".")
      }
    }
  }
  
  max_lin <- vector()
  for(i in seq(nrow(mat))){
    max_lin[i] <- mat[i, which.max(sapply(mat[i, -1], len_str))+1]
  }
  mat <- data.frame(cbind(mat, max_lin), stringsAsFactors = F)
  names(mat) <- c("id", paste0("lin_level_", 1:(ncol(mat)-2) ), "max_lin")
  return(mat)
}


top_spol_freq <- function(x, col){
  x %>% 
    group_by_(.dots = lazyeval::lazy(col)) %>% 
    dplyr::count(.dots = lazyeval::lazy(col), spoligotype) %>% 
    dplyr::arrange(desc(n), .by_group = TRUE) %>%
    dplyr::top_n(10, n) %>% 
    data.frame()
}


tab2df <- function(df){
  as.data.frame.matrix(table(df))
}

row_probs <- function(x){
  # Dataframe:
  # fruit   X1 X2 X3
  # mangoes 90 10 20
  # bananas 10 90 80
  # Get the row-wise proportions for each number:
  # fruit   X1     X2     X3
  # mangoes 0.7500 0.0833 0.167
  # bananas 0.0556 0.5000 0.444
  # i.e. mangoes-X1 = 90/(90+10+20) = 0.75
  
  # Strip off the non-numeric col(s)
  x_non_num <- non_num_cols(x)
  # Strip off numeric cols for calculation 
  x <- num_cols(x)
  # Pre-define an empty matrix
  mat <- matrix(nrow = nrow(x), ncol = ncol(x))
  # Loop over rows 
  for(row in seq(nrow(x))){
    # Loop over cols in row
    for(col in seq(ncol(x[row, ]))){
      # Divide the number by the total in the row
      mat[row, col] <- x[row, col]/sum(x[row, ])
    }
  }
  # Put table back together
  cbind(x_non_num, setNames(data.frame(mat), names(x)))
}

col_probs <- function(x){
  # Dataframe:
  # fruit   X1 X2 X3
  # mangoes 90 10 20
  # bananas 10 90 80
  # Get the col-wise proportions for each number:
  # col_probs(x)
  # fruit   L1  L2  L3
  # mangoes 0.9 0.1 0.2
  # bananas 0.1 0.9 0.8
  # i.e. mangoes-X1 = 90/(90+10) = 0.9
  
  # Strip off the non-numeric col(s)
  x_non_num <- non_num_cols(x)
  # Strip off numeric cols for calculation 
  x <- num_cols(x)
  # Pre-define an empty matrix
  mat <- matrix(nrow = nrow(x), ncol = ncol(x))
  # Loop over rows 
  for(row in seq(nrow(x))){
    # Loop over cols in row
    for(col in seq(ncol(x[row, ]))){
      # Divide the number by the total in the row
      mat[row, col] <- x[row, col]/sum(x[ ,col])
    }
  }
  # Put table back together
  cbind(x_non_num, setNames(data.frame(mat), names(x)))
}

sort_df_by_col_name <- function(df, col, decreasing = T){
  df[order(df[, col],  decreasing = decreasing),]
}

rm_dup_group <- function(df, col){
  # If rows of groups are repeated in a col, replace repeats with blank ("")
  # For final display of tables
  # e.g. 
  # in
  # lineage value
  # L1      10
  # L1      20
  # L1      25
  # L2      100
  # L2      3
  # L2      21
  # out
  # lineage value
  # L1      10
  #         20
  #         25
  # L2      100
  #         3
  #         21
  df[which(duplicated(df[col])), col] <- ""
  df
}

pc <- function(x){
  paste0(round(x, 1), "%")
}

list_to_df_group <- function(lst){
  # lst <- list(X = 1:5, Y = LETTERS[1:5])
  # $X
  # [1]  1  2  3  4  5 
  # $Y
  # [1] "A" "B" "C" "D" "E"
  # list_to_df_group(lst)
  #      group values
  # 1      X      1
  # 2      X      2
  # 3      X      3
  # 4      X      4
  # 5      X      5
  # 6      Y      A
  # 7      Y      B
  # 8      Y      C
  # 9      Y      D
  # 10     Y      E
  
  df_list <- list()
  for(i in seq(lst)){
    values_vect <- lst[[i]]
    nm <- names(lst[i])
    group_vect <- rep(nm, length(values_vect))
    df_list[[i]] <- data.frame(group = group_vect, values = values_vect)
  }
  do.call("rbind", df_list)
}

```

```{r variables, echo = F, warning=F, message=F}


```

```{r run-scripts, echo = F, warning=F, message=F}

# source("~/Documents/spolpred/r_scripts/spol_lin_levels_table.R")

```

```{r paths, echo = F, warning=F, message=F}

setwd("~/Documents/spolpred/r_scripts")

data_path <- "../data/"
results_path <- "../results/"

```

```{r files, echo = F, warning=F, message=F}

spol_data_file <- paste0(data_path, "spoligo_lineage.SNPs.csv")
spol_lin_levels_table_file <- paste0(results_path, "spol_lin_levels_table.csv")

lin1_7_ggtree <- paste0(results_path, "lin1_7_ggtree.png")
lin2_ggtree <- paste0(results_path, "lin2_ggtree.png")
lin3_ggtree <- paste0(results_path, "lin3_ggtree.png")
lin4_ggtree <- paste0(results_path, "lin4_ggtree.png")
lin5_6_8_9_La_ggtree <- paste0(results_path, "lin5_6_8_9_La_ggtree.png")

```

```{r read-in-data, echo = F, warning=F, message=F}

spol_data <- read.csv(spol_data_file, header = T, colClasses = c("spoligotype" = "character"))
spol_lin_levels_table <- read.csv(spol_lin_levels_table_file, colClasses = c("spoligotype" = "character"))

```

```{r clean-spol-data, echo = F, warning=F, message=F}

# Blank lineages - all 1.2.2.1 apparently
spol_data$lineage <- ifelse(spol_data$lineage == "", "lineage1.2.2.1", spol_data$lineage)
# Remove 0000000000000000000000000000000000000000000 - error apparently
spol_data <- subset(spol_data, !(spoligotype == "0000000000000000000000000000000000000000000"))

# Clean SIT and family cols
spol_data$SIT <- ifelse(spol_data$SIT == "", "-", spol_data$SIT)
spol_data$family <- ifelse(spol_data$family == "", "-", spol_data$family)

# Separate out all the metadata into lookup tables and data tables
lin_spol_sit_fam <- odr(unique(select(spol_data, lineage, spoligotype, SIT, family)))
sit_fam_spol <- odr(unique(select(spol_data, SIT, family, spoligotype)))
sit_fam <- odr(unique(select(spol_data, SIT, family)))

# Separate out the data for just correlating lineage and spol

# Remove "lineage" so that the levels can be split out
spol_data$lineage <- gsub("lineage", "", spol_data$lineage)

# Just retain sample, lin and spol cols 
spol_data <- select(spol_data, sample, lineage, spoligotype)

# Remove and store animal strains - need to process separately
# Or only analyse non-animal?
# animal <- subset(spol_data, grepl("La", lineage))
spol_data <- subset(spol_data, !(grepl("La", lineage)))

# Expand lineages, rbind animal back in and merge
exp <- expand_hierarchy_fill(spol_data, "sample", "lineage")
# data <- merge(rbind(spol_data, animal), exp,
#               by.x = "sample", by.y = "id", all.x = T, 
#               sort = F)
spol_data <- merge(spol_data, exp,
                   by.x = "sample", by.y = "id", all.x = T, 
                   sort = F)
```

```{r clean-results-table, echo = F, warning=F, message=F}

# Split into two tables - one with all results, and one top 5 spols by proportion of samples in lin 

spol_lin_levels_split <- split(spol_lin_levels_table, spol_lin_levels_table$level)

spol_lin_levels_top <- list()
for(level in names(spol_lin_levels_split)){
  
  level_data <- spol_lin_levels_split[[level]]
  level_data_split <- split(level_data, level_data$lineage)
  
  lin_list <- list()
  for(lin in names(level_data_split)){
    
      # Get the top 5 sample proportions and save as separate list
      top_col_prob <- sort(level_data_split[[lin]]$col_prob, decreasing = T)
      top_col_prob <- top_col_prob[1:5]
      
      # print(level_data_split[[lin]][which(level_data_split[[lin]]$col_prob %in% top_col_prob), ])
      lin_list[[lin]] <- level_data_split[[lin]][which(level_data_split[[lin]]$col_prob %in% top_col_prob), ]
  }
  spol_lin_levels_top[[level]] <- do.call("rbind", lin_list)
}
spol_lin_levels_top <- do.call("rbind", spol_lin_levels_top)

# Tidy top results table for display
spol_lin_levels_table_display <- rm_dup_group(spol_lin_levels_top, "lineage")
spol_lin_levels_table_display <- rm_dup_group(spol_lin_levels_table_display, "level")
# Need to wrap spol in quotes for otherwise printout is dodgy 
spol_lin_levels_table_display$spoligotype <- paste0("\"", spol_lin_levels_table_display$spoligotype, "\"")

names(spol_lin_levels_table_display) <- c("Level",
                                          "Lineage",
                                          "Spoligotype",
                                          "SIT",
                                          "Family",
                                          "Proportion in lin.",
                                          "n in lineage",
                                          "% of lin")

# spol_lin_levels_table$Level <- ifelse(is.na(spol_lin_levels_table$Level), "", spol_lin_levels_table$Level)

```

```{r basic-numbers-before-filter, echo = F, warning=F, message=F}

n_total_samps_before_filter <- length(spol_data$sample)
n_unique_lins_before_filter <- length(unique(spol_data$lineage))
n_unique_spol_before_filter <- length(unique(spol_data$spoligotype))

```

```{r filter-spol-five-samps, echo = F, warning=F}

# Keep only those with 5 or more samples per spoligo
spol_data <- spol_data %>% group_by(spoligotype) %>% filter(n() > 4) %>% data.frame()

```

```{r basic-numbers-after-filter, echo = F, warning=F, message=F}

n_total_samps_after_filter <- length(spol_data$sample)
n_unique_lins_after_filter <- length(unique(spol_data$lineage))
n_unique_spol_after_filter <- length(unique(spol_data$spoligotype))

```

```{r table-1, echo = F, warning=F, message=F}

n_pivot_lv1 <- reshape2::dcast(spol_data, lin_level_1 ~ 'n_samp', value.var = "sample", fun.aggregate = len_uniq)
spol_pivot_lv1 <- reshape2::dcast(spol_data, lin_level_1 ~ 'n_spol', value.var = "spoligotype", fun.aggregate = len_uniq)

n_pivot_lv2 <- reshape2::dcast(spol_data, lin_level_2 ~ 'n_samp', value.var = "sample", fun.aggregate = len_uniq)
spol_pivot_lv2 <- reshape2::dcast(spol_data, lin_level_2 ~ 'n_spol', value.var = "spoligotype", fun.aggregate = len_uniq)

table_1_lv1 <- data.frame(cbind(to_table(n_pivot_lv1, "col"), to_table(spol_pivot_lv1, "col")))
table_1_lv1 <- dplyr::select(table_1_lv1, -(lin_level_1.1),  -(Total), -(Total.1))
table_1_lv1 <- data.frame(cbind(level = rep("1", nrow(table_1_lv1)), table_1_lv1))

table_1_lv2 <- data.frame(cbind(to_table(n_pivot_lv2, "col"), to_table(spol_pivot_lv2, "col")))
table_1_lv2 <- dplyr::select(table_1_lv2, -(lin_level_2.1),  -(Total), -(Total.1))
table_1_lv2 <- data.frame(cbind(level = rep("2", nrow(table_1_lv2)), table_1_lv2))

table_1 <- rbind_force(table_1_lv1, table_1_lv2)

table_1 <- rm_dup_group(table_1, "level")

names(table_1) <- c("Level", "Lineage", "n samples", "n unique spoligotypes")

```

```{r spol-lin-results, echo = F, warning=F, message=F}

# Split out by lin level
spol_lin_levels_table_split <- split(spol_lin_levels_table, spol_lin_levels_table$level)

# Make lists to store stats for each level
pure_n_list <- list() # N spols pure at each level
pure_pc_list <- list() # Overall % of spols pure at each level
pc_samps_pure_vect_list <- data.frame() # Among the pure spols, take the vector of porportion of samps with each spol (col_prob col)
med_pc_samps_pure_list <- list() # Take the median of this vector

for(level in names(spol_lin_levels_table_split)){
  
  # Table of all the spoligotypes, pure and unpure
  all_spols_at_level <- spol_lin_levels_table_split[[level]]
  
  # Subset the pure ones
  pure <- subset(all_spols_at_level, prob == 1)
  
  # Add 'lv' to make it easier to subset lists later
  new_lv_name <- paste0("lv", level)
  
  # N spols pure at a level
  pure_n_list[[new_lv_name]] <- length(pure$spoligotype)
  # What % of all the spols at the level are pure?
  pure_pc_list[[new_lv_name]] <- (pure_n_list[[new_lv_name]]/length(all_spols_at_level$spoligotype))*100
  
  # Each pure spol at the level - get the % of samples with that spol
  pc_samps_pure_vect_list[[new_lv_name]] <- pure$col_prob
  # Save the median of this value
  med_pc_samps_pure_list[[new_lv_name]] <- round(median(pure$col_prob), 2)
  
}

```

```{r spol-lin-results-plot, echo = F, warning=F, message=F}

spol_lin_levels_table$col_prob_log10 <- log10(spol_lin_levels_table$col_prob)
spol_lin_levels_table$col_prob_log10 <- ifelse(is.infinite(spol_lin_levels_table$col_prob_log10), 
                                               min(spol_lin_levels_table$col_prob_log10[!is.infinite(spol_lin_levels_table$col_prob_log10)]),
                                               spol_lin_levels_table$col_prob_log10)

pure_pc_df <- list_to_df_group(pure_pc_list)
pure_pc_df$group <- 1:4

y_A <- seq(0, 2, 0.5)
y_B <- seq(0, 10, 2) 
y_C <- seq(20, 50, 10) 
y_D <- seq(60, 100, 20)
y_ax <- c(y_A, y_B, y_C, y_D)
spol_lin_results_plot <- ggplot()+
  geom_boxplot(data = spol_lin_levels_table, aes(x = as.factor(level), y = col_prob))+
  geom_line(data = pure_pc_df, aes(x=group, y=values, group=1), color="red", size = 1)+
  geom_point(data = pure_pc_df, aes(x=group, y=values), size = 3, colour = "blue")+
  xlab("Lineage level")+
  ylab("Percentage")+
  scale_y_log10(breaks = y_ax)+
  theme_bw()
spol_lin_results_plot_file <- "../results/spol_lin_results_plot.png"

ggsave(file = spol_lin_results_plot_file, plot = spol_lin_results_plot, width = 1100/5, height = 700/5, units = "mm")


```


| | |
| ----------- | ----------- |
|Gary Napier^1^ |	gary.napier@lshtm.ac.uk|
|Collaborators in Europe	| |
|Susana Campino^1^ | susana.campino@lshtm.ac.uk|
|Collaborators in Europe | |
|Jody Phelan^1^,^\*^ | jody.phelan@lshtm.ac.uk|
|Taane G. Clark^1,5,\*^ | taane.clark@lshtm.ac.uk|

1. Faculty of Infectious and Tropical Diseases, London School of Hygiene & Tropical Medicine, WC1E 7HT London, UK
2. Faculty of Epidemiology and Population Health, London School of Hygiene & Tropical Medicine, WC1E 7HT London, UK

\* joint authors

**Genome Medicine:**

**Abstract**

**Background:** Strain-types of *Mycobacterium tuberculosis*, the bacterial pathogen underlying tuberculosis disease (TB), have been associated with drug resistance, transmissibility, virulence, and host-pathogen interactions. Spoligotyping is an established genotyping technique, and historically used to describe strain-types globally. Advances in sequencing technologies have led to whole genome characterisation and determination of barcoding mutations for strain-types through a sub-lineage nomenclature. Given the large number of *M. tuberculosis*, there is a need to update the *in silico* profiling of spoligotypes, and link it to established sub-lineages. 

**Results:** 
    - Updating of spolpred and codes, software
    - Distributions of spoligotypes globally….
    - Correlation with new sublineage system.

**Conclusions:** 

**URL:** link to new spolpred2

**Keywords:** *Mycobacterium tuberculosis*, spoligotypes, lineages, phylogeny, spolpred

## Background

Napier [@Napier2020]
Brudey [@Brudey2006]
Kamerbeek [@Kamerbeek1997]
Coll (spolpred) [@Coll2012]


Tuberculosis is an infectious disease of high global burden caused by members of the *Mycobacterium tuberculosis* complex (MTBC), which includes XXX

- Different strain-types 
- phylogeography

Strain identification is crucial to address key epidemiological questions, providing XXXX what information XXXX

Spoligotyping is a fingerprinting PCR techniques [@Kamerbeek1997], which exploits the polymorphism harboured at the direct repeat (DR) locus of MTBC. It is based on the PCR amplification of 43 short unique sequences (termed spacers) contained between well-conserved 36-bp DRs and the subsequent hybridisation of the products onto a membrane with oligonucleotides complementary to each spacer. Since strains vary in the occurrence of spacers, each sample produces a distinctive spot pattern, which is then translated into a numerical code of 8 digits. More than 60 lineages/sub-lineages have been defined based on octal codes, each one normally showing a specific world distribution [@Brudey2006]. 

Advances in sequencing technologies will lead to whole genome bacterial characterisation




The lineage system characterised in Napier *et al.* (2020) [@Napier2020] names MTBC clades in a hierarchy of lineages and sublineages. The first level names the familiar major lineages as 1-9, plus animal strains. Sublineages consist of progressively finer resolution of the phylogenetic tree - for example lineage 1 is sub-divided into two main clades, 1.1 and 1.2, and so on **Figure \@ref(fig:lin-1-7-tree)**. These lineages and sublineages overlap with pre-established lineage systems such as regions of difference (RD), preserving major phylogenetic structural changes at the higher levels. Departing from these other lineage systems Napier *et al.* (2020) identifies finer resolution based on statistical differences in the branch lengths of the MTBC phylogenetic tree. The identifying markers of these clades, rather than being major structural changes of the MTBC genome, are individual (synonymous) SNPs with a fixation index (F~st~) score of 1, meaning that the SNP is unique to the clade. 

One of the central questions we consider here is at which level of the  Napier *et al.* (2020) lineage system spoligotypes are usefully associated. The phylogenetic trees in **Figure \@ref(fig:lin-1-7-tree)** clearly show a high degree of noise among the individual spoligotypes. While some patterns can be discerned between the major lineages (the overall spoligotype pattern of lineage 1 is clearly different to lineage 2 for example), it is less clear how spoligotypes vary with the lower levels of the lineage system (1.1, 1.1.1, 1.1.1.1 etc). We developed a score for each spoligotype measuring how purely each is associated to a lineage, at each level, weighted by sample size. This score is somewhat similar to the F~st~ fixiation index used in  Napier *et al.* (2020), and a score of 1 indicates the spoligotype occurs exclusively in a lineage (see **Methods**). 
 



Spoligotyping is still a technology of choice in some settings, and it is possible to **in silico** predict spoligotypes from SpolPred [@Coll2012]

With a great number of WGS Mtb available, we seek to update the definition of spoligotypes, check consistency with the sub-lineage system [@Napier2020], and assess their global distribution. This is achieved through developing software ("Spolpred2") to *in silico* genotype isolates, to predict the spoligotype from raw sequence reads. 



## Implementation

Description of the overall architecture of the software implementation

We have developed a XXXXXX executable to predict the spoligotype octal code from FASTQ files, including those from XXXXXXXX platforms. 

Appearance of all 43 queries is eventually translated into the octal code which is then matched to a spoligotype in the latest version of the international spoligotyping database (SpolDB5).

The software was run on 40k Mtb

Compared to the new sublineage system

## Methods

**Association of spoligotypes to lineages**

As there were many spoligotypes in low numbers of samples and therefore offering little predictive power, those appearing in fewer than five samples were excluded. Since we were interested in the strength of association between spoligotypes and the various levels of the Napier *et al.* (2020) lineage system, the lineages were parsed into a hierarchy for each round of analysis. For example, the first level analysed the association between each spoligotype and the main *Mtb* lineages 1-7. Next was the association between each spoligotype and the second level, represented by lineages 1.1, 1.2, 2.1, 2.2, etc. This hierarchy consisted of four levels, the last being e.g. lineage 1.1.1.1. As the system is hierarchical, any spoligotypes still appearing in samples at a higher level were included in the association calculations. Hence the results in **Table \@ref(tab:spol-lin-levels-table)** show for example lineage 3 appearing along with lineage 3.1 at the second lineage level. 

To assess how closely associated each spoligotype is to each lineage, at each level, a score was developed analagous to the fixation index F~st~ [@Weir1984]. This statistic assigns a score of 1 if an allele is fixed in a given population, and is not present outside that group. Similarly, the spoligotype score here assigns a score of 1 if a spoligotype is only found in a given lineage, and anything less than 1 indicates that the spoligotype is found in at least one other sample belonging to another lineage. 

Our calculation proceeded as follows: At each lineage level, a frequency table was made of samples for each spoligotype by lineage. For each lineage, the sample frequencies were first converted to a proportion of the total lineage sample size in order to weight the final association score by sample size. Then, for each spoligotype, this sample size proportion was calculated as a proportion of occurrences across each lineage (column "Proportion in lineage" in **Table \@ref(tab:spol-lin-levels-table)**).
      
These calculations yield a measure of how purely associated each spoligotype is to each lineage, at each level. A score of 1 for a spoligotype-lineage combination means a spoligotype only appears in that particular lineage. For example, spoligotype 1001111111111111111111111111000010110001111 scores 1 for lineage 1.1, meaning this spoligotype is only found in this lineage and no others (at the second level of the lineage system). 

## Results

**Association of spoligotypes to lineages**

Before filtering the spoligotypes to those appearing in five or more samples, our data consisted of `r fmt(n_total_samps_before_filter)` samples, `r fmt(n_unique_lins_before_filter)` unique lineages and sublineages, and `r fmt(n_unique_spol_before_filter)` unique spoligotypes. This filtering step resulted in `r fmt(n_total_samps_after_filter)` samples, `r fmt(n_unique_lins_after_filter)` unique lineages and `r fmt(n_unique_spol_after_filter)` distinct spoligotypes. 

Many spoligotypes were found to be exclusive to lineages at each level, however in many cases they nevertheless appeared in a relatively small proportion of that lineage's total samples, for example spoligotype 1101111111111111111001111111000010111111111 is only found in lineage 1, but appears in only 17.2% of that lineage's total samples. Conversely, less pure spoligotypes were found which in fact appeared in a large proportion of samples (spoligotype 0000000000000000000000000000000000111111111 scored 0.99 for association to lineage 2, but appears in 91.2% of its samples). Therefore, we include the number of samples with a given spoligotype as well as the percentage of the lineage's total samples in **Table \@ref(tab:spol-lin-levels-table)**. 

For simplicity, our results in **Table \@ref(tab:spol-lin-levels-table)** only show the top five most-closely associated spoligotypes for each lineage. These are ordered first by purity - i.e. the "Proportion in lineage score", then by percentage of samples in the lineage with this spoligotype (column "% of lineage"). The full table of results for the unfiltered spoligotypes can be found at github.com/GaryNapier/spolpred/blob/master/results/spol_lin_levels_table.csv

At the first lineage level (lineages 1-7), there were `r pure_n_list$lv1` (`r pc(pure_pc_list$lv1)`) spoligotypes appearing exclusively in their respective lineages, however the the median percentage of samples with a pure spoligotype across all lineages 1-7 was very low at `r med_pc_samps_pure_list$lv1`. 

The levels show decreasing numbers and proportions of samples with pure spoligotypes (second level: n = `r pure_n_list$lv2` (`r pc(pure_pc_list$lv2)`), third level: n = `r pure_n_list$lv3` (`r pc(pure_pc_list$lv3)`), fourth level: `r pure_n_list$lv4` (`r pc(pure_pc_list$lv4)`)), but the median percentage of samples with pure spoligotypes, while remaining low very, actually increased (second level: `r med_pc_samps_pure_list$lv2`, third level: `r med_pc_samps_pure_list$lv3`, fourth level: `r med_pc_samps_pure_list$lv4`) (**Figure `r spol-lin-results-plot-display`**). 

## Discussion

Although many spoligotypes were shown to be purely associated to a lineage, even to the lowest lineage level, a significant number of these were in a small proportion of the lineage samples. On the other hand, a number of spoligotypes were less predictive of lineage, but appeared in a large proportion of the lineage samples. These latter spoligotypes are of course more likely to be encountered, and so although they have a lower purity score, should be considered useful. 

The percentage of spoligotypes purely associated to a lineage decreased significantly from `r pure_pc_list$lv1`% at the first lineage level to `r pure_pc_list$lv4`% at the fourth, indicating that spoligotypes in general are only usefully predictive of perhaps the first two levels. 

## Conclusions

## Availability and requirements**

## List of abbreviations

**Declarations**

**Ethics approval and consent to participate**
Not applicable

**Consent for publication**
Not applicable 

**Availability of data and materials**

**Competing interests**
The authors declare that they have no competing interests

**Funding**
GN is funded by an BBSRC-LiDO PhD studentship. JEP is funded by a Newton Institutional Links Grant (British Council, no. 261868591). TGC is funded by the Medical Research Council UK (Grant no. MR/M01360X/1, MR/N010469/1, MR/R025576/1, and MR/R020973/1). SC is funded by Medical Research Council UK grants (ref. MR/M01360X/1, MR/R025576/1, and MR/R020973/1). The authors declare no conflicts of interest. The funders had no role in the design of the study and collection, analysis, and interpretation of data and in writing the manuscript should be declared.

**Authors' contributions**
XXX, JEP and TGC conceived and directed the project. XXXXXXX contributed data. GN performed bioinformatic and statistical analyses under the supervision of SC, JEP and TGC. GN, SC, JEP and TGC interpreted results. GN wrote the first draft of the manuscript with inputs from JEP and TGC. All authors commented and edited on various versions of the draft manuscript and approved the final version. GN, SC, JEP, and TGC compiled the final manuscript. 

**Acknowledgements**

## FIGURES

Boxplot: Aggregated percentages of samples with each spoligotype, within each lineage; Line: Total percentage of 'pure' spoligotypes.

```{r spol-lin-results-plot-display, echo = F, warning=F, message=F, fig.cap = "Boxplot: Aggregated percentages of samples within each lineage with 'pure' spoligotypes; Line: Total percentage of 'pure' spoligotypes."}
  
knitr::include_graphics(spol_lin_results_plot_file)

```


```{r lin-1-7-tree, echo = F, warning=F, fig.cap = "Phylogenetic trees showing lineage and spoligotypes."}

knitr::include_graphics(lin1_7_ggtree)

```

```{r lin-2-tree, echo = F, warning=F}

knitr::include_graphics(lin2_ggtree)

```

```{r lin-3-tree, echo = F, warning=F}

knitr::include_graphics(lin3_ggtree)


```

```{r lin-4-tree, echo = F, warning=F}

knitr::include_graphics(lin4_ggtree)


```

```{r lin-5-tree, echo = F, warning=F}

knitr::include_graphics(lin5_6_8_9_La_ggtree)


```

## TABLES

```{r table-1-show, echo = F, warning=F}

cap <- "Numbers of samples and unique spoligotypes for the first two lineage levels after filtering out spoligotypes occurring in fewer than five samples"

knitr::kable(table_1, row.names = F, caption = cap, format = "pipe")


```

```{r spol-lin-levels-table, echo = F, warning=F}

cap <- "Correspondence between lineage and spoligotypes at each of the four levels of lineage."

knitr::kable(spol_lin_levels_table_display, row.names = F, caption = cap, format = "pipe")

```




## REFERENCES
























