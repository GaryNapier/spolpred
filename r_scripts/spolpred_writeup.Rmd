---
title: "Accurate *in silico* prediction of *Mycobacterium tuberculosis* spoligotypes from whole genome sequences"
output: 
  bookdown::word_document2: 
    fig_caption: yes
    table_caption: yes
    number_sections: no
    reference_docx: use_template.docx
bibliography: all_refs.bib
csl: biomed-central.csl
---

```{r setup, include=FALSE, echo = F, warning=F, message=F}

# SETUP ----

rm(list = ls())

knitr::opts_chunk$set(echo = F)
# options(scipen=1, digits=2)
options(scipen=999, digits = 3)
table_font_sz <- 8

```

```{r library, include=FALSE, echo = F, warning=F, message=F}

# library(sjmisc)
library(dplyr)
library(tibble)
library(stringr)

```

```{r functions, echo = F, warning=F, message=F}

source("https://raw.githubusercontent.com/GaryNapier/Packages_functions/master/Functions.R")

non_num_cols <- function(x){
  # Returns only the non-numeric columns of a dataframe
  x[!(sapply(x, is.numeric))]
}

expand_hierarchy <- function(df, group_by_col_name, hierarchy_to_expand_col_name){
  # Takes df like this:
  #   ID      Group
  # 1 samp_1  4.2.1.1
  # 2 samp_2  1.2.1.2.1
  
  # And makes this:
  #   ID    lin_level_1 lin_level_2 lin_level_3 lin_level_4 lin_level_5   max_lin
  # 1 samp_1          4         4.2       4.2.1     4.2.1.1        <NA>   4.2.1.1
  # 2 samp_2          1         1.2       1.2.1     1.2.1.2   1.2.1.2.1 1.2.1.2.1
  
  split_lins <- stringr::str_split(df[[hierarchy_to_expand_col_name]], "\\.")
  max_lin_len <- max(sapply(split_lins, length))
  mat <- matrix(nrow = length(df[[group_by_col_name]]), ncol = max_lin_len+1)
  mat[, 1] <- df[[group_by_col_name]]
  for(i in 1:nrow(mat)){
    for(lin_level in 1:max_lin_len){
      
      len_lin <- length(split_lins[[i]])
      
      if(lin_level > len_lin){
        mat[i, lin_level+1] <- NA
      }else{
        mat[i, lin_level+1] <- paste0(split_lins[[i]][1:lin_level], collapse = ".")
      }
    }
  }
  
  max_lin <- vector()
  for(i in seq(nrow(mat))){
    max_lin[i] <- mat[i, which.max(sapply(mat[i, -1], len_str))+1]
  }
  mat <- data.frame(cbind(mat, max_lin), stringsAsFactors = F)
  names(mat) <- c("id", paste0("lin_level_", 1:(ncol(mat)-2) ), "max_lin")
  return(mat)
}


top_spol_freq <- function(x, col){
  x %>% 
    group_by_(.dots = lazyeval::lazy(col)) %>% 
    dplyr::count(.dots = lazyeval::lazy(col), spoligotype) %>% 
    dplyr::arrange(desc(n), .by_group = TRUE) %>%
    dplyr::top_n(10, n) %>% 
    data.frame()
}


tab2df <- function(df){
  as.data.frame.matrix(table(df))
}

row_probs <- function(x){
  # Dataframe:
  # fruit   X1 X2 X3
  # mangoes 90 10 20
  # bananas 10 90 80
  # Get the row-wise proportions for each number:
  # fruit   X1     X2     X3
  # mangoes 0.7500 0.0833 0.167
  # bananas 0.0556 0.5000 0.444
  # i.e. mangoes-X1 = 90/(90+10+20) = 0.75
  
  # Strip off the non-numeric col(s)
  x_non_num <- non_num_cols(x)
  # Strip off numeric cols for calculation 
  x <- num_cols(x)
  # Pre-define an empty matrix
  mat <- matrix(nrow = nrow(x), ncol = ncol(x))
  # Loop over rows 
  for(row in seq(nrow(x))){
    # Loop over cols in row
    for(col in seq(ncol(x[row, ]))){
      # Divide the number by the total in the row
      mat[row, col] <- x[row, col]/sum(x[row, ])
    }
  }
  # Put table back together
  cbind(x_non_num, setNames(data.frame(mat), names(x)))
}

col_probs <- function(x){
  # Dataframe:
  # fruit   X1 X2 X3
  # mangoes 90 10 20
  # bananas 10 90 80
  # Get the col-wise proportions for each number:
  # col_probs(x)
  # fruit   L1  L2  L3
  # mangoes 0.9 0.1 0.2
  # bananas 0.1 0.9 0.8
  # i.e. mangoes-X1 = 90/(90+10) = 0.9
  
  # Strip off the non-numeric col(s)
  x_non_num <- non_num_cols(x)
  # Strip off numeric cols for calculation 
  x <- num_cols(x)
  # Pre-define an empty matrix
  mat <- matrix(nrow = nrow(x), ncol = ncol(x))
  # Loop over rows 
  for(row in seq(nrow(x))){
    # Loop over cols in row
    for(col in seq(ncol(x[row, ]))){
      # Divide the number by the total in the row
      mat[row, col] <- x[row, col]/sum(x[ ,col])
    }
  }
  # Put table back together
  cbind(x_non_num, setNames(data.frame(mat), names(x)))
}

sort_df_by_col_name <- function(df, col, decreasing = T){
  df[order(df[, col],  decreasing = decreasing),]
}

rm_dup_group <- function(df, col){
  # If rows of groups are repeated in a col, replace repeats with blank ("")
  # For final display of tables
  # e.g. 
  # in
  # lineage value
  # L1      10
  # L1      20
  # L1      25
  # L2      100
  # L2      3
  # L2      21
  # out
  # lineage value
  # L1      10
  #         20
  #         25
  # L2      100
  #         3
  #         21
  df[which(duplicated(df[col])), col] <- ""
  df
}

```

```{r variables, echo = F, warning=F, message=F}


```

```{r run-scripts, echo = F, warning=F, message=F}

# source("~/Documents/spolpred/r_scripts/spol_lin_levels_table.R")

```

```{r paths, echo = F, warning=F, message=F}

setwd("~/Documents/spolpred/r_scripts")

data_path <- "../data/"
results_path <- "../results/"

```

```{r files, echo = F, warning=F, message=F}

spol_data_file <- paste0(data_path, "spoligo_lineage.SNPs.csv")
stopifnot(file.exists(spol_data_file))
spol_lin_levels_table_file <- paste0(results_path, "spol_lin_levels_table.csv")
stopifnot(file.exists(spol_lin_levels_table_file))

lin1_7_ggtree <- paste0(results_path, "lin1_7_ggtree.png")
lin2_ggtree <- paste0(results_path, "lin2_ggtree.png")
lin3_ggtree <- paste0(results_path, "lin3_ggtree.png")
lin4_ggtree <- paste0(results_path, "lin4_ggtree.png")
lin5_6_8_9_La_ggtree <- paste0(results_path, "l5_6_8_9_La_ggtree.png")

file.exists(lin5_6_8_9_La_ggtree)

```

```{r read-in-data, echo = F, warning=F, message=F}

spol_data <- read.csv(spol_data_file, header = T, colClasses = c("spoligotype" = "character"))
spol_lin_levels_table <- read.csv(spol_lin_levels_table_file, colClasses = c("Spoligotype" = "character"))

```

```{r clean-data, echo = F, warning=F, message=F}

# Blank lineages - all 1.2.2.1 apparently
spol_data$lineage <- ifelse(spol_data$lineage == "", "lineage1.2.2.1", spol_data$lineage)
# Remove 0000000000000000000000000000000000000000000 - error apparently
spol_data <- subset(spol_data, !(spoligotype == "0000000000000000000000000000000000000000000"))

# Clean SIT and family cols
spol_data$SIT <- ifelse(spol_data$SIT == "", "-", spol_data$SIT)
spol_data$family <- ifelse(spol_data$family == "", "-", spol_data$family)

# Separate out all the metadata into lookup tables and data tables
lin_spol_sit_fam <- odr(unique(select(spol_data, lineage, spoligotype, SIT, family)))
sit_fam_spol <- odr(unique(select(spol_data, SIT, family, spoligotype)))
sit_fam <- odr(unique(select(spol_data, SIT, family)))

# Separate out the data for just correlating lineage and spol

# Remove "lineage" so that the levels can be split out
spol_data$lineage <- gsub("lineage", "", spol_data$lineage)

# Just retain sample, lin and spol cols 
spol_data <- select(spol_data, sample, lineage, spoligotype)

# Remove and store animal strains - need to process separately
# Or only analyse non-animal?
# animal <- subset(spol_data, grepl("La", lineage))
spol_data <- subset(spol_data, !(grepl("La", lineage)))

# Expand lineages, rbind animal back in and merge
exp <- expand_hierarchy_fill(spol_data, "sample", "lineage")
# data <- merge(rbind(spol_data, animal), exp,
#               by.x = "sample", by.y = "id", all.x = T, 
#               sort = F)
spol_data <- merge(spol_data, exp,
                   by.x = "sample", by.y = "id", all.x = T, 
                   sort = F)

```

```{r basic-numbers-before-filter, echo = F, warning=F, message=F}

n_total_samps_before_filter <- length(spol_data$sample)
n_unique_lins_before_filter <- length(unique(spol_data$lineage))
n_unique_spol_before_filter <- length(unique(spol_data$spoligotype))

```

```{r filter-spol-five-samps, echo = F, warning=F}

# Keep only those with 5 or more samples per spoligo
spol_data <- spol_data %>% group_by(spoligotype) %>% filter(n() > 4) %>% data.frame()


```

```{r basic-numbers-after-filter, echo = F, warning=F, message=F}

n_total_samps_after_filter <- length(spol_data$sample)
n_unique_lins_after_filter <- length(unique(spol_data$lineage))
n_unique_spol_after_filter <- length(unique(spol_data$spoligotype))

```

```{r table-1, echo = F, warning=F, message=F}

n_pivot <- reshape2::dcast(spol_data, lin_level_1 ~ 'n_samp', value.var = "sample", fun.aggregate = len_uniq)
spol_pivot <- reshape2::dcast(spol_data, lin_level_1 ~ 'n_spol', value.var = "spoligotype", fun.aggregate = len_uniq)
table_1 <- data.frame(cbind(to_table(n_pivot, "col"), to_table(spol_pivot, "col")))
table_1 <- dplyr::select(table_1, -(lin_level_1.1),  -(Total), -(Total.1))
names(table_1) <- c("Lineage (level 1)", "n samples", "n unique spoligotypes")

```


**Abstract**

**Background:** 

**Results**: 

**Conclusions**: 

**URL**: link to new spolpred2

**Keywords**: 

## Background

Napier [@Napier2020]
Brudey [@Brudey2006]
Kamerbeek [@Kamerbeek1997]
Coll (spolpred) [@Coll2012]

## Implementation

## Results

### Correlation of spoligotypes with lineages

Before filtering spoligotypes:

n samples  - `r fmt(n_total_samps_before_filter)`

n unique lineages - `r fmt(n_unique_lins_before_filter)`

n unique spoligotypes - `r fmt(n_unique_spol_before_filter)`

After filtering spoligotypes appearing in fewer than five samples and animal strains:

n samples - `r fmt(n_total_samps_after_filter)`

n unique lineages - `r fmt(n_unique_lins_after_filter)`

n unique spoligotypes - `r fmt(n_unique_spol_after_filter)`


## Discussion

## Conclusions

## Availability and requirements**

## List of abbreviations

**Declarations**

**Ethics approval and consent to participate**
Not applicable

**Consent for publication**
Not applicable 

**Availability of data and materials**

**Competing interests**
The authors declare that they have no competing interests

**Funding**
GN is funded by an BBSRC-LiDO PhD studentship. JEP is funded by a Newton Institutional Links Grant (British Council, no. 261868591). TGC is funded by the Medical Research Council UK (Grant no. MR/M01360X/1, MR/N010469/1, MR/R025576/1, and MR/R020973/1). SC is funded by Medical Research Council UK grants (ref. MR/M01360X/1, MR/R025576/1, and MR/R020973/1). The authors declare no conflicts of interest. The funders had no role in the design of the study and collection, analysis, and interpretation of data and in writing the manuscript should be declared.

**Authors' contributions**

**Acknowledgements**

## FIGURES

```{r lin-1-7-tree, echo = F, warning=F, fig.cap = "Phylogenetic trees showing lineage and spoligotypes."}

knitr::include_graphics(lin1_7_ggtree)

```

```{r lin-2-tree, echo = F, warning=F}

knitr::include_graphics(lin2_ggtree)

```

```{r lin-3-tree, echo = F, warning=F}

knitr::include_graphics(lin3_ggtree)


```

```{r lin-4-tree, echo = F, warning=F}

knitr::include_graphics(lin4_ggtree)


```

```{r lin-5-tree, echo = F, warning=F}

knitr::include_graphics(lin5_6_8_9_La_ggtree)


```

## TABLES

```{r table-1-show, echo = F, warning=F}

cap <- "Numbers of samples and unique spoligotypes by main lineage (level 1)"

knitr::kable(table_1, row.names = F, caption = cap, format = "pipe")


```

```{r spol-lin-levels-table, echo = F, warning=F}

cap <- "Correspondence between lineage and spoligotypes at each of the four levels of lineage."

knitr::kable(spol_lin_levels_table, row.names = F, caption = cap, format = "pipe")

```




## REFERENCES
























