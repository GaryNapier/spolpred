---
title: "Accurate *in silico* prediction of *Mycobacterium tuberculosis* spoligotypes from whole genome sequences"
output: 
  bookdown::word_document2: 
    fig_caption: yes
    table_caption: yes
    number_sections: no
    reference_docx: use_template.docx
bibliography: all_refs.bib
csl: biomed-central.csl
---

```{r setup, include=FALSE, echo = F, warning=F, message=F}

# SETUP ----

rm(list = ls())

knitr::opts_chunk$set(echo = F)
# options(scipen=1, digits=2)
options(scipen=999, digits = 3)
table_font_sz <- 8

```

```{r library, include=FALSE, echo = F, warning=F, message=F}

# library(sjmisc)
library(dplyr)
library(tibble)
library(stringr)

```

```{r functions, echo = F, warning=F, message=F}

source("https://raw.githubusercontent.com/GaryNapier/Packages_functions/master/Functions.R")

non_num_cols <- function(x){
  # Returns only the non-numeric columns of a dataframe
  x[!(sapply(x, is.numeric))]
}

expand_hierarchy <- function(df, group_by_col_name, hierarchy_to_expand_col_name){
  # Takes df like this:
  #   ID      Group
  # 1 samp_1  4.2.1.1
  # 2 samp_2  1.2.1.2.1
  
  # And makes this:
  #   ID    lin_level_1 lin_level_2 lin_level_3 lin_level_4 lin_level_5   max_lin
  # 1 samp_1          4         4.2       4.2.1     4.2.1.1        <NA>   4.2.1.1
  # 2 samp_2          1         1.2       1.2.1     1.2.1.2   1.2.1.2.1 1.2.1.2.1
  
  split_lins <- stringr::str_split(df[[hierarchy_to_expand_col_name]], "\\.")
  max_lin_len <- max(sapply(split_lins, length))
  mat <- matrix(nrow = length(df[[group_by_col_name]]), ncol = max_lin_len+1)
  mat[, 1] <- df[[group_by_col_name]]
  for(i in 1:nrow(mat)){
    for(lin_level in 1:max_lin_len){
      
      len_lin <- length(split_lins[[i]])
      
      if(lin_level > len_lin){
        mat[i, lin_level+1] <- NA
      }else{
        mat[i, lin_level+1] <- paste0(split_lins[[i]][1:lin_level], collapse = ".")
      }
    }
  }
  
  max_lin <- vector()
  for(i in seq(nrow(mat))){
    max_lin[i] <- mat[i, which.max(sapply(mat[i, -1], len_str))+1]
  }
  mat <- data.frame(cbind(mat, max_lin), stringsAsFactors = F)
  names(mat) <- c("id", paste0("lin_level_", 1:(ncol(mat)-2) ), "max_lin")
  return(mat)
}


top_spol_freq <- function(x, col){
  x %>% 
    group_by_(.dots = lazyeval::lazy(col)) %>% 
    dplyr::count(.dots = lazyeval::lazy(col), spoligotype) %>% 
    dplyr::arrange(desc(n), .by_group = TRUE) %>%
    dplyr::top_n(10, n) %>% 
    data.frame()
}


tab2df <- function(df){
  as.data.frame.matrix(table(df))
}

row_probs <- function(x){
  # Dataframe:
  # fruit   X1 X2 X3
  # mangoes 90 10 20
  # bananas 10 90 80
  # Get the row-wise proportions for each number:
  # fruit   X1     X2     X3
  # mangoes 0.7500 0.0833 0.167
  # bananas 0.0556 0.5000 0.444
  # i.e. mangoes-X1 = 90/(90+10+20) = 0.75
  
  # Strip off the non-numeric col(s)
  x_non_num <- non_num_cols(x)
  # Strip off numeric cols for calculation 
  x <- num_cols(x)
  # Pre-define an empty matrix
  mat <- matrix(nrow = nrow(x), ncol = ncol(x))
  # Loop over rows 
  for(row in seq(nrow(x))){
    # Loop over cols in row
    for(col in seq(ncol(x[row, ]))){
      # Divide the number by the total in the row
      mat[row, col] <- x[row, col]/sum(x[row, ])
    }
  }
  # Put table back together
  cbind(x_non_num, setNames(data.frame(mat), names(x)))
}

col_probs <- function(x){
  # Dataframe:
  # fruit   X1 X2 X3
  # mangoes 90 10 20
  # bananas 10 90 80
  # Get the col-wise proportions for each number:
  # col_probs(x)
  # fruit   L1  L2  L3
  # mangoes 0.9 0.1 0.2
  # bananas 0.1 0.9 0.8
  # i.e. mangoes-X1 = 90/(90+10) = 0.9
  
  # Strip off the non-numeric col(s)
  x_non_num <- non_num_cols(x)
  # Strip off numeric cols for calculation 
  x <- num_cols(x)
  # Pre-define an empty matrix
  mat <- matrix(nrow = nrow(x), ncol = ncol(x))
  # Loop over rows 
  for(row in seq(nrow(x))){
    # Loop over cols in row
    for(col in seq(ncol(x[row, ]))){
      # Divide the number by the total in the row
      mat[row, col] <- x[row, col]/sum(x[ ,col])
    }
  }
  # Put table back together
  cbind(x_non_num, setNames(data.frame(mat), names(x)))
}

sort_df_by_col_name <- function(df, col, decreasing = T){
  df[order(df[, col],  decreasing = decreasing),]
}

rm_dup_group <- function(df, col){
  # If rows of groups are repeated in a col, replace repeats with blank ("")
  # For final display of tables
  # e.g. 
  # in
  # lineage value
  # L1      10
  # L1      20
  # L1      25
  # L2      100
  # L2      3
  # L2      21
  # out
  # lineage value
  # L1      10
  #         20
  #         25
  # L2      100
  #         3
  #         21
  df[which(duplicated(df[col])), col] <- ""
  df
}

pc <- function(x){
  paste0(round(x, 1), "%")
}

```

```{r variables, echo = F, warning=F, message=F}


```

```{r run-scripts, echo = F, warning=F, message=F}

# source("~/Documents/spolpred/r_scripts/spol_lin_levels_table.R")

```

```{r paths, echo = F, warning=F, message=F}

setwd("~/Documents/spolpred/r_scripts")

data_path <- "../data/"
results_path <- "../results/"

```

```{r files, echo = F, warning=F, message=F}

spol_data_file <- paste0(data_path, "spoligo_lineage.SNPs.csv")
stopifnot(file.exists(spol_data_file))
spol_lin_levels_table_file <- paste0(results_path, "spol_lin_levels_table.csv")
stopifnot(file.exists(spol_lin_levels_table_file))

lin1_7_ggtree <- paste0(results_path, "lin1_7_ggtree.png")
lin2_ggtree <- paste0(results_path, "lin2_ggtree.png")
lin3_ggtree <- paste0(results_path, "lin3_ggtree.png")
lin4_ggtree <- paste0(results_path, "lin4_ggtree.png")
lin5_6_8_9_La_ggtree <- paste0(results_path, "lin5_6_8_9_La_ggtree.png")

```

```{r read-in-data, echo = F, warning=F, message=F}

spol_data <- read.csv(spol_data_file, header = T, colClasses = c("spoligotype" = "character"))
spol_lin_levels_table <- read.csv(spol_lin_levels_table_file, colClasses = c("spoligotype" = "character"))

```

```{r clean-spol-data, echo = F, warning=F, message=F}

# Blank lineages - all 1.2.2.1 apparently
spol_data$lineage <- ifelse(spol_data$lineage == "", "lineage1.2.2.1", spol_data$lineage)
# Remove 0000000000000000000000000000000000000000000 - error apparently
spol_data <- subset(spol_data, !(spoligotype == "0000000000000000000000000000000000000000000"))

# Clean SIT and family cols
spol_data$SIT <- ifelse(spol_data$SIT == "", "-", spol_data$SIT)
spol_data$family <- ifelse(spol_data$family == "", "-", spol_data$family)

# Separate out all the metadata into lookup tables and data tables
lin_spol_sit_fam <- odr(unique(select(spol_data, lineage, spoligotype, SIT, family)))
sit_fam_spol <- odr(unique(select(spol_data, SIT, family, spoligotype)))
sit_fam <- odr(unique(select(spol_data, SIT, family)))

# Separate out the data for just correlating lineage and spol

# Remove "lineage" so that the levels can be split out
spol_data$lineage <- gsub("lineage", "", spol_data$lineage)

# Just retain sample, lin and spol cols 
spol_data <- select(spol_data, sample, lineage, spoligotype)

# Remove and store animal strains - need to process separately
# Or only analyse non-animal?
# animal <- subset(spol_data, grepl("La", lineage))
spol_data <- subset(spol_data, !(grepl("La", lineage)))

# Expand lineages, rbind animal back in and merge
exp <- expand_hierarchy_fill(spol_data, "sample", "lineage")
# data <- merge(rbind(spol_data, animal), exp,
#               by.x = "sample", by.y = "id", all.x = T, 
#               sort = F)
spol_data <- merge(spol_data, exp,
                   by.x = "sample", by.y = "id", all.x = T, 
                   sort = F)
```

```{r clean-results-table, echo = F, warning=F, message=F}

# Split into two tables - one with all results, and one top 5 spols by proportion of samples in lin 

spol_lin_levels_split <- split(spol_lin_levels_table, spol_lin_levels_table$level)

spol_lin_levels_top <- list()
for(level in names(spol_lin_levels_split)){
  
  level_data <- spol_lin_levels_split[[level]]
  level_data_split <- split(level_data, level_data$lineage)
  
  lin_list <- list()
  for(lin in names(level_data_split)){
    
      # Get the top 5 sample proportions and save as separate list
      top_col_prob <- sort(level_data_split[[lin]]$col_prob, decreasing = T)
      top_col_prob <- top_col_prob[1:5]
      
      # print(level_data_split[[lin]][which(level_data_split[[lin]]$col_prob %in% top_col_prob), ])
      lin_list[[lin]] <- level_data_split[[lin]][which(level_data_split[[lin]]$col_prob %in% top_col_prob), ]
  }
  spol_lin_levels_top[[level]] <- do.call("rbind", lin_list)
}
spol_lin_levels_top <- do.call("rbind", spol_lin_levels_top)

# Tidy top results table for display
spol_lin_levels_table_display <- rm_dup_group(spol_lin_levels_top, "lineage")
spol_lin_levels_table_display <- rm_dup_group(spol_lin_levels_table_display, "level")
# Need to wrap spol in quotes for otherwise printout is dodgy 
spol_lin_levels_table_display$spoligotype <- paste0("\"", spol_lin_levels_table_display$spoligotype, "\"")

names(spol_lin_levels_table_display) <- c("Level",
                                          "Lineage",
                                          "Spoligotype",
                                          "SIT",
                                          "Family",
                                          "Proportion in lin.",
                                          "n in lineage",
                                          "% of lin")

# spol_lin_levels_table$Level <- ifelse(is.na(spol_lin_levels_table$Level), "", spol_lin_levels_table$Level)

```

```{r basic-numbers-before-filter, echo = F, warning=F, message=F}

n_total_samps_before_filter <- length(spol_data$sample)
n_unique_lins_before_filter <- length(unique(spol_data$lineage))
n_unique_spol_before_filter <- length(unique(spol_data$spoligotype))

```

```{r filter-spol-five-samps, echo = F, warning=F}

# Keep only those with 5 or more samples per spoligo
spol_data <- spol_data %>% group_by(spoligotype) %>% filter(n() > 4) %>% data.frame()

```

```{r basic-numbers-after-filter, echo = F, warning=F, message=F}

n_total_samps_after_filter <- length(spol_data$sample)
n_unique_lins_after_filter <- length(unique(spol_data$lineage))
n_unique_spol_after_filter <- length(unique(spol_data$spoligotype))

```

```{r table-1, echo = F, warning=F, message=F}

n_pivot <- reshape2::dcast(spol_data, lin_level_1 ~ 'n_samp', value.var = "sample", fun.aggregate = len_uniq)
spol_pivot <- reshape2::dcast(spol_data, lin_level_1 ~ 'n_spol', value.var = "spoligotype", fun.aggregate = len_uniq)
table_1 <- data.frame(cbind(to_table(n_pivot, "col"), to_table(spol_pivot, "col")))
table_1 <- dplyr::select(table_1, -(lin_level_1.1),  -(Total), -(Total.1))
names(table_1) <- c("Lineage (level 1)", "n samples", "n unique spoligotypes")

```

```{r spol-lin-results, echo = F, warning=F, message=F}

spol_lin_levels_table_split <- split(spol_lin_levels_table, spol_lin_levels_table$level)

pure_n_list <- list()
pure_pc_list <- list()
med_pc_samps_pure <- list()
for(level in names(spol_lin_levels_table_split)){
  
  x <- spol_lin_levels_table_split[[level]]
  pure <- subset(x, prob == 1)
  
  new_lv_name <- paste0("lv", level)
  
  pure_n_list[[new_lv_name]] <- length(pure$spoligotype)
  pure_pc_list[[new_lv_name]] <- (pure_n_list[[new_lv_name]]/length(x$prob))*100
  med_pc_samps_pure[[new_lv_name]] <- round(median(pure$col_prob), 2)
  
}

```

**Abstract**

**Background:** 

**Results**: 

**Conclusions**: 

**URL**: link to new spolpred2

**Keywords**: 

## Background

Napier [@Napier2020]
Brudey [@Brudey2006]
Kamerbeek [@Kamerbeek1997]
Coll (spolpred) [@Coll2012]

## Implementation

## Results

**Association of spoligotypes to lineages**

Before filtering the spoligotypes to those appearing in five or more samples, our data consisted of `r fmt(n_total_samps_before_filter)` samples, `r fmt(n_unique_lins_before_filter)` unique lineages and sublineages, and `r fmt(n_unique_spol_before_filter)` unique spoligotypes. This filtering step resulted in `r fmt(n_total_samps_after_filter)` samples, `r fmt(n_unique_lins_after_filter)` unique lineages and `r fmt(n_unique_spol_after_filter)` distinct spoligotypes. 

The lineage system deveolped in Napier *et al.* (2020) is a hierarchical one consisting of phylogenetic levels. One of the central questions we consider here is at which level spoligotypes are usefully associated to this lineage system. **Figure \@ref(fig:lin-1-7-tree)** clearly shows a high degree of noise among the individual spoligotypes. While some patterns can be discerned between the major lineages (the overall spoligotype pattern of lineage 1 is clearly different to lineage 2 for example), it is less clear how spoligotypes vary with the lower levels of the lineage system (1.1, 1.1.1, 1.1.1.1 etc). 

We developed a score for each spoligotype measuring how purely each is associated to a lineage, at each level, weighted by sample size. A score of 1 indicates the spoligotype occurs exclusively in a lineage (see **Methods**). 

Although many spoligotypes are exclusive to lineages, in many cases they nevertheless appeared in a relatively small proportion of that lineage's total samples, for example spoligotype 1101111111111111111001111111000010111111111 is only found in lineage 1, but appears in only 17.2% of that lineage's total samples. Conversely, less pure spoligotypes were found which in fact appeared in a large proportion of samples (spoligotype 0000000000000000000000000000000000111111111 scored 0.99 for association to lineage 2, but appears in 91.2% of its samples). Therefore, we include the number of samples with a given spoligotype as well as the percentage of the lineage's total samples in **Table \@ref(tab:spol-lin-levels-table)**. 

For simplicity, our results only show the top five most-closely associated spoligotypes for each lineage. These are ordered first by purity - i.e. the "Proportion in lineage score", then by percentage of samples in the lineage with this spoligotype (column "% of lineage"). The full table of results for the unfiltered spoligotypes can be found at github.com/GaryNapier/spolpred/blob/master/results/spol_lin_levels_table.csv

At the first lineage level (lineages 1-7), there were `r pure_n_list$lv1` (`r pc(pure_pc_list$lv1)`) spoligotypes appearing exclusively in their respective lineages, however the the median percentage of samples with a pure spoligotype across all lineages 1-7 was very low at `r med_pc_samps_pure$lv1`. 

The levels show decreasing numbers and proportions of samples with pure spoligotypes (second level: n = `r pure_n_list$lv2` (`r pc(pure_pc_list$lv2)`), third level: n = `r pure_n_list$lv3` (`r pc(pure_pc_list$lv3)`), fourth level: `r pure_n_list$lv4` (`r pc(pure_pc_list$lv4)`)), but the median percentage of samples with pure spoligotypes, while remaining low very, actually increased (second level: `r med_pc_samps_pure$lv2`, third level: `r med_pc_samps_pure$lv3`, fourth level: `r med_pc_samps_pure$lv4`). 

## Methods

**Association of spoligotypes to lineages**

As there were many spoligotypes in low numbers of samples and therefore offering little predictive power, those appearing in fewer than five samples were excluded. Since we were interested in the strength of association between spoligotypes and the various levels of the Napier *et al.* lineage system, the lineages were parsed into a hierarchy for each round of analysis. For example, the first level analysed the association between each spoligotype and the main *Mtb* lineages 1-7. Next was the association between each spoligotype and the second level, represented by lineages 1.1, 1.2, 2.1, 2.2, etc. This hierarchy consisted of four levels, the last being e.g. lineage 1.2.1.2. As the system is hierarchical, any spoligotypes still appearing in samples at a higher level were included in the association calculations. Hence the results in **Table \@ref(tab:spol-lin-levels-table)** show for example lineage 3 appearing along with lineage 3.1 at the second lineage level. 

At each lineage level, a frequency table was made of samples for each spoligotype by lineage. For each lineage, the sample frequencies were first converted to a proportion of the total lineage sample size in order to weight the final association score by sample size. Then, for each spoligotype, this sample size proportion was calculated as a proportion of occurrences across each lineage (column "Proportion in lineage" in **Table \@ref(tab:spol-lin-levels-table)**).
      
These calculations yield a measure of how purely associated each spoligotype is to each lineage, at each level. A score of 1 for a spoligotype-lineage combination means a spoligotype only appears in that particular lineage. For example, spoligotype "1001111111111111111111111111000010110001111" scores 1 for lineage 1.1, meaning this spoligotype is only found in this lineage and no others (at the second level of the lineage system). 

## Discussion

Although many spoligotypes were shown to be purely associated to a lineage, even to the lowest lineage level, a significant number of these were in a small proportion of the lineage samples. On the other hand, a number of spoligotypes were less predictive of lineage, but appeared in a large proportion of the lineage samples. These latter spoligotypes are of course more likely to be encountered, and so although they have a lower purity score, should be considered useful. 

The percentage of spoligotypes purely associated to a lineage decreased significantly from `r pure_pc_list$lv1` at the first lineage level to `r pure_pc_list$lv4` at the fourth, 
indicating that spoligotypes in general are only usefully predictive of perhaps the first two levels. 

## Conclusions

## Availability and requirements**

## List of abbreviations

**Declarations**

**Ethics approval and consent to participate**
Not applicable

**Consent for publication**
Not applicable 

**Availability of data and materials**

**Competing interests**
The authors declare that they have no competing interests

**Funding**
GN is funded by an BBSRC-LiDO PhD studentship. JEP is funded by a Newton Institutional Links Grant (British Council, no. 261868591). TGC is funded by the Medical Research Council UK (Grant no. MR/M01360X/1, MR/N010469/1, MR/R025576/1, and MR/R020973/1). SC is funded by Medical Research Council UK grants (ref. MR/M01360X/1, MR/R025576/1, and MR/R020973/1). The authors declare no conflicts of interest. The funders had no role in the design of the study and collection, analysis, and interpretation of data and in writing the manuscript should be declared.

**Authors' contributions**

**Acknowledgements**

## FIGURES

```{r lin-1-7-tree, echo = F, warning=F, fig.cap = "Phylogenetic trees showing lineage and spoligotypes."}

knitr::include_graphics(lin1_7_ggtree)

```

```{r lin-2-tree, echo = F, warning=F}

knitr::include_graphics(lin2_ggtree)

```

```{r lin-3-tree, echo = F, warning=F}

knitr::include_graphics(lin3_ggtree)


```

```{r lin-4-tree, echo = F, warning=F}

knitr::include_graphics(lin4_ggtree)


```

```{r lin-5-tree, echo = F, warning=F}

knitr::include_graphics(lin5_6_8_9_La_ggtree)


```

## TABLES

```{r table-1-show, echo = F, warning=F}

cap <- "Numbers of samples and unique spoligotypes by main lineage (level 1) after filtering out spoligotypes occurring in fewer than five samples"

knitr::kable(table_1, row.names = F, caption = cap, format = "pipe")


```

```{r spol-lin-levels-table, echo = F, warning=F}

cap <- "Correspondence between lineage and spoligotypes at each of the four levels of lineage."

knitr::kable(spol_lin_levels_table_display, row.names = F, caption = cap, format = "pipe")

```




## REFERENCES
























