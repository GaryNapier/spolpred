---
title: "Spoligotypes exploratory"
output: html_document
---

```{r setup, include=FALSE, echo = F, warning=F, message=F}

# SETUP ----

rm(list = ls())

knitr::opts_chunk$set(echo = F)
# options(scipen=1, digits=2)
options(scipen=999, digits = 3)
table_font_sz <- 8

```

```{r library, include=FALSE, echo = F, warning=F, message=F}

# library(sjmisc)
library(dplyr)
library(tibble)
library(stringr)

```

```{r functions, echo = F, warning=F, message=F}

source("https://raw.githubusercontent.com/GaryNapier/Packages_functions/master/Functions.R")

non_num_cols <- function(x){
  # Returns only the non-numeric columns of a dataframe
  x[!(sapply(x, is.numeric))]
}

expand_hierarchy <- function(df, group_by_col_name, hierarchy_to_expand_col_name){
  # Takes df like this:
  #   ID      Group
  # 1 samp_1  4.2.1.1
  # 2 samp_2  1.2.1.2.1
  
  # And makes this:
  #   ID    lin_level_1 lin_level_2 lin_level_3 lin_level_4 lin_level_5   max_lin
  # 1 samp_1          4         4.2       4.2.1     4.2.1.1        <NA>   4.2.1.1
  # 2 samp_2          1         1.2       1.2.1     1.2.1.2   1.2.1.2.1 1.2.1.2.1
  
  split_lins <- stringr::str_split(df[[hierarchy_to_expand_col_name]], "\\.")
  max_lin_len <- max(sapply(split_lins, length))
  mat <- matrix(nrow = length(df[[group_by_col_name]]), ncol = max_lin_len+1)
  mat[, 1] <- df[[group_by_col_name]]
  for(i in 1:nrow(mat)){
    for(lin_level in 1:max_lin_len){
      
      len_lin <- length(split_lins[[i]])
      
      if(lin_level > len_lin){
        mat[i, lin_level+1] <- NA
      }else{
        mat[i, lin_level+1] <- paste0(split_lins[[i]][1:lin_level], collapse = ".")
      }
    }
  }
  
  max_lin <- vector()
  for(i in seq(nrow(mat))){
    max_lin[i] <- mat[i, which.max(sapply(mat[i, -1], len_str))+1]
  }
  mat <- data.frame(cbind(mat, max_lin), stringsAsFactors = F)
  names(mat) <- c("id", paste0("lin_level_", 1:(ncol(mat)-2) ), "max_lin")
  return(mat)
}


top_spol_freq <- function(x, col){
  x %>% 
    group_by_(.dots = lazyeval::lazy(col)) %>% 
    dplyr::count(.dots = lazyeval::lazy(col), spoligotype) %>% 
    dplyr::arrange(desc(n), .by_group = TRUE) %>%
    dplyr::top_n(10, n) %>% 
    data.frame()
}


tab2df <- function(df){
  as.data.frame.matrix(table(df))
}

row_probs <- function(x){
  # Dataframe:
  # fruit   X1 X2 X3
  # mangoes 90 10 20
  # bananas 10 90 80
  # Get the row-wise proportions for each number:
  # fruit   X1     X2     X3
  # mangoes 0.7500 0.0833 0.167
  # bananas 0.0556 0.5000 0.444
  # i.e. mangoes-X1 = 90/(90+10+20) = 0.75
  
  # Strip off the non-numeric col(s)
  x_non_num <- non_num_cols(x)
  # Strip off numeric cols for calculation 
  x <- num_cols(x)
  # Pre-define an empty matrix
  mat <- matrix(nrow = nrow(x), ncol = ncol(x))
  # Loop over rows 
  for(row in seq(nrow(x))){
    # Loop over cols in row
    for(col in seq(ncol(x[row, ]))){
      # Divide the number by the total in the row
      mat[row, col] <- x[row, col]/sum(x[row, ])
    }
  }
  # Put table back together
  cbind(x_non_num, setNames(data.frame(mat), names(x)))
}

col_probs <- function(x){
  # Dataframe:
  # fruit   X1 X2 X3
  # mangoes 90 10 20
  # bananas 10 90 80
  # Get the col-wise proportions for each number:
  # col_probs(x)
  # fruit   L1  L2  L3
  # mangoes 0.9 0.1 0.2
  # bananas 0.1 0.9 0.8
  # i.e. mangoes-X1 = 90/(90+10) = 0.9
  
  # Strip off the non-numeric col(s)
  x_non_num <- non_num_cols(x)
  # Strip off numeric cols for calculation 
  x <- num_cols(x)
  # Pre-define an empty matrix
  mat <- matrix(nrow = nrow(x), ncol = ncol(x))
  # Loop over rows 
  for(row in seq(nrow(x))){
    # Loop over cols in row
    for(col in seq(ncol(x[row, ]))){
      # Divide the number by the total in the row
      mat[row, col] <- x[row, col]/sum(x[ ,col])
    }
  }
  # Put table back together
  cbind(x_non_num, setNames(data.frame(mat), names(x)))
}

sort_df_by_col_name <- function(df, col, decreasing = T){
  df[order(df[, col],  decreasing = decreasing),]
}

rm_dup_group <- function(df, col){
  # If rows of groups are repeated in a col, replace repeats with blank ("")
  # For final display of tables
  # e.g. 
  # in
  # lineage value
  # L1      10
  # L1      20
  # L1      25
  # L2      100
  # L2      3
  # L2      21
  # out
  # lineage value
  # L1      10
  #         20
  #         25
  # L2      100
  #         3
  #         21
  df[which(duplicated(df[col])), col] <- ""
  df
}

```

```{r variables, echo = F, warning=F, message=F}


```

```{r paths, echo = F, warning=F, message=F}

setwd("~/Documents/spolpred/r_scripts")

data_path <- "../data/"

```

#### Data file

```{r files, echo = T, warning=F, message=F}

spol_data_file <- paste0(data_path, "spoligo_lineage.SNPs.csv")

file.exists(spol_data_file)

```

```{r read-in-data, echo = T, warning=F, message=F}

# spol_data <- read.table(spol_data_file, header = T, sep = "\t", 
#                                    colClasses = c("spoligotype" = "character"))
spol_data <- read.csv(spol_data_file, header = T, 
                                   colClasses = c("spoligotype" = "character"))

```

```{r clean-data, echo = F, warning=F, message=F}

# Blank lineages - all 1.2.2.1 apparently
spol_data$lineage <- ifelse(spol_data$lineage == "", "lineage1.2.2.1", spol_data$lineage)
# Remove 0000000000000000000000000000000000000000000 - error apparently
spol_data <- subset(spol_data, !(spoligotype == "0000000000000000000000000000000000000000000"))

# Clean SIT and family cols
spol_data$SIT <- ifelse(spol_data$SIT == "", "-", spol_data$SIT)
spol_data$family <- ifelse(spol_data$family == "", "-", spol_data$family)

# Separate out all the metadata into lookup tables and data tables
lin_spol_sit_fam <- odr(unique(select(spol_data, lineage, spoligotype, SIT, family)))
sit_fam_spol <- odr(unique(select(spol_data, SIT, family, spoligotype)))
sit_fam <- odr(unique(select(spol_data, SIT, family)))

# Separate out the data for just correlating lineage and spol

# Remove "lineage" so that the levels can be split out
spol_data$lineage <- gsub("lineage", "", spol_data$lineage)

# Just retain sample, lin and spol cols 
spol_data <- select(spol_data, sample, lineage, spoligotype)

# Remove and store animal strains - need to process separately
# Or only analyse non-animal?
# animal <- subset(spol_data, grepl("La", lineage))
spol_data <- subset(spol_data, !(grepl("La", lineage)))

# Expand lineages, rbind animal back in and merge
exp <- expand_hierarchy_fill(spol_data, "sample", "lineage")
# data <- merge(rbind(spol_data, animal), exp,
#               by.x = "sample", by.y = "id", all.x = T, 
#               sort = F)
spol_data <- merge(spol_data, exp,
                   by.x = "sample", by.y = "id", all.x = T, 
                   sort = F)

# Fill in cols lin_level_1 and max_lin for animal
# spol_data$lin_level_1 <- ifelse(grepl("M", spol_data$lineage), spol_data$lineage, spol_data$lin_level_1)
# spol_data$lin_level_2 <- ifelse(grepl("M", spol_data$lineage), spol_data$lineage, spol_data$lin_level_2)
# spol_data$lin_level_3 <- ifelse(grepl("M", spol_data$lineage), spol_data$lineage, spol_data$lin_level_3)
# spol_data$lin_level_4 <- ifelse(grepl("M", spol_data$lineage), spol_data$lineage, spol_data$lin_level_4)
# spol_data$lin_level_5 <- ifelse(grepl("M", spol_data$lineage), spol_data$lineage, spol_data$lin_level_5)
# spol_data$max_lin <- ifelse(grepl("M", spol_data$lineage), spol_data$lineage, spol_data$max_lin)

# Remove everything except lin and spoligotype info
# data <- dplyr::select(data, sample:lineage, lin_level_1:max_lin)

# Keep only those with 5 or more samples per spoligo
spol_data <- spol_data %>% group_by(spoligotype) %>% filter(n() > 4) %>% data.frame()

```

### Basic stats

```{r basic-stats, echo = T, warning=F}

head(spol_data)
nrow(spol_data)
length(unique(spol_data$spoligotype))
length(unique(spol_data$lineage))

```

#### Lineage frequencies

```{r n-spol-lin, echo = T, warning=F}

table(spol_data$lineage) %>% as.data.frame() %>% arrange(Var1)
table(spol_data$lin_level_1) %>% as.data.frame() %>% arrange(Var1)
table(spol_data$lin_level_2) %>% as.data.frame() %>% arrange(Var1)
table(spol_data$lin_level_3) %>% as.data.frame() %>% arrange(Var1)
table(spol_data$lin_level_4) %>% as.data.frame() %>% arrange(Var1)
# table(spol_data$lin_level_5) %>% as.data.frame() %>% arrange(Var1)

```

#### Top ten spoligotypes per lineage, per level

```{r top-spol-lin, echo = T, warning=F}

top_spol_freq(spol_data, lin_level_1)
top_spol_freq(spol_data, lin_level_2)
top_spol_freq(spol_data, lin_level_3)
top_spol_freq(spol_data, lin_level_4)

```

#### Top ten most frequent spoligotypes and their lineages (per level)

```{r top-ten-spol-tables, echo = T, warning=F}

top_spol <- table(spol_data$spoligotype) %>% as.data.frame() %>% arrange(desc(Freq)) %>% top_n(10, Freq)
top_spol_sub <- subset(spol_data, spoligotype %in% top_spol$Var1)

table(top_spol_sub$spoligotype, top_spol_sub$lineage)
table(top_spol_sub$spoligotype, top_spol_sub$lin_level_1)
table(top_spol_sub$spoligotype, top_spol_sub$lin_level_2)
table(top_spol_sub$spoligotype, top_spol_sub$lin_level_3)
table(top_spol_sub$spoligotype, top_spol_sub$lin_level_4)

```

#### Count how many spoligotypes are in more than 1 lineage etc

```{r spol-counts, echo = F, warning = F}

lv1Summary <- spol_data %>% dplyr::count(spoligotype, lin_level_1)
lv2Summary <- spol_data %>% dplyr::count(spoligotype, lin_level_2)
lv3Summary <- spol_data %>% dplyr::count(spoligotype, lin_level_3)
lv4Summary <- spol_data %>% dplyr::count(spoligotype, lin_level_4)
lv5Summary <- spol_data %>% dplyr::count(spoligotype, lin_level_5)

SpoligoMultiLv1Lineage <- lv1Summary %>% dplyr::group_by(spoligotype) %>% filter(n()>1)
SpoligoMultiLv2Lineage <- lv2Summary %>% dplyr::group_by(spoligotype) %>% filter(n()>1)
SpoligoMultiLv3Lineage <- lv3Summary %>% dplyr::group_by(spoligotype) %>% filter(n()>1)
SpoligoMultiLv4Lineage <- lv4Summary %>% dplyr::group_by(spoligotype) %>% filter(n()>1)
SpoligoMultiLv5Lineage <- lv5Summary %>% dplyr::group_by(spoligotype) %>% filter(n()>1)

# in more than 2 lineages
SpoligoMultiLv1Lineage2 <- lv1Summary %>% dplyr::group_by(spoligotype) %>% filter(n()>2)
SpoligoMultiLv2Lineage2 <- lv2Summary %>% dplyr::group_by(spoligotype) %>% filter(n()>2)
SpoligoMultiLv3Lineage2 <- lv3Summary %>% dplyr::group_by(spoligotype) %>% filter(n()>2)
SpoligoMultiLv4Lineage2 <- lv4Summary %>% dplyr::group_by(spoligotype) %>% filter(n()>2)
SpoligoMultiLv5Lineage2 <- lv5Summary %>% dplyr::group_by(spoligotype) %>% filter(n()>2)

# in more than 3 lineages
SpoligoMultiLv1Lineage3 <- lv1Summary %>% dplyr::group_by(spoligotype) %>% filter(n()>3)
SpoligoMultiLv2Lineage3 <- lv2Summary %>% dplyr::group_by(spoligotype) %>% filter(n()>3)
SpoligoMultiLv3Lineage3 <- lv3Summary %>% dplyr::group_by(spoligotype) %>% filter(n()>3)
SpoligoMultiLv4Lineage3 <- lv4Summary %>% dplyr::group_by(spoligotype) %>% filter(n()>3)
SpoligoMultiLv5Lineage3 <- lv5Summary %>% dplyr::group_by(spoligotype) %>% filter(n()>3)

# in more than 4 lineages
SpoligoMultiLv1Lineage4 <- lv1Summary %>% dplyr::group_by(spoligotype) %>% filter(n()>4)
SpoligoMultiLv2Lineage4 <- lv2Summary %>% dplyr::group_by(spoligotype) %>% filter(n()>4)
SpoligoMultiLv3Lineage4 <- lv3Summary %>% dplyr::group_by(spoligotype) %>% filter(n()>4)
SpoligoMultiLv4Lineage4 <- lv4Summary %>% dplyr::group_by(spoligotype) %>% filter(n()>4)
SpoligoMultiLv5Lineage4 <- lv5Summary %>% dplyr::group_by(spoligotype) %>% filter(n()>4)

```

```{r spol-lineage-matching, echo = F, warning = F}

# Show consistency with the lineage scheme. Things that would be good to report are
# Number of spoligotypes per sublineage
# Identify spoligotypes that cut across multiple sublineages (i.e. have poor resulution)
# Identify sublineages that have multiple spoligotypes (i.e. better resolution using spoligotyping)

```



```{r dummy-predictions, echo = F, warning=F}

# x <- as.data.frame.matrix(table(dummy$spol, dummy$lineage))

fruit <- c("mangoes", "bananas")
L1 <- c(90, 100 - 90)
L2 <- c(100, 1000 - 100)
L3 <- c(20000, 100000 - 20000)

# fruit <- c("mangoes", "bananas")
# L1 <- c(90, 10)
# L2 <- c(10, 90)
# L3 <- c(20, 80)

x <- data.frame(fruit = fruit, L1 = L1, L2 = L2, L3 = L3)

x_num <- num_cols(x)

col_probs(x_num)

row_probs(col_probs(x_num))

# Dummy
dummy_file <- paste0(data_path, "dummy_data.csv")
dummy <- read.csv(dummy_file)

dummy_freqs <- as.data.frame.matrix(table(dummy))

##### ANSWER?? #####
row_probs(col_probs(dummy_freqs))
##### ANSWER?? #####

# Add more data so bootstrap sampling works better
dummy <- rbind(dummy, dummy, dummy)

# Add disproportionately more bananas to L1
dummy_bananas <- rbind(data.frame(spol = rep("bananas", 1000), lineage = rep("L1", 1000)), dummy)
# Balance out L2 and L3 a bit (only ~10 samples in L2 and L3)

dummy_bananas_freqs <- as.data.frame.matrix(table(dummy_bananas))

dummy_bananas_freqs

row_probs(col_probs(dummy_bananas_freqs))

# Compare to bootstrapping
dummy_bananas_split <- split(dummy_bananas, dummy_bananas$lineage)
min_samp_sz <- min(unlist(lapply(dummy_bananas_split, function(x){nrow(x)})))
n_samps <- plyr::round_any(floor(min_samp_sz*0.8), 10)

n_loops <- 100

bs_list <- list()
for(i in seq(n_loops)){
  bs_list[[i]] <- do.call("rbind", lapply(dummy_bananas_split, function(x){
    x[sample(nrow(x), n_samps), ]
    }))
}

bs_df <- do.call("rbind", bs_list)

tab2df(bs_df)

row_probs(tab2df(bs_df))

```

```{r spol-predictions-one-level, echo = F, warning=F}

# Try the above on the real data

# Add "lineage" back into lineages for ease of col names/list names
samp_spol <- dplyr::select(spol_data, sample, spoligotype)
non_samp_spol <- dplyr::select(spol_data, -sample, -spoligotype)
non_samp_spol_add_lin <- data.frame(apply(non_samp_spol, 2, function(x){
  paste0("lineage", x)
  }))
spol_data <- cbind(samp_spol, non_samp_spol_add_lin)

head(spol_data)

# ---

# Make a freq table
lv1_tab <- tab2df(select(spol_data, spoligotype, lin_level_2))

# Calc probs
lv1_col_prob <- col_probs(lv1_tab)
lv1_prob <- row_probs(col_probs(lv1_tab))

heaD(lv1_tab)
head(lv1_prob)
head(lv1_col_prob)

# Save the spoligotype
spol <- row.names(lv1_prob)
# Save the colnames before adding spoligotype
col_nms <- colnames(lv1_prob)
lv1_tab$spoligotype <- row.names(lv1_tab)
lv1_prob$spoligotype <- row.names(lv1_prob)
lv1_col_prob$spoligotype <- row.names(lv1_col_prob)

# Pull out the non-zeros for each lineage and store each lineage (col) as a separate list entry
lv1_list <- list()
for(col in col_nms){
  df <- lv1_prob[, c("spoligotype", col)]
  df <- df[which(df[, col] > 0), ]
  lv1_list[[col]] <- sort_df_by_col_name(df, col)
}

# Merge in sample numbers (freqs) and col probs (freqs as proportion)

head(lv1_tab)
head(lv1_prob)

for(lin in names(lv1_list)){
  
  # Merge in the freqs
  lv1_list[[lin]] <- setNames(merge(lv1_list[[lin]], lv1_tab[, c("spoligotype", lin)], 
        by = "spoligotype", 
        sort = F), 
        c("spoligotype", lin, "freq"))
  
  # Merge in the freq as a proportion of the total n samps per lin
  lv1_list[[lin]] <- setNames(merge(lv1_list[[lin]], lv1_col_prob[, c("spoligotype", lin)],
      by = "spoligotype",
      sort = F), 
      c("spoligotype", "prob", "freq", "col_prob"))

  # names(lv1_list[[lin]]) <- c("spol", "prob", "freq")
  
  # Sort
  lv1_list[[lin]] <- dplyr::arrange(lv1_list[[lin]], desc(prob), desc(freq))
  
  # Get the top 5 sample proportions
  top_col_prob <- sort(lv1_list[[lin]]$col_prob, decreasing = T)
  top_col_prob <- top_col_prob[1:5]
  lv1_list[[lin]] <- lv1_list[[lin]][which(lv1_list[[lin]]$col_prob %in% top_col_prob), ]
  
}

# Add the lineages as a col before r-binding
lv1_list <- lapply(seq(lv1_list), function(i){
  lin <- names(lv1_list[i])
  lv1_list[[i]]$lineage <- rep(lin, nrow(lv1_list[[i]])); lv1_list[[i]]
})
lv1_df <- do.call("rbind", lv1_list)

# Merge the SIT and family cols 
# merge(lv1_df, sit_fam_spol, by = "spoligotype", all.x = T, sort = F)
lv1_df <- plyr::join(lv1_df, sit_fam_spol, by = "spoligotype", type = "left")

# Tidy
lv1_df$col_prob <- round(lv1_df$col_prob*100, 1)
lv1_df <- dplyr::select(lv1_df, lineage, spoligotype, SIT, family, prob, freq, col_prob)
# Remove dup lins
lv1_df <- rm_dup_group(lv1_df, "lineage")

# names(lv1_df) <- c("lineage", "spoligotype", "SIT", "family", "weighted proportion \nof lineage", "n", "%n of lineage")

```

```{r spol-predictions-loop, echo = F, warning=F, R.options = list(width = 1000)}

# # Get levels
# levels <- names(spol_data)[grepl("level", names(spol_data))]
# # Don't go to level 5
# levels <- levels[-length(levels)]

levels <- c("lin_level_1", "lin_level_2", "lin_level_3", "lin_level_4")

# Loop over levels and calcualate top spoligotypes for each lin
level_results_list <- list()
for(level in levels){
  # Make freq table for the level
  lv_tab <- tab2df(dplyr::select(spol_data, spoligotype, all_of(level)))
  
  # Calc probs
  lv_col_prob <- col_probs(lv_tab)
  lv_prob <- row_probs(col_probs(lv_tab))
  
  # Save the spoligotype
  spol <- row.names(lv_prob)
  # Save the colnames before adding spoligotype
  col_nms <- colnames(lv_prob)
  lv_tab$spoligotype <- row.names(lv_tab)
  lv_prob$spoligotype <- row.names(lv_prob)
  lv_col_prob$spoligotype <- row.names(lv_col_prob)
  
  
  # Pull out the non-zeros for each lineage and store each lineage (col) as a separate list entry
  lv_list <- list()
  for(col in col_nms){
    df <- lv_prob[, c("spoligotype", col)]
    df <- df[which(df[, col] > 0), ]
    lv_list[[col]] <- sort_df_by_col_name(df, col)
  }
  
  # Merge in sample numbers (freqs) and col probs (freqs as proportion)
  
  for(lin in names(lv_list)){
  
    # Merge in the freqs
    lv_list[[lin]] <- setNames(merge(lv_list[[lin]], lv_tab[, c("spoligotype", lin)], 
          by = "spoligotype", 
          sort = F), 
          c("spoligotype", lin, "freq"))
    
    # Merge in the freq as a proportion of the total n samps per lin
    lv_list[[lin]] <- setNames(merge(lv_list[[lin]], lv_col_prob[, c("spoligotype", lin)],
        by = "spoligotype",
        sort = F), 
        c("spoligotype", "prob", "freq", "col_prob"))
  
    # names(lv1_list[[lin]]) <- c("spol", "prob", "freq")
    
    # Sort
    lv_list[[lin]] <- dplyr::arrange(lv_list[[lin]], desc(prob), desc(freq))
    
    # Get the top 5 sample proportions
    top_col_prob <- sort(lv_list[[lin]]$col_prob, decreasing = T)
    top_col_prob <- top_col_prob[1:5]
    lv_list[[lin]] <- lv_list[[lin]][which(lv_list[[lin]]$col_prob %in% top_col_prob), ]
    
  }
  
  # Add the lineages as a col before r-binding
  lv_list <- lapply(seq(lv_list), function(i){
    lin <- names(lv_list[i])
    lv_list[[i]]$lineage <- rep(lin, nrow(lv_list[[i]])); lv_list[[i]]
  })
  lv_df <- do.call("rbind", lv_list)
  
  # Merge the SIT and family cols 
  lv_df <- plyr::join(lv_df, sit_fam_spol, by = "spoligotype", type = "left")
  
  # Tidy
  lv_df$col_prob <- round(lv_df$col_prob*100, 1)
  lv_df <- dplyr::select(lv_df, lineage, spoligotype, SIT, family, prob, freq, col_prob)
  # Remove dup lins
  lv_df <- rm_dup_group(lv_df, "lineage")
  
  # names(lv_df) <- c("lineage", "spoligotype", "SIT", "family", "weighted proportion \nof lineage", "n", "%n of lineage")
  
  level_results_list[[level]] <- lv_df
  
}

level_results_list

```




















